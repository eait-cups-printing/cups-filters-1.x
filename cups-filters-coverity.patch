diff -up cups-filters-1.0.34/cupsfilters/image-tiff.c.coverity cups-filters-1.0.34/cupsfilters/image-tiff.c
--- cups-filters-1.0.34/cupsfilters/image-tiff.c.coverity	2012-06-22 18:10:47.000000000 +0200
+++ cups-filters-1.0.34/cupsfilters/image-tiff.c	2013-06-05 12:47:24.891983446 +0200
@@ -655,7 +655,12 @@ _cupsImageReadTIFF(
     case PHOTOMETRIC_PALETTE :
 	if (!TIFFGetField(tif, TIFFTAG_COLORMAP, &redcmap, &greencmap, &bluecmap))
 	{
-          fputs("DEBUG: No colormap tag in the file!\n", stderr);
+	  _TIFFfree(scanline);
+	  free(in);
+	  free(out);
+
+	  TIFFClose(tif);
+	  fputs("DEBUG: No colormap tag in the file!\n", stderr);
 	  fclose(fp);
 	  return (-1);
 	}
diff -up cups-filters-1.0.34/filter/pdftopdf/nup.cc.coverity cups-filters-1.0.34/filter/pdftopdf/nup.cc
--- cups-filters-1.0.34/filter/pdftopdf/nup.cc.coverity	2012-08-20 02:29:46.000000000 +0200
+++ cups-filters-1.0.34/filter/pdftopdf/nup.cc	2013-06-05 12:47:24.891983446 +0200
@@ -52,7 +52,7 @@ bool NupParameters::possible(int nup) //
 {
   // 1 2 3 4 6 8 9 10 12 15 16
   return (nup>=1)&&(nup<=16)&&
-         ( (nup!=5)||(nup!=7)||(nup!=11)||(nup!=13)||(nup!=14) );
+         ( (nup!=5)&&(nup!=7)&&(nup!=11)&&(nup!=13)&&(nup!=14) );
 }
 // }}}
 
diff -up cups-filters-1.0.34/filter/textcommon.c.coverity cups-filters-1.0.34/filter/textcommon.c
--- cups-filters-1.0.34/filter/textcommon.c.coverity	2012-06-22 18:10:47.000000000 +0200
+++ cups-filters-1.0.34/filter/textcommon.c	2013-06-05 12:47:24.892983432 +0200
@@ -608,6 +608,8 @@ TextMain(const char *name,	/* I - Name o
 
     if (PageColumns < 1)
     {
+      if (fp != stdin)
+        fclose(fp);
       fprintf(stderr, "ERROR: Bad columns value %d.\n", PageColumns);
       return (1);
     }
@@ -619,6 +621,8 @@ TextMain(const char *name,	/* I - Name o
 
     if (CharsPerInch <= 0.0)
     {
+      if (fp != stdin)
+        fclose(fp);
       fprintf(stderr, "ERROR: Bad cpi value %f.\n", CharsPerInch);
       return (1);
     }
@@ -630,6 +634,8 @@ TextMain(const char *name,	/* I - Name o
 
     if (LinesPerInch <= 0.0)
     {
+      if (fp != stdin)
+        fclose(fp);
       fprintf(stderr, "ERROR: Bad lpi value %f.", LinesPerInch);
       return (1);
     }
@@ -1110,6 +1116,9 @@ TextMain(const char *name,	/* I - Name o
 
   WriteEpilogue();
 
+  if (fp != stdin)
+    fclose(fp);
+
   if (ppd != NULL)
     ppdClose(ppd);
 
diff -up cups-filters-1.0.34/filter/texttopdf.c.coverity cups-filters-1.0.34/filter/texttopdf.c
--- cups-filters-1.0.34/filter/texttopdf.c.coverity	2013-03-01 19:06:58.000000000 +0100
+++ cups-filters-1.0.34/filter/texttopdf.c	2013-06-05 12:47:24.892983432 +0200
@@ -1220,6 +1220,7 @@ static void write_pretty_header() // {{{
       x = PageRight - PageLeft - 36.0f / LinesPerInch - stringwidth_x(pagestr);
   }
   write_font_str(x,y,ATTR_BOLD,pagestr,-1);
+  free(pagestr);
 
   pdfOut_printf(pdf,"Q\n");
 }
diff -up cups-filters-1.0.34/fontembed/embed_sfnt.c.coverity cups-filters-1.0.34/fontembed/embed_sfnt.c
--- cups-filters-1.0.34/fontembed/embed_sfnt.c.coverity	2012-06-22 18:10:47.000000000 +0200
+++ cups-filters-1.0.34/fontembed/embed_sfnt.c	2013-06-05 12:47:24.892983432 +0200
@@ -335,7 +335,7 @@ static const char *emb_otf_get_post_name
     if (gid<num_glyphs) {
       unsigned short idx=get_USHORT(post+34+2*gid);
       if (idx<258) {
-        if (gid<sizeof(macRoman)/sizeof(macRoman[0])) {
+        if (idx<sizeof(macRoman)/sizeof(macRoman[0])) {
           return macRoman[idx];
         } 
       } else if (idx<32768) {
diff -up cups-filters-1.0.34/utils/cups-browsed.c.coverity cups-filters-1.0.34/utils/cups-browsed.c
--- cups-filters-1.0.34/utils/cups-browsed.c.coverity	2013-04-10 17:37:14.000000000 +0200
+++ cups-filters-1.0.34/utils/cups-browsed.c	2013-06-05 12:47:52.970593829 +0200
@@ -403,6 +403,8 @@ gboolean handle_cups_queues(gpointer unu
 	  p->timeout = current_time + TIMEOUT_RETRY;
 	  break;
 	}
+	if (response)
+	  ippDelete(response);
 
 	/* No jobs, not default printer, remove the CUPS queue */
 	request = ippNewRequest(CUPS_DELETE_PRINTER);
@@ -635,6 +637,9 @@ void generate_local_queue(const char *ho
 	   ignore this remote printer */
 	debug_printf("cups-browsed: %s also taken, printer ignored.\n",
 		     local_queue_name);
+	free (backup_queue_name);
+	free (remote_host);
+	cupsFreeDests(num_dests, dests);
 	return;
       }
     }
@@ -716,6 +721,8 @@ void generate_local_queue(const char *ho
 			    name ? name : "", type, domain);
     free (uri);
   }
+  free (backup_queue_name);
+  free (remote_host);
 
   if (p)
     debug_printf("cups-browsed: Bonjour IDs: Service name: \"%s\", "
@@ -1562,8 +1569,11 @@ fail:
   if (conn)
     httpClose (conn);
 
+  if (server)
+    free (server);
+
   /* Call a new timeout handler so that we run again */
-  g_timeout_add_seconds (BrowseInterval, browse_poll, server);
+  g_timeout_add_seconds (BrowseInterval, browse_poll, data);
 
   /* Stop this timeout handler, we called a new one */
   return FALSE;
@@ -1933,13 +1943,13 @@ int main(int argc, char*argv[]) {
   }
 
   if (BrowsePoll) {
-    char **server;
-    for (server = BrowsePoll;
-	 *server;
-	 server++) {
+    size_t index;
+    for (index = 0;
+	 index < NumBrowsePoll;
+	 index++) {
       debug_printf ("cups-browsed: will browse poll %s every %ds\n",
-		    *server, BrowseInterval);
-      g_idle_add (browse_poll, *server);
+		    BrowsePoll[index], BrowseInterval);
+      g_idle_add (browse_poll, BrowsePoll[index]);
     }
   }
 
