diff --git a/COPYING b/COPYING
index 140aae1..4103e6e 100644
--- a/COPYING
+++ b/COPYING
@@ -145,21 +145,6 @@ Files: filter/imagetopdf*
 Copyright: 1993-2007, Easy Software Products
 License: GPL-2
 
-Files: filter/pdftoijs.cxx
- ppd/HP-PhotoSmart_Pro_B8300-hpijs-pdftoijs.ppd
-Copyright: 2008, Tobias Hoffmann
-  2008, BBR Inc.
-License: Expat
-
-Files: filter/pdftoopvp/*
-Copyright: 2003, 2004, 2005, 2006, AXE,Inc
-  2007, 2008, ModifiedBBR Inc.
-  2003, Glyph & Cog, LLC
-  2006, Fuji Xerox Printing Systems Co., Ltd
-  2006, Free Standards Group
-  2006, Canon Inc
-License: Expat
-
 Files: filter/pdftopdf/*
 Copyright: 2012 Tobias Hoffmann
  2006-2011, BBR Inc
diff --git a/INSTALL b/INSTALL
index e4c60ae..5d21a47 100644
--- a/INSTALL
+++ b/INSTALL
@@ -24,7 +24,7 @@ BEFORE YOU BEGIN
     Compaq, HP, SGI, and Sun.  BSD users should use GNU make (gmake) since BSD
     make does not support "include".
 
-    Poppler, libijs, freetype, fontconfig, and liblcms (liblcms2 recommended) 
+    Poppler, freetype, fontconfig, and liblcms (liblcms2 recommended)
     must be installed to be able to compile this package.
 
     Note that Poppler has to be compiled with the
diff --git a/Makefile.am b/Makefile.am
index cfefa5a..80260aa 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -482,61 +482,6 @@ EXTRA_DIST += \
 pkgfilter_PROGRAMS =
 pkgfilterdir = $(CUPS_SERVERBIN)/filter
 
-# ===========
-# PDF to OPVP
-# ===========
-if ENABLE_OPVP
-if ENABLE_POPPLER
-pkgfilter_PROGRAMS += \
-	pdftoopvp
-
-pkgfontconfigdir = $(sysconfdir)/$(FONTDIR)
-pkgfontconfig_DATA = filter/pdftoopvp/99pdftoopvp.conf
-endif
-endif
-EXTRA_DIST += filter/pdftoopvp/99pdftoopvp.conf
-
-pdftoopvp_SOURCES = \
-	filter/pdftoopvp/oprs/OPRS.cxx \
-	filter/pdftoopvp/oprs/OPRS.h \
-	filter/pdftoopvp/oprs/OPVPSplashClip.cxx \
-	filter/pdftoopvp/oprs/OPVPSplashClip.h \
-	filter/pdftoopvp/oprs/OPVPSplash.cxx \
-	filter/pdftoopvp/oprs/OPVPSplash.h \
-	filter/pdftoopvp/oprs/OPVPSplashPath.cxx \
-	filter/pdftoopvp/oprs/OPVPSplashPath.h \
-	filter/pdftoopvp/oprs/OPVPSplashState.cxx \
-	filter/pdftoopvp/oprs/OPVPSplashState.h \
-	filter/pdftoopvp/oprs/OPVPSplashXPath.cxx \
-	filter/pdftoopvp/oprs/OPVPSplashXPath.h \
-	filter/pdftoopvp/oprs/OPVPWrapper.cxx \
-	filter/pdftoopvp/oprs/OPVPWrapper.h \
-	filter/pdftoopvp/oprs/OPVPWrapper_0_2.cxx \
-	filter/pdftoopvp/oprs/OPVPWrapper_0_2.h \
-	filter/pdftoopvp/OPVPError.h \
-	filter/pdftoopvp/opvp/opvp_common.h \
-	filter/pdftoopvp/opvp/opvp.h \
-	filter/pdftoopvp/opvp/opvp_0_2_0.h \
-	filter/pdftoopvp/OPVPOutputDev.cxx \
-	filter/pdftoopvp/OPVPOutputDev.h \
-	filter/pdftoopvp/pdftoopvp.cxx
-pdftoopvp_CFLAGS = \
-	$(CUPS_CFLAGS) \
-	$(FREETYPE_CFLAGS) \
-	$(FONTCONFIG_CFLAGS) \
-	$(LIBPNG_CFLAGS) \
-	$(POPPLER_CFLAGS) \
-	-I$(srcdir)/filter/pdftoopvp/oprs \
-	-I$(srcdir)/filter/pdftoopvp/opvp
-pdftoopvp_CXXFLAGS = $(pdftoopvp_CFLAGS)
-pdftoopvp_LDADD = \
-	$(CUPS_LIBS) \
-	$(FREETYPE_LIBS) \
-	$(FONTCONFIG_LIBS) \
-	$(LIBPNG_LIBS) \
-	$(POPPLER_LIBS) \
-	$(DLOPEN_LIBS)
-
 # ==========
 # PDF to PDF 
 # ==========
@@ -619,10 +564,6 @@ endif
 if ENABLE_POPPLER
 pkgfilter_PROGRAMS += \
 	pdftoraster
-if ENABLE_IJS
-pkgfilter_PROGRAMS += \
-	pdftoijs
-endif
 endif
 if ENABLE_GHOSTSCRIPT
 pkgfilter_PROGRAMS += \
@@ -819,19 +760,6 @@ rastertops_LDADD = \
 	-lz \
 	libcupsfilters.la
 
-pdftoijs_SOURCES = \
-	filter/pdftoijs.cxx \
-	filter/PDFError.h
-pdftoijs_CFLAGS = \
-	$(CUPS_CFLAGS) \
-	$(IJS_CFLAGS) \
-	$(POPPLER_CFLAGS)
-pdftoijs_CXXFLAGS = $(pdftoijs_CFLAGS)
-pdftoijs_LDADD = \
-	$(CUPS_LIBS) \
-	$(IJS_LIBS) \
-	$(POPPLER_LIBS)
-
 sys5ippprinter_SOURCES = \
 	filter/common.c \
 	filter/common.h \
@@ -858,8 +786,7 @@ pdftops_LDADD = $(STRCASESTR) $(CUPS_LIBS)
 pdftops_DEPENDENCIES = $(STRCASESTR)
 
 pdftoraster_SOURCES = \
-	filter/pdftoraster.cxx \
-	filter/PDFError.h
+	filter/pdftoraster.cxx
 pdftoraster_CFLAGS = \
 	$(CUPS_CFLAGS) \
 	$(LCMS_CFLAGS) \
@@ -1017,13 +944,6 @@ genppdfiles = \
 	ppd/HP-Color_LaserJet_CM3530_MFP-PDF.ppd \
 	ppd/Ricoh-PDF_Printer-PDF.ppd
 ppd_DATA = $(genppdfiles)
-ijsppdfiles = \
-	ppd/HP-PhotoSmart_Pro_B8300-hpijs-pdftoijs.ppd
-if ENABLE_POPPLER
-if ENABLE_IJS
-ppd_DATA += $(ijsppdfiles)
-endif
-endif
 gsppdfiles = \
 	ppd/pxlcolor.ppd \
 	ppd/pxlmono.ppd
@@ -1033,7 +953,6 @@ endif
 
 EXTRA_DIST += \
 	$(genppdfiles) \
-	$(ijsppdfiles) \
 	$(gsppdfiles)
 
 # =========
diff --git a/README b/README
index 2d80e32..ba02771 100644
--- a/README
+++ b/README
@@ -455,7 +455,7 @@ CUPS FILTERS FOR PDF AS STANDARD PRINT JOB FORMAT
 
     Here is documentation from the former CUPS add-on tarball with the filters
     for the PDF-based printing workflow: imagetopdf, texttopdf,
-    pdftopdf, pdftoraster, pdftoopvp, and pdftoijs
+    pdftopdf, and pdftoraster
 
     The original filters are from http://sourceforge.jp/projects/opfc/
 
@@ -718,7 +718,10 @@ output NEWLINE
 Thus, if you want to use both PDF filters and GS by single PPD file,
 what you should do is to add the following line in the PPD file;
 
-*pdftopdfJCLBegin: "pdftoopvp jobInfo:"
+*pdftopdfJCLBegin: "pdfto... jobInfo:"
+
+Replace "pdfto..." by the name of the actual filter to be called after
+pdftopdf.
 
 Note:
   If you specify JCLBegin, you have to specify JCLToPSInterpreter as well.
@@ -1100,247 +1103,6 @@ in the location specified by TMPDIR environment variable. Default location
 is "/tmp".
 
 
-PDFTOIJS
-========
-
-(Optional, only included when building with "./configure ... --enable-ijs ...")
-
-1. INTRODUCTION
-
-"pdftoijs" is a filter for CUPS. It reads PDF files, converts it
-and sends it to an IJS server.
-
-2. LICENSE
-
-Almost source files are under MIT like license. However, "pdftoijs" links
-some "poppler" libraries, and these files are under GNU public license.
-See copyright notice of each file for details.
-
-3. COMMAND LINE
-
-"pdftoijs" is a CUPS filter, and the command line arguments, environment
-variables and configuration files are in accordance with the CUPS filter
-interface.
-
-pdftoijs <job> <user> <title> <num-copies> <options> [<filename>]
-
-"pdftoijs" ignores <job> and <user>.
-<title> is appended into the PDF dictionary as /Title.
-<num-copies> specifies the number of document copies.
-<options> is a CUPS option list.
-<filename> is an input PDF file name.
-
-When omit the <filename>, "pdftoijs" reads a PDF file from the stdin,
-and save it as a temporary file.
-
-4. ENVIRONMENT VARIABLES
-
-This program refers the following environment variable;
-   PPD:  PPD file name of the printer.
-
-5. NEW PPD KEYWORDS
-
-*ijsServer : the ijsserver executable
-*ijsManufacturer, *ijsModel : as used by the ijs server
-*ijsColorspace : the desired output colorspace, one of
-                 'rgb'
-                 'cmyk' (availability depending on poppler compile-options)
-                 'white1', 'black1':  1-bit normal/inverted
-                 'white8', 'black8':  8-bit greyscale normal/inverted
-*ijsResolution [option]=[choice]: the desired output resolution e.g. "600 600"
-*ijsParams [option]=[choice]: custom ijs parameters, separated by ','
-                 (to escape: use \,)
-
-6. COMMAND OPTIONS
-
-(See CUPS documents for details.)
-
-ijsOutputFile : the destination file, stdout otherwise
-
-7. INFORMATION FOR DEVELOPERS
-
-Following information is for developers, not for driver users.
-
-7.1 Temporally files location
-
-"pdftoijs" creates temporary files if needed. Temporary files are created
-in the location specified by TMPDIR environment variable. Default location
-is "/tmp".
-
-
-PDFTOOPVP
-=========
-
-(Optional, only included when building with "./configure ... --enable-opvp ...")
-
-1. INTRODUCTION
-
-"pdftoopvp" is a CUPS filter which reads PDF file, renders pages and
-outputs PDL to a printer driver which is compliant with the OpenPrinting
-Vector Printer Driver Interface "opvp".
-
-2. CONFIGURATION
-
-"pdftoopvp" refers the poppler configuration file. Be aware that poppler
-uses "fontconfig" for its font configuration.
-
-3. JCL
-
-When "pdftoopvp" reads a PDF file from stdin, "pdftoopvp" handles the data
-prior to PDF header (%PDF ...) as JCL options. JCL options for "pdftoopvp"
-must begin with "pdftoopvp jobInfo:". "pdftoopvp" passes the option string
-just after ":" to the driver as the jobInfo option.
-
-4. COMMAND LINE
-
-"pdftoopvp" is a CUPS filter, and the command line arguments,
-environment variables and configuration files are in accordance with
-the CUPS filter interface.
-
-pdftoopvp <job> <user> <title> <num-copies> <options> [<filename>]
-
-"pdftoopvp" ignores <job>, <user>, <title> and <num-copies>.
-<options> is a CUPS option list.
-
-When omit the <filename>, "pdftoopvp" reads a PDF file from stdin,
-and save it as a temporary file.
-
-CUPS options defined in <options> are delimited by space. Boolean
-type CUPS option is defined only by the option key, and other type
-CUPS option are defined by pairs of key and value, <key>=<value>.
-
-5. COMMAND OPTIONS
-
-"pdftoopvp" accepts the following CUPS standard options;
-
-Resolution=<int>
-  Specifies a printer resolution in dpi.
-  When this option is omitted, the resolution is treated as 300dpi.
-  Horizontal and vertical resolution are treated as the same resolution.
-
-PageSize=<string>
-  Specifies a paper size by name defined in the PPD file.
-  This option is ignored when no PPD file is assigned for the printer
-  queue.
-
-"pdftoopvp" accepts the following original options;
-
-opvpDriver=<string>
-  Specifies a driver library name.
-
-opvpModel=<string>
-  Specifies a printer model name.
-
-opvpJobInfo=<string>
-  Specifies "jobInfo" printing options that are passed to the driver.
-  Printing options are overridden by JCL options.
-
-opvpDocInfo=<string>
-  Specifies "docInfo" document options that are passed to the driver.
-
-opvpPageInfo=<string>
-  Specifies "pageInfo" page options that are passed to the driver.
-
-pdftoopvpClipPathNotSaved (Boolean option)
-  Specifies that the driver cannot save clipping path operators in PDF.
-
-nopdftoopvpShearImage (Boolean option)
-  Specifies that the driver cannot rotate/shear images by CTM.
-
-nopdftoopvpMiterLimit (Boolean option)
-  Specifies that the driver does not support miter limit.
-  If the driver does not prepare the opvpSetMiterLimit function entry,
-  this option setting is ignored, and also miter limit is ignored.
-
-pdftoopvpIgnoreMiterLimit (Boolean option)
-  When nopdftoopvpMiterLimit option is set, pdftoopvp automatically
-  replace paths to multiple lines or drawing images. This option
-  specifies to avoid the path replacement even when nopdftoopvpMiterLimit
-  option is set.
-
-pdftoopvpMaxClipPathLength=<int>
-  Specifies the maximum number of clipping path points that the driver
-  supports. Default value is 2000 points.
-
-pdftoopvpMaxFillPathLength=<int>
-  Specifies the maximum number of fill path points that the driver supports.
-  Default value is 4000 points.
-
-nopdftoopvpLineStyle (Boolean option)
-  Specifies that the driver ignores the line style settings in PDF.
-  If the driver does not prepare the SetLineStyle , SetLineDash or
-  SetLineDashOffset function entry, this option setting is ignored, and
-  also line style, line dash and line dash offset are ignored.
-
-nopdftoopvpClipPath (Boolean option)
-  Specifies that the driver does not support clipping path.
-  If the driver does not prepare the opvpSetClipPath function entry, this
-  option is ignored, and also clip path setting is ignored.
-
-nopdftoopvpBitmapChar (Boolean option)
-  Specifies that the driver does not output characters as images.
-  Default setting is that "pdftoopvp" outputs small characters as images.
-
-pdftoopvpBitmapCharThreshold=<int>
-  Specifies the threshold value that "pdftoopvp" outputs characters as
-  images. Threshold value is defined as W x H where character's width
-  is given by W pixels and height is given by H pixels.
-  Default threshold value is 2000 points.
-
-nopdftoopvpImageMask (Boolean option)
-  Specifies that the driver does not support image mask.
-  If this option is set, "pdftoopvp" treats as the nopdftoopvpBitmapChar
-  option is given.
-
-6. PPD OPTIONS
-
-Following options can be defined in a PPD.
-
-Resolution=<int>
-PageSize=<string>
-opvpDriver=<string>
-opvpModel=<string>
-opvpJobInfo=<string>
-opvpDocInfo=<string>
-opvpPageInfo=<string>
-pdftoopvpClipPathNotSaved=True
-pdftoopvpShearImage=False
-pdftoopvpMiterLimit=False
-pdftoopvpIgnoreMiterLimit=True
-pdftoopvpMaxClipPathLength=<int>
-pdftoopvpMaxFillPathLength=<int>
-pdftoopvpLineStyle=False
-pdftoopvpClipPath=False
-pdftoopvpBitmapChar=False
-pdftoopvpBitmapCharThreshold=<int>
-pdftoopvpImageMask=False
-
-7. OPTIONS OVERRIDING RULE
-
-"jobInfo" printing options in a PPD is used as a initial "jobInfo" printing
-options. If opvpJobInfo option is given in the command line, precedent
-"jobInfo" printing options are overridden by the opvpJobInfo options.
-
-After the "jobInfo" printing options are overridden by the opvpJobInfo
-options, if JCL options are given, precedent "jobInfo" printing options are
-overridden by the options given by JCL options.
-
-8. INFORMATION FOR CUPS 1.1
-
-To use this program under CUPS 1.1, following lines must be defined
-in the CUPS's "mime.types" file.
-
-application/vnd.cups-pdf
-
-9. KNOWN PROBLEMS
-
-Problem:
-  When a page is rotated and a character is small, character might not be
-  rotated correctly. This problem is caused by free type library.
-Solution:
-  Define the nopdftoopvpBitmapChar to inhibit characters output as images.
-
-
 URFTOPDF
 ========
 
diff --git a/configure.ac b/configure.ac
index 317792b..89c530d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -459,7 +459,6 @@ AS_IF([test x"$lcms2" = "xno"], [
 ])
 PKG_CHECK_MODULES([FREETYPE], [freetype2], [AC_DEFINE([HAVE_FREETYPE_H], [1], [Have FreeType2 include files])])
 PKG_CHECK_MODULES([FONTCONFIG], [fontconfig >= 2.0.0])
-PKG_CHECK_MODULES([IJS], [ijs], [have_ijs=yes], [have_ijs=no])
 PKG_CHECK_MODULES([ZLIB], [zlib])
 AC_DEFINE([HAVE_LIBZ], [], [Define that we use zlib])
 PKG_CHECK_MODULES([LIBQPDF], [libqpdf >= 8.3.0])
@@ -488,7 +487,7 @@ AC_ARG_ENABLE(poppler, AS_HELP_STRING([--enable-poppler],[enable Poppler-based f
 	      enable_poppler=$enableval,enable_poppler=yes)
 AM_CONDITIONAL(ENABLE_POPPLER, test x$enable_poppler = xyes)
 if test x$enable_poppler = xyes; then
-	PKG_CHECK_MODULES([POPPLER], [poppler >= 0.19])
+	PKG_CHECK_MODULES([POPPLER], [poppler-cpp >= 0.19])
 	AC_CHECK_HEADER([poppler/cpp/poppler-version.h], [AC_DEFINE([HAVE_CPP_POPPLER_VERSION_H],,[Define if you have Poppler's "cpp/poppler-version.h" header file.])], [])
 fi
 
@@ -542,21 +541,6 @@ AC_ARG_ENABLE([ghostscript],
 	[enable_ghostscript="$enableval"],
 	[enable_ghostscript=yes]
 )
-AC_ARG_ENABLE([ijs],
-	[AS_HELP_STRING([--enable-ijs], [Enable filters using IJS.])],
-	[enable_ijs="$enableval"],
-	[enable_ijs=no]
-)
-AS_IF([test "x$enable_ijs" = "xyes" -a "x$have_ijs" != "xyes"], [
-       AC_MSG_ERROR([IJS not found, but requested.])
-])
-AM_CONDITIONAL(ENABLE_IJS, test "x$enable_ijs" = "xyes")
-AC_ARG_ENABLE([opvp],
-	[AS_HELP_STRING([--enable-opvp], [Enable filters using OpenPrinting Vector (OPVP).])],
-	[enable_opvp="$enableval"],
-	[enable_opvp=no]
-)
-AM_CONDITIONAL(ENABLE_OPVP, test "x$enable_opvp" = "xyes")
 AC_ARG_WITH([pdftops],
 	[AS_HELP_STRING([--with-pdftops=value], [Set which pdftops to use (gs,pdftops,pdftocairo,acroread,mupdf,hybrid).])],
 	[with_pdftops="$withval"],
@@ -903,7 +887,5 @@ Build configuration:
 	apple-raster:    ${APPLE_RASTER_FILTER}
 	pclm:            ${enable_pclm}
 	driverless auto-setup: ${enable_auto_setup_driverless}
-	ijs:             ${enable_ijs}
-	opvp:            ${enable_opvp}
 ==============================================================================
 ])
diff --git a/filter/PDFError.h b/filter/PDFError.h
deleted file mode 100644
index 6167b5a..0000000
--- a/filter/PDFError.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
-
-Copyright (c) 2012, BBR Inc.  All rights reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-*/
-/*
- P2PError.h
-*/
-#ifndef _P2PERROR_H_
-#define _P2PERROR_H_
-
-#include <config.h>
-#include <stdarg.h>
-#include <Error.h>
-#ifdef HAVE_CPP_POPPLER_VERSION_H
-#include "cpp/poppler-version.h"
-#endif
-
-#define pdfError(pos,...) error(errInternal,pos,__VA_ARGS__)
-
-#endif
diff --git a/filter/imagetopdf.c b/filter/imagetopdf.c
index 0bf2618..4b8c6ad 100644
--- a/filter/imagetopdf.c
+++ b/filter/imagetopdf.c
@@ -149,13 +149,13 @@ void emitJCLOptions(FILE *fp, int copies)
   int i;
   char buf[1024];
   ppd_attr_t *attr;
-  int pdftoopvp = 0;
+  int pdftopdfjcl = 0;
   int datawritten = 0;
 
   if (ppd == 0) return;
   if ((attr = ppdFindAttr(ppd,"pdftopdfJCLBegin",NULL)) != NULL) {
     int n = strlen(attr->value);
-    pdftoopvp = 1;
+    pdftopdfjcl = 1;
     for (i = 0;i < n;i++) {
 	if (attr->value[i] == '\r' || attr->value[i] == '\n') {
 	    /* skip new line */
@@ -173,7 +173,7 @@ void emitJCLOptions(FILE *fp, int copies)
     if ((attr = ppdFindAttr(ppd,"pdftopdfJCLCopies",buf)) != NULL) {
       fputs(attr->value,fp);
       datawritten = 1;
-    } else if (pdftoopvp) {
+    } else if (pdftopdfjcl) {
       fprintf(fp,"Copies=%d;",copies);
       datawritten = 1;
     }
@@ -189,7 +189,7 @@ void emitJCLOptions(FILE *fp, int copies)
       if ((attr = ppdFindAttr(ppd,buf,choices[i]->choice)) != NULL) {
         fputs(attr->value,fp);
 	datawritten = 1;
-      } else if (pdftoopvp) {
+      } else if (pdftopdfjcl) {
         fprintf(fp,"%s=%s;",
           ((ppd_option_t *)(choices[i]->option))->keyword,
           choices[i]->choice);
diff --git a/filter/pdftoijs.cxx b/filter/pdftoijs.cxx
deleted file mode 100644
index 4a93ef7..0000000
--- a/filter/pdftoijs.cxx
+++ /dev/null
@@ -1,522 +0,0 @@
-/*
-Copyright (c) 2008, BBR Inc.  All rights reserved.
-          (c) 2008 Tobias Hoffmann
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-*/
-/*
- pdftoijs.cc
- pdf to ijs filter
-*/
-
-#include <config.h>
-#include <stdio.h>
-#include <stdlib.h>
-#ifdef HAVE_CPP_POPPLER_VERSION_H
-#include "cpp/poppler-version.h"
-#endif
-#include <goo/GooString.h>
-#include <goo/gmem.h>
-#include <Object.h>
-#include <Stream.h>
-#include <PDFDoc.h>
-#include <SplashOutputDev.h>
-#include <cups/cups.h>
-#include <cups/ppd.h>
-#include <stdarg.h>
-#include "PDFError.h"
-#include <GlobalParams.h>
-#include <splash/SplashTypes.h>
-#include <splash/SplashBitmap.h>
-extern "C" {
-#include <ijs/ijs.h>
-#include <ijs/ijs_client.h>
-}
-#include <vector>
-#include <string>
-
-#define MAX_CHECK_COMMENT_LINES	20
-
-namespace {
-  int exitCode = 0;
-  char *outputfile = NULL;
-//  int deviceCopies = 1;
-//  bool deviceCollate = false;
-  const char *ijsserver = NULL;
-  int resolution[2] = {0,0};
-  enum ColEnum { NONE=-1, COL_RGB, COL_CMYK, COL_BLACK1, COL_WHITE1, COL_BLACK8, COL_WHITE8 } colspace=NONE;
-  const char *devManu=NULL, *devModel=NULL;
-  std::vector<std::pair<std::string,std::string> > params;
-
-  ppd_file_t *ppd = 0; // holds the memory for the strings
-}
-
-#if POPPLER_VERSION_MAJOR > 0 || POPPLER_VERSION_MINOR >= 23
-void CDECL myErrorFun(void *data, ErrorCategory category,
-#if POPPLER_VERSION_MAJOR > 0 || POPPLER_VERSION_MINOR >= 70
-    Goffset pos, const char *msg)
-#else
-    Goffset pos, char *msg)
-#endif /* MAJOR > 0 || MINOR >= 70 */
-#else
-void CDECL myErrorFun(void *data, ErrorCategory category,
-    int pos, char *msg)
-#endif
-{
-  if (pos >= 0) {
-#if POPPLER_VERSION_MAJOR > 0 || POPPLER_VERSION_MINOR >= 23
-    fprintf(stderr, "ERROR (%lld): ", pos);
-#else
-    fprintf(stderr, "ERROR (%d): ", pos);
-#endif
-  } else {
-    fprintf(stderr, "ERROR: ");
-  }
-  fprintf(stderr, "%s\n",msg);
-  fflush(stderr);
-}
-
-/* parse  "300 400" */
-void parse_resolution(const char *str)
-{
-  const char *tmp=strchr(str,' ');
-  if (tmp) {
-    resolution[0]=atoi(str);
-    resolution[1]=atoi(tmp+1);
-  } else {
-    resolution[0]=resolution[1]=atoi(str);
-  }
-}
-
-/* parse  "cmyk" "grey" "rgb" */
-void parse_colorspace(const char *str)
-{
-  if (strcasecmp(str,"rgb")==0) {
-    colspace=COL_RGB;
-  } else if (strcasecmp(str,"black1")==0) {
-    colspace=COL_BLACK1;
-  } else if (strcasecmp(str,"white1")==0) {
-    colspace=COL_WHITE1;
-  } else if (strcasecmp(str,"black8")==0) {
-    colspace=COL_BLACK8;
-  } else if (strcasecmp(str,"white8")==0) {
-    colspace=COL_WHITE8;
-#ifdef SPLASH_CMYK
-  } else if (strcasecmp(str,"cmyk")==0) {
-    colspace=COL_CMYK;
-  } else {
-    pdfError(-1,"Unknown colorspace; supported are 'rgb', 'cmyk', 'white1', 'black1', 'white8', 'black8'");
-#else
-  } else {
-    pdfError(-1,"Unknown colorspace; supported are 'rgb', 'white1', 'black1', 'white8', 'black8'");
-#endif
-    exit(1);
-  }
-}
-
-std::string str_trim(const char *str,int len) 
-{
-  int start=strspn(str," \r\n\t");
-  for (len--;len>=0;len--) {
-    if (!strchr(" \r\n\t",str[len])) {
-      break;
-    }
-  }
-  len++;
-  if (start>=len) {
-    return std::string();
-  }
-  return std::string(str+start,len-start);
-}
-
-/* parse  key=value */
-void parse_param(const char *str)
-{
-  const char *eq=strchr(str,'=');
-  if (!eq) {
-    fprintf(stderr, "WARNING: ignored ijsParam without '='");
-    return;
-  }
-  params.push_back(make_pair(str_trim(str,eq-str),str_trim(eq+1,strlen(eq+1))));
-}
-
-/* parse  key1=value1,key2=value2,... */
-void parse_paramlist(const char *str) 
-{
-  std::string tmp;
-  const char *cur=str;
-  while (*cur) {
-    tmp.clear();
-    for (;*cur;++cur) {
-      if ( (*cur=='\\')&&(cur[1]) ) {
-        ++cur;
-        tmp.push_back(*cur);
-      } else if(*cur==',') {
-        ++cur;
-        break;
-      } else {
-        tmp.push_back(*cur);
-      }
-    }
-    parse_param(tmp.c_str());
-  }
-}
-
-void parseOpts(int argc, char **argv)
-{
-  int num_options = 0;
-  cups_option_t *options = 0;
-
-  if (argc < 6 || argc > 7) {
-    pdfError(-1,"%s job-id user title copies options [file]",
-      argv[0]);
-    exit(1);
-  }
-
-  assert(!ppd);
-  ppd = ppdOpenFile(getenv("PPD"));
-  ppdMarkDefaults(ppd);
-
-  // handle  *ijsServer, *ijsManufacturer, *ijsModel, *ijsColorspace
-  ppd_attr_t *attr; 
-  if ((attr = ppdFindAttr(ppd,"ijsServer",0)) != 0) {
-    ijsserver=attr->value;
-  }
-  if ((attr = ppdFindAttr(ppd,"ijsManufacturer",0)) != 0) {
-    devManu=attr->value;
-  }
-  if ((attr = ppdFindAttr(ppd,"ijsModel",0)) != 0) {
-    devModel=attr->value;
-  }
-  if ((attr = ppdFindAttr(ppd,"ijsColorspace",0)) != 0) {
-    parse_colorspace(attr->value);
-  }
-  if ( (!ijsserver)||(!devManu)||(!devModel)||(colspace==NONE) ) {
-    pdfError(-1,"ijsServer, ijsManufacturer, ijsModel and ijsColorspace must be specified in the PPD");
-    exit(1);
-  }
-  
-  options = NULL;
-
-  num_options = cupsParseOptions(argv[5],0,&options);
-//  cupsMarkOptions(ppd,num_options,options); // TODO? returns 1 on conflict
-  // handle *ijsResolution, *ijsParam here
-  char spec[PPD_MAX_NAME];
-  for (int iA=0;iA<num_options;iA++) {
-    snprintf(spec,PPD_MAX_NAME,"%s=%s",options[iA].name,options[iA].value);
-    if ((attr = ppdFindAttr(ppd,"ijsResolution",spec)) != 0) {
-      parse_resolution(attr->value);
-    }
-    if ((attr = ppdFindAttr(ppd,"ijsParams",spec)) != 0) {
-      parse_paramlist(attr->value);
-    }
-    if (strcmp(options[iA].name,"ijsOutputFile")==0) {
-      outputfile=strdup(options[iA].value);
-    }
-  }
-  if (!resolution[0]) {
-    pdfError(-1,"ijsResolution must be specified");
-    exit(1);
-  }
-  cupsFreeOptions(num_options,options);
-}
-
-#if 0
-void parsePDFTOPDFComment(FILE *fp)
-{
-  char buf[4096];
-  int i;
-
-  /* skip until PDF start header */
-  while (fgets(buf,sizeof(buf),fp) != 0) {
-    if (strncmp(buf,"%PDF",4) == 0) {
-      break;
-    }
-  }
-  for (i = 0;i < MAX_CHECK_COMMENT_LINES;i++) {
-    if (fgets(buf,sizeof(buf),fp) == 0) break;
-    if (strncmp(buf,"%%PDFTOPDFNumCopies",19) == 0) {
-      char *p;
-
-      p = strchr(buf+19,':');
-      deviceCopies = atoi(p+1);
-    } else if (strncmp(buf,"%%PDFTOPDFCollate",17) == 0) {
-      char *p;
-
-      p = strchr(buf+17,':');
-      while (*p == ' ' || *p == '\t') p++;
-      if (strncasecmp(p,"true",4) == 0) {
-	deviceCollate = true;
-      } else {
-	deviceCollate = false;
-      }
-    }
-  }
-}
-#endif
-
-int main(int argc, char *argv[]) {
-  PDFDoc *doc;
-  SplashOutputDev *out;
-  SplashColor paperColor;
-  int i;
-  int npages;
-  IjsClientCtx *ctx=NULL;
-  int job_id;
-  enum SplashColorMode cmode;
-  int rowpad;
-  bool reverseVideo;
-
-  setErrorCallback(::myErrorFun,NULL);
-  globalParams = new GlobalParams();
-  parseOpts(argc, argv);
-
-  if (argc == 6) {
-    /* stdin */
-    int fd;
-    char name[BUFSIZ];
-    char buf[BUFSIZ];
-    int n;
-
-    fd = cupsTempFd(name,sizeof(name));
-    if (fd < 0) {
-      pdfError(-1,"Can't create temporary file");
-      exit(1);
-    }
-
-    /* copy stdin to the tmp file */
-    while ((n = read(0,buf,BUFSIZ)) > 0) {
-      if (write(fd,buf,n) != n) {
-        pdfError(-1,"Can't copy stdin to temporary file");
-        close(fd);
-	exit(1);
-      }
-    }
-    close(fd);
-    doc = new PDFDoc(new GooString(name));
-    /* remove name */
-    unlink(name);
-  } else {
-    GooString *fileName = new GooString(argv[6]);
-    /* argc == 7 filenmae is specified */
-    FILE *fp;
-
-    if ((fp = fopen(argv[6],"rb")) == 0) {
-        pdfError(-1,"Can't open input file %s",argv[6]);
-	exit(1);
-    }
-//    parsePDFTOPDFComment(fp); // TODO?
-    fclose(fp);
-    doc = new PDFDoc(fileName,NULL,NULL);
-  }
-
-  if (!doc->isOk()) {
-    exitCode = 1;
-    goto err1;
-  }
-
-  char tmp[100];
-  tmp[99]=0;
-  // ... OutputFD=stdout .. needs to be done before forking
-  int outfd;
-  outfd=dup(fileno(stdout)); 
-
-#if 0
-  /* fix NumCopies, Collate ccording to PDFTOPDFComments */
-  header.NumCopies = deviceCopies;
-  header.Collate = deviceCollate ? CUPS_TRUE : CUPS_FALSE;
-  /* fixed other values that pdftopdf handles */
-  header.MirrorPrint = CUPS_FALSE;
-  header.Orientation = CUPS_ORIENT_0;
-#endif
-
-  job_id=atoi(argv[1]);
-  ctx = ijs_invoke_server (ijsserver);
-  ijs_client_open (ctx);
-  ijs_client_begin_job (ctx,job_id);
-  if (outputfile) {
-    ijs_client_set_param(ctx,job_id,"OutputFile",outputfile,strlen(outputfile));
-  } else {
-    snprintf(tmp,99,"%d",outfd);
-    ijs_client_set_param(ctx,job_id,"OutputFD",tmp,strlen(tmp));
-    close(outfd);
-  }
-  ijs_client_set_param(ctx,job_id,"DeviceManufacturer",devManu,strlen(devManu));
-  ijs_client_set_param(ctx,job_id,"DeviceModel",devModel,strlen(devModel));
-  // TODO: get supported output-formats from ijs-server, overriding PPD
-
-  /* set image's values */
-  int numChan,bitsPerSample;
-  const char *devName;
-  reverseVideo = false;
-  switch (colspace) {
-  case COL_RGB:
-    numChan=3;
-    bitsPerSample=8;
-    cmode = splashModeRGB8;
-    devName = "DeviceRGB";
-    rowpad = 3;
-    /* set paper color white */
-    paperColor[0] = 255;
-    paperColor[1] = 255;
-    paperColor[2] = 255;
-    break;
-  case COL_BLACK1:
-    reverseVideo = true;
-  case COL_WHITE1:
-    numChan=1;
-    bitsPerSample=1;
-    cmode = splashModeMono1;
-    devName = "DeviceGray";
-    /* set paper color white */
-    paperColor[0] = 255;
-    rowpad = 1;
-    break;
-  case COL_BLACK8:
-    reverseVideo = true;
-  case COL_WHITE8:
-    numChan=1;
-    bitsPerSample=8;
-    cmode = splashModeMono8;
-    devName = "DeviceGray";
-    /* set paper color white */
-    paperColor[0] = 255;
-    rowpad = 1;
-    break;
-#ifdef SPLASH_CMYK
-  case COL_CMYK:
-    numChan=4;
-    bitsPerSample=8;
-    cmode = splashModeCMYK8;
-    devName = "DeviceCMYK";
-    /* set paper color white */
-    paperColor[0] = 0;
-    paperColor[1] = 0;
-    paperColor[2] = 0;
-    paperColor[3] = 0;
-    rowpad = 4;
-    break;
-#endif
-  default:
-    pdfError(-1,"Specified ColorSpace is not supported");
-    exit(1);
-    break;
-  }
-
-  out = new SplashOutputDev(cmode,rowpad/* row padding */,
-    reverseVideo,paperColor,true
-#if POPPLER_VERSION_MAJOR == 0 && POPPLER_VERSION_MINOR <= 30
-    ,false
-#endif
-    );
-  out->startDoc(doc);
-
-  snprintf(tmp,99,"%d",numChan);
-  ijs_client_set_param(ctx,job_id,"NumChan",tmp,strlen(tmp));
-  snprintf(tmp,99,"%d",bitsPerSample);
-  ijs_client_set_param(ctx,job_id,"BitsPerSample",tmp,strlen(tmp));
-  ijs_client_set_param(ctx,job_id,"ColorSpace",devName,strlen(devName));
-  snprintf(tmp,99,"%dx%d",resolution[0],resolution[1]);
-  ijs_client_set_param(ctx,job_id,"Dpi",tmp,strlen(tmp));
-
-  { // set the custom ijs parameters
-    const int plen=params.size();
-    for (i=0;i<plen;i++) {
-      ijs_client_set_param(ctx,job_id,params[i].first.c_str(),params[i].second.c_str(),params[i].second.size());
-    }
-  }
-
-  npages = doc->getNumPages();
-  for (i = 1;i <= npages;i++) {
-    SplashBitmap *bitmap;
-    unsigned int size;
-
-    doc->displayPage(out,i,resolution[0],resolution[1],0,false,false,false);
-    bitmap = out->getBitmap();
-
-    /* set page parameters */
-    snprintf(tmp,99,"%d",bitmap->getWidth());
-    ijs_client_set_param(ctx,job_id,"Width",tmp,strlen(tmp));
-    snprintf(tmp,99,"%d",bitmap->getHeight());
-    ijs_client_set_param(ctx,job_id,"Height",tmp,strlen(tmp));
-    ijs_client_begin_page(ctx,job_id);
-
-    /* write page image */
-    size = bitmap->getRowSize()*bitmap->getHeight();
-    int status=ijs_client_send_data_wait(ctx,job_id,(const char *)bitmap->getDataPtr(),size);
-    if (status) {
-        pdfError(-1,"Can't write page %d image: %d",i,status);
-	exit(1);
-    }
-
-    status=ijs_client_end_page(ctx,job_id);
-    if (status) {
-        pdfError(-1,"Can't finish page %d: %d",i,status);
-	exit(1);
-    }
-  }
-  ijs_client_end_job (ctx, job_id);
-  ijs_client_close (ctx);
-
-  ijs_client_begin_cmd (ctx, IJS_CMD_EXIT);
-  ijs_client_send_cmd_wait (ctx);
-
-  delete out;
-err1:
-  delete doc;
-  ppdClose(ppd);
-  free(outputfile);
-
-#if POPPLER_VERSION_MAJOR == 0 && POPPLER_VERSION_MINOR < 69
-  // Check for memory leaks
-  Object::memCheck(stderr);
-  gMemReport(stderr);
-#endif
-
-  return exitCode;
-}
-
-/* replace memory allocation methods for memory check */
-/* For compatibility with g++ >= 4.7 compilers _GLIBCXX_THROW
- *  should be used as a guard, otherwise use traditional definition */
-#ifndef _GLIBCXX_THROW
-#define _GLIBCXX_THROW throw
-#endif
-
-void * operator new(size_t size) _GLIBCXX_THROW (std::bad_alloc)
-{
-  return gmalloc(size);
-}
-
-void operator delete(void *p) throw ()
-{
-  gfree(p);
-}
-
-void * operator new[](size_t size) _GLIBCXX_THROW (std::bad_alloc)
-{
-  return gmalloc(size);
-}
-
-void operator delete[](void *p) throw ()
-{
-  gfree(p);
-}
diff --git a/filter/pdftoopvp/99pdftoopvp.conf b/filter/pdftoopvp/99pdftoopvp.conf
deleted file mode 100644
index 2737e17..0000000
--- a/filter/pdftoopvp/99pdftoopvp.conf
+++ /dev/null
@@ -1,18 +0,0 @@
-<?xml version="1.0"?>
-<!DOCTYPE fontconfig SYSTEM "fonts.dtd">
-<!-- conf.d/pdftoopvp.fconf -->
-<fontconfig>
-<!--  Symbol and ZapfDingbats -->
-	<alias>
-		<family>ZapfDingbats</family>
-		<prefer>
-			<family>Dingbats</family>
-		</prefer>
-	</alias>
-	<alias>
-		<family>Symbol</family>
-		<prefer>
-			<family>Standard Symbols L</family>
-		</prefer>
-	</alias>
-</fontconfig>
diff --git a/filter/pdftoopvp/OPVPError.h b/filter/pdftoopvp/OPVPError.h
deleted file mode 100644
index 4550949..0000000
--- a/filter/pdftoopvp/OPVPError.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
-
-Copyright (c) 2012, BBR Inc.  All rights reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-*/
-/*
- OPVPError.h
-*/
-#ifndef _OPVPERROR_H_
-#define _OPVPERROR_H_
-
-#include <config.h>
-#include <stdarg.h>
-#include <Error.h>
-#ifdef HAVE_CPP_POPPLER_VERSION_H
-#include "cpp/poppler-version.h"
-#endif
-
-#define opvpError(pos,...) error(errInternal,pos,__VA_ARGS__)
-
-#endif
diff --git a/filter/pdftoopvp/OPVPOutputDev.cxx b/filter/pdftoopvp/OPVPOutputDev.cxx
deleted file mode 100644
index 2526714..0000000
--- a/filter/pdftoopvp/OPVPOutputDev.cxx
+++ /dev/null
@@ -1,1948 +0,0 @@
-//
-// OPVPOutputDev.cc
-// 	Based SplashOutputDev.cc : Copyright 2003 Glyph & Cog, LLC
-//
-// Copyright 2005 AXE,Inc.
-//
-// 2007,2008 Modified by BBR Inc.
-//========================================================================
-
-#include <config.h>
-#ifdef HAVE_CPP_POPPLER_VERSION_H
-#include "cpp/poppler-version.h"
-#endif
-
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
-#include <string.h>
-#include <math.h>
-#include "goo/gfile.h"
-#include "GlobalParams.h"
-#include "OPVPError.h"
-#include "Object.h"
-#include "GfxState.h"
-#include "GfxFont.h"
-#include "Link.h"
-#include "CharCodeToUnicode.h"
-#include "FontEncodingTables.h"
-#include "fofi/FoFiTrueType.h"
-#include "splash/SplashMath.h"
-#include "CMap.h"
-#include "splash/SplashBitmap.h"
-#include "splash/SplashGlyphBitmap.h"
-#include "splash/SplashPattern.h"
-#include "splash/SplashScreen.h"
-#include "splash/SplashErrorCodes.h"
-#include "splash/SplashFontEngine.h"
-#include "splash/SplashFont.h"
-#include "splash/SplashFontFile.h"
-#include "splash/SplashFontFileID.h"
-#include "OPVPSplashPath.h"
-#include "OPVPSplashState.h"
-#include "OPRS.h"
-#include "OPVPOutputDev.h"
-
-#define SLICE_FOR_PATTERN 1000
-
-//------------------------------------------------------------------------
-// Font substitutions
-//------------------------------------------------------------------------
-
-struct SplashOutFontSubst {
-  char *name;
-  double mWidth;
-};
-
-//------------------------------------------------------------------------
-
-#define soutRound(x) ((int)(x + 0.5))
-
-//------------------------------------------------------------------------
-// SplashOutFontFileID
-//------------------------------------------------------------------------
-
-class SplashOutFontFileID: public SplashFontFileID {
-public:
-
-  SplashOutFontFileID(const Ref *rA) { r = *rA; substIdx = -1; }
-
-  ~SplashOutFontFileID() {}
-
-  bool matches(SplashFontFileID *id) {
-    return ((SplashOutFontFileID *)id)->r.num == r.num &&
-           ((SplashOutFontFileID *)id)->r.gen == r.gen;
-  }
-
-  void setSubstIdx(int substIdxA) { substIdx = substIdxA; }
-  int getSubstIdx() { return substIdx; }
-
-private:
-
-  Ref r;
-  int substIdx;
-};
-
-//------------------------------------------------------------------------
-// T3FontCache
-//------------------------------------------------------------------------
-
-struct T3FontCacheTag {
-  Gushort code;
-  Gushort mru;			// valid bit (0x8000) and MRU index
-};
-
-class T3FontCache {
-public:
-
-  T3FontCache(Ref *fontID, double m11A, double m12A,
-	      double m21A, double m22A,
-	      int glyphXA, int glyphYA, int glyphWA, int glyphHA,
-	      bool aa);
-  ~T3FontCache();
-  bool matches(Ref *idA, double m11A, double m12A,
-		double m21A, double m22A)
-    { return fontID.num == idA->num && fontID.gen == idA->gen &&
-	     m11 == m11A && m12 == m12A && m21 == m21A && m22 == m22A; }
-
-  Ref fontID;			// PDF font ID
-  double m11, m12, m21, m22;	// transform matrix
-  int glyphX, glyphY;		// pixel offset of glyph bitmaps
-  int glyphW, glyphH;		// size of glyph bitmaps, in pixels
-  int glyphSize;		// size of glyph bitmaps, in bytes
-  int cacheSets;		// number of sets in cache
-  int cacheAssoc;		// cache associativity (glyphs per set)
-  Guchar *cacheData;		// glyph pixmap cache
-  T3FontCacheTag *cacheTags;	// cache tags, i.e., char codes
-};
-
-T3FontCache::T3FontCache(Ref *fontIDA, double m11A, double m12A,
-			 double m21A, double m22A,
-			 int glyphXA, int glyphYA, int glyphWA, int glyphHA,
-			 bool aa) {
-  int i;
-
-  fontID = *fontIDA;
-  m11 = m11A;
-  m12 = m12A;
-  m21 = m21A;
-  m22 = m22A;
-  glyphX = glyphXA;
-  glyphY = glyphYA;
-  glyphW = glyphWA;
-  glyphH = glyphHA;
-  if (aa) {
-    glyphSize = glyphW * glyphH;
-  } else {
-    glyphSize = ((glyphW + 7) >> 3) * glyphH;
-  }
-  cacheAssoc = 8;
-  if (glyphSize <= 256) {
-    cacheSets = 8;
-  } else if (glyphSize <= 512) {
-    cacheSets = 4;
-  } else if (glyphSize <= 1024) {
-    cacheSets = 2;
-  } else {
-    cacheSets = 1;
-  }
-  cacheData = (Guchar *)gmallocn3(cacheSets , cacheAssoc , glyphSize);
-  cacheTags = (T3FontCacheTag *)gmallocn3(cacheSets , cacheAssoc ,
-					sizeof(T3FontCacheTag));
-  for (i = 0; i < cacheSets * cacheAssoc; ++i) {
-    cacheTags[i].mru = i & (cacheAssoc - 1);
-  }
-}
-
-T3FontCache::~T3FontCache() {
-  gfree(cacheData);
-  gfree(cacheTags);
-}
-
-struct T3GlyphStack {
-  Gushort code;			// character code
-  double x, y;			// position to draw the glyph
-
-  //----- cache info
-  T3FontCache *cache;		// font cache for the current font
-  T3FontCacheTag *cacheTag;	// pointer to cache tag for the glyph
-  Guchar *cacheData;		// pointer to cache data for the glyph
-
-  //----- saved state
-  SplashBitmap *origBitmap;
-  OPRS *origOPRS;
-  double origCTM4, origCTM5;
-
-  T3GlyphStack *next;		// next object on stack
-};
-
-//------------------------------------------------------------------------
-// OPVPOutputDev
-//------------------------------------------------------------------------
-
-OPVPOutputDev::OPVPOutputDev()
-{
-  xref = 0;
-  bitmap = 0;
-  fontEngine = 0;
-  nT3Fonts = 0;
-  t3GlyphStack = 0;
-  font = NULL;
-  needFontUpdate = false;
-  textClipPath = 0;
-  underlayCbk = 0;
-  underlayCbkData = 0;
-  scaleWidth = scaleHeight = -1;
-  leftMargin = 0;
-  bottomMargin = 0;
-  rotate = 0;
-  sliceHeight = 0;
-  yoffset = 0;
-  oprs = 0;
-}
-
-void OPVPOutputDev::setScale(double w, double h,
-  double leftMarginA, double bottomMarginA, int rotateA,
-  int yoffsetA, int sliceHeightA)
-{
-  scaleWidth = w;
-  scaleHeight = h;
-  leftMargin = leftMarginA;
-  bottomMargin = bottomMarginA;
-  rotate = rotateA;
-  yoffset = yoffsetA;
-  sliceHeight = sliceHeightA;
-}
-
-int OPVPOutputDev::init(SplashColorMode colorModeA,
-				 bool colorProfile,
-				 bool reverseVideoA,
-				 SplashColor paperColorA,
-                                 const char *driverName,
-				 int outputFD,
-				 const char *printerModel,
-				 int nOptions,
-				 const char *optionKeys[],
-				 const char *optionVals[]) {
-  int result;
-
-  oprs = new OPRS();
-
-  if ((result = oprs->init(driverName, outputFD, printerModel,
-       nOptions,optionKeys,optionVals)) < 0) {
-    opvpError(-1,"OPRS initialization fail");
-    return result;
-  }
-  colorMode = colorModeA;
-  if ((result = oprs->setColorMode(colorMode,colorProfile)) < 0) {
-    opvpError(-1,"Can't setColorMode");
-    return result;
-  }
-  reverseVideo = reverseVideoA;
-  splashColorCopy(paperColor,paperColorA);
-
-  return 0;
-}
-
-OPVPOutputDev::~OPVPOutputDev() {
-  int i;
-
-  for (i = 0; i < nT3Fonts; ++i) {
-    delete t3FontCache[i];
-  }
-  if (fontEngine) {
-    delete fontEngine;
-  }
-  if (oprs) {
-    delete oprs;
-  }
-  if (bitmap) {
-    delete bitmap;
-  }
-}
-
-void OPVPOutputDev::startDoc(XRef *xrefA) {
-  int i;
-
-  xref = xrefA;
-  if (fontEngine) {
-    delete fontEngine;
-  }
-  fontEngine = new SplashFontEngine(
-#if HAVE_T1LIB_H
-				    globalParams->getEnableT1lib(),
-#endif
-#if HAVE_FREETYPE_FREETYPE_H || HAVE_FREETYPE_H
-				    globalParams->getEnableFreeType(),
-				    false,
-                                    false,
-#endif
-#if POPPLER_VERSION_MAJOR == 0 && POPPLER_VERSION_MINOR <= 30
-				    globalParams->getAntialias());
-#else
-                                    false);
-#endif
-  for (i = 0; i < nT3Fonts; ++i) {
-    delete t3FontCache[i];
-  }
-  nT3Fonts = 0;
-}
-
-void OPVPOutputDev::startPage(int pageNum, GfxState *state) {
-  int w, h;
-
-  if (state) {
-    if (scaleWidth > 0 && scaleHeight > 0) {
-      const double *ctm = state->getCTM();
-
-      switch (rotate) {
-      case 90:
-	state->setCTM(0,ctm[1],ctm[2],0,leftMargin,bottomMargin-yoffset);
-	break;
-      case 180:
-	state->setCTM(ctm[0],0,0,ctm[3],paperWidth-leftMargin,
-	  bottomMargin-yoffset);
-	break;
-      case 270:
-	state->setCTM(0,ctm[1],ctm[2],0,paperWidth-leftMargin,
-	  -bottomMargin+paperHeight-yoffset);
-	break;
-      default:
-	state->setCTM(ctm[0],0,0,ctm[3],leftMargin,
-	  -bottomMargin+paperHeight-yoffset);
-	break;
-      }
-      state->concatCTM(scaleWidth,0.0,0.0,scaleHeight,0,0);
-    }
-    w = (int)(state->getPageWidth()+0.5);
-    h = (int)(state->getPageHeight()+0.5);
-  } else {
-    w = h = 1;
-  }
-  oprs->initGS(colorMode,w,h,paperColor);
-
-  if (underlayCbk) {
-    (*underlayCbk)(underlayCbkData);
-  }
-}
-
-void OPVPOutputDev::endPage() {
-  oprs->endPage();
-}
-
-void OPVPOutputDev::saveState(GfxState *state) {
-  oprs->saveState();
-}
-
-void OPVPOutputDev::restoreState(GfxState *state) {
-  oprs->restoreState();
-  needFontUpdate = true;
-}
-
-void OPVPOutputDev::updateAll(GfxState *state) {
-  updateLineDash(state);
-  updateLineJoin(state);
-  updateLineCap(state);
-  updateLineWidth(state);
-  updateFlatness(state);
-  updateMiterLimit(state);
-  updateFillColor(state);
-  updateStrokeColor(state);
-  needFontUpdate = true;
-}
-
-void OPVPOutputDev::updateCTM(GfxState *state, double m11, double m12,
-				double m21, double m22,
-				double m31, double m32) {
-  updateLineDash(state);
-  updateLineJoin(state);
-  updateLineCap(state);
-  updateLineWidth(state);
-}
-
-void OPVPOutputDev::transLineDash(GfxState *state, SplashCoord **adash,
-  int *adashLength, SplashCoord *aphase) {
-  double *dashPattern;
-  double dashStart;
-  static SplashCoord dash[20];
-  int i;
-
-  state->getLineDash(&dashPattern, adashLength, &dashStart);
-  if (*adashLength > 20) {
-    *adashLength = 20;
-  }
-  for (i = 0; i < *adashLength; ++i) {
-    dash[i] =  (SplashCoord)state->transformWidth(dashPattern[i]);
-    if (dash[i] < 1) {
-      dash[i] = 1;
-    }
-  }
-  *adash = dash;
-  *aphase = (SplashCoord)state->transformWidth(dashStart);
-}
-
-void OPVPOutputDev::updateSplashLineDash(GfxState *state, Splash *splash) {
-  int dashLength;
-  SplashCoord *dash;
-  SplashCoord phase;
-
-  transLineDash(state, &dash, &dashLength, &phase);
-  splash->setLineDash(dash, dashLength, phase);
-}
-
-void OPVPOutputDev::updateLineDash(GfxState *state) {
-  int dashLength;
-  SplashCoord *dash;
-  SplashCoord phase;
-
-  transLineDash(state, &dash, &dashLength, &phase);
-  oprs->setLineDash(dash, dashLength, phase);
-}
-
-void OPVPOutputDev::updateFlatness(GfxState *state) {
-  oprs->setFlatness(state->getFlatness());
-}
-
-void OPVPOutputDev::updateLineJoin(GfxState *state) {
-  oprs->setLineJoin(state->getLineJoin());
-}
-
-void OPVPOutputDev::updateLineCap(GfxState *state) {
-  oprs->setLineCap(state->getLineCap());
-}
-
-void OPVPOutputDev::updateMiterLimit(GfxState *state) {
-  oprs->setMiterLimit(state->getMiterLimit());
-}
-
-void OPVPOutputDev::updateLineWidth(GfxState *state) {
-  oprs->setLineWidth(state->getTransformedLineWidth());
-}
-
-void OPVPOutputDev::updateFillColor(GfxState *state) {
-  GfxGray gray;
-  GfxRGB rgb;
-
-  state->getFillGray(&gray);
-  state->getFillRGB(&rgb);
-  oprs->setFillPattern(getColor(gray, &rgb));
-}
-
-void OPVPOutputDev::updateStrokeColor(GfxState *state) {
-  GfxGray gray;
-  GfxRGB rgb;
-
-  state->getStrokeGray(&gray);
-  state->getStrokeRGB(&rgb);
-  oprs->setStrokePattern(getColor(gray, &rgb));
-}
-
-#ifdef SPLASH_CMYK
-SplashPattern *OPVPOutputDev::getColor(double gray, GfxRGB *rgb,
-     GfxCMYK *cmyk) {
-#else
-SplashPattern *OPVPOutputDev::getColor(GfxGray gray, GfxRGB *rgb) {
-#endif
-  SplashPattern *pattern;
-  SplashColor  color1;
-  GfxColorComp r, g, b;
-
-  if (reverseVideo) {
-    gray = gfxColorComp1 - gray;
-    r = gfxColorComp1 - rgb->r;
-    g = gfxColorComp1 - rgb->g;
-    b = gfxColorComp1 - rgb->b;
-  } else {
-    r = rgb->r;
-    g = rgb->g;
-    b = rgb->b;
-  }
-
-  pattern = NULL; // make gcc happy
-  switch (colorMode) {
-  case splashModeMono1:
-  case splashModeMono8:
-    color1[0] = colToByte(gray);
-    pattern = new SplashSolidColor(color1);
-    break;
-  case splashModeRGB8:
-    color1[0] = colToByte(r);
-    color1[1] = colToByte(g);
-    color1[2] = colToByte(b);
-    pattern = new SplashSolidColor(color1);
-    break;
-#if SPLASH_CMYK
-  case splashModeCMYK8:
-    color[0] = colToByte(cmyk->c);
-    color[1] = colToByte(cmyk->m);
-    color[2] = colToByte(cmyk->y);
-    color[3] = colToByte(cmyk->k);
-    pattern = new SplashSolidColor(color);
-    break;
-#endif
-  default:
-    opvpError(-1, "no supported color mode");
-    break;
-  }
-
-  return pattern;
-}
-
-void OPVPOutputDev::updateFont(GfxState *state) {
-    needFontUpdate = true;
-}
-
-void OPVPOutputDev::doUpdateFont(GfxState *state) {
-  GfxFont *gfxFont;
-  GfxFontType fontType;
-  SplashOutFontFileID *id;
-  SplashFontFile *fontFile;
-  SplashFontSrc *fontsrc = NULL;
-  const char *fontName = "(unnamed)";
-  FoFiTrueType *ff;
-  Ref embRef;
-  Object refObj, strObj;
-  GooString *fileName;
-  char *tmpBuf;
-  int tmpBufLen;
-  int *codeToGID;
-  double m11, m12, m21, m22;
-  int n;
-  int faceIndex = 0;
-  bool recreateFont = false;
-
-  needFontUpdate = false;
-  font = NULL;
-  fileName = NULL;
-  tmpBuf = NULL;
-
-  if (!(gfxFont = state->getFont())) {
-    goto err1;
-  }
-  fontType = gfxFont->getType();
-  if (fontType == fontType3) {
-    goto err1;
-  }
-
-  // check the font file cache
-  id = new SplashOutFontFileID(gfxFont->getID());
-  if ((fontFile = fontEngine->getFontFile(id))) {
-    delete id;
-
-  } else {
-    if (gfxFont->getName()) {
-#if POPPLER_VERSION_MAJOR <= 0 && POPPLER_VERSION_MINOR <= 71
-      fontName = gfxFont->getName()->getCString();
-#else
-      fontName = gfxFont->getName()->c_str();
-#endif
-    }
-
-    // if there is an embedded font, write it to disk
-    if (gfxFont->getEmbeddedFontID(&embRef)) {
-      tmpBuf = gfxFont->readEmbFontFile(xref, &tmpBufLen);
-      if (! tmpBuf)
-	goto err2;
-
-    } else {
-      SysFontType sftype;
-      fileName = globalParams->findSystemFontFile(gfxFont,&sftype,
-                          &faceIndex, NULL);
-      if (fileName == 0) {
-	opvpError(-1, "Couldn't find a font for '%s'", fontName);
-	goto err2;
-      }
-      switch (sftype) {
-      case sysFontPFA:
-      case sysFontPFB:
-	fontType = gfxFont->isCIDFont() ? fontCIDType0 : fontType1;
-	break;
-      case sysFontTTF:
-      case sysFontTTC:
-	fontType = gfxFont->isCIDFont() ? fontCIDType2 : fontTrueType;
-	break;
-      }
-    }
-
-    fontsrc = new SplashFontSrc;
-    if (fileName)
-      fontsrc->setFile(fileName, false);
-    else
-      fontsrc->setBuf(tmpBuf, tmpBufLen, true);
-
-    // load the font file
-    switch (fontType) {
-    case fontType1:
-      if (!(fontFile = fontEngine->loadType1Font(
-			   id,
-			   fontsrc,
-                           (const char **)
-			   ((Gfx8BitFont *)gfxFont)->getEncoding()))) {
-	opvpError(-1, "Couldn't create a font for '%s'", fontName);
-	goto err2;
-      }
-      break;
-    case fontType1C:
-      if (!(fontFile = fontEngine->loadType1CFont(
-			   id,
-			   fontsrc,
-                           (const char **)
-			   ((Gfx8BitFont *)gfxFont)->getEncoding()))) {
-	opvpError(-1, "Couldn't create a font for '%s'", fontName);
-	goto err2;
-      }
-      break;
-    case fontType1COT:
-      if (!(fontFile = fontEngine->loadOpenTypeT1CFont(
-			   id,
-			   fontsrc,
-                           (const char **)
-			   ((Gfx8BitFont *)gfxFont)->getEncoding()))) {
-	opvpError(-1, "Couldn't create a font for '%s'", fontName);
-	goto err2;
-      }
-      break;
-    case fontTrueTypeOT:
-    case fontTrueType:
-	if (fileName)
-#if POPPLER_VERSION_MAJOR <= 0 && POPPLER_VERSION_MINOR <= 71
-	 ff = FoFiTrueType::load(fileName->getCString());
-#else
-	 ff = FoFiTrueType::load(fileName->c_str());
-#endif
-	else
-	ff = FoFiTrueType::make(tmpBuf, tmpBufLen);
-      if (ff) {
-	codeToGID = ((Gfx8BitFont *)gfxFont)->getCodeToGIDMap(ff);
-	n = 256;
-	delete ff;
-      } else {
-	codeToGID = NULL;
-	n = 0;
-      }
-      if (!(fontFile = fontEngine->loadTrueTypeFont(
-			   id,
-			   fontsrc,
-			   codeToGID, n))) {
-	opvpError(-1, "Couldn't create a font for '%s'", fontName);
-	goto err2;
-      }
-      break;
-    case fontCIDType0:
-    case fontCIDType0C:
-      if (!(fontFile = fontEngine->loadCIDFont(
-			   id,
-			   fontsrc))) {
-	opvpError(-1, "Couldn't create a font for '%s'", fontName);
-	goto err2;
-      }
-      break;
-    case fontCIDType0COT:
-      n = ((GfxCIDFont *)gfxFont)->getCIDToGIDLen();
-      if (n) {
-        codeToGID = (int *)gmallocn(n, sizeof(int));
-        memcpy(codeToGID, ((GfxCIDFont *)gfxFont)->getCIDToGID(),
-                n * sizeof(int));
-      } else {
-          codeToGID = NULL;
-      }
-      if (!(fontFile = fontEngine->loadOpenTypeCFFFont(
-			   id,
-			   fontsrc,codeToGID,n))) {
-	opvpError(-1, "Couldn't create a font for '%s'", fontName);
-	goto err2;
-      }
-      break;
-    case fontCIDType2OT:
-    case fontCIDType2:
-      codeToGID = NULL;
-      n = 0;
-      if (((GfxCIDFont *)gfxFont)->getCIDToGID()) {
-	n = ((GfxCIDFont *)gfxFont)->getCIDToGIDLen();
-	if (n) {
-	  codeToGID = (int *)gmallocn(n, sizeof(int));
-	  memcpy(codeToGID, ((GfxCIDFont *)gfxFont)->getCIDToGID(),
-		  n * sizeof(int));
-	}
-      } else {
-	if (fileName)
-#if POPPLER_VERSION_MAJOR <= 0 && POPPLER_VERSION_MINOR <= 71
-	  ff = FoFiTrueType::load(fileName->getCString());
-#else
-	  ff = FoFiTrueType::load(fileName->c_str());
-#endif
-	else
-	  ff = FoFiTrueType::make(tmpBuf, tmpBufLen);
-	if (! ff)
-	  goto err2;
-	codeToGID = ((GfxCIDFont *)gfxFont)->getCodeToGIDMap(ff, &n);
-	delete ff;
-      }
-      if (!(fontFile = fontEngine->loadTrueTypeFont(
-			   id,
-			   fontsrc,
-			   codeToGID, n, faceIndex))) {
-	opvpError(-1, "Couldn't create a font for '%s'", fontName);
-	goto err2;
-      }
-      break;
-    default:
-      // this shouldn't happen
-      goto err2;
-    }
-    fontFile->doAdjustMatrix = true;
-  }
-
-  // get the font matrix
-  state->getFontTransMat(&m11, &m12, &m21, &m22);
-  m11 *= state->getHorizScaling();
-  m12 *= state->getHorizScaling();
-
-  // create the scaled font
-  fontMat[0] = m11;  fontMat[1] = m12;
-  fontMat[2] = m21;  fontMat[3] = m22;
-  font = fontEngine->getFont(fontFile, fontMat, oprs->getMatrix());
-
-  // for substituted fonts: adjust the font matrix -- compare the
-  // width of 'm' in the original font and the substituted font
-  if (fontFile->doAdjustMatrix && !gfxFont->isCIDFont()) {
-    double w1, w2;
-    CharCode code;
-    const char *name;
-    for (code = 0; code < 256; ++code) {
-      if ((name = ((Gfx8BitFont *)gfxFont)->getCharName(code)) &&
-          name[0] == 'm' && name[1] == '\0') {
-        break;
-      }
-    }
-    if (code < 256) {
-      w1 = ((Gfx8BitFont *)gfxFont)->getWidth(code);
-      w2 = font->getGlyphAdvance(code);
-      if (!gfxFont->isSymbolic() && w2 > 0) {
-        // if real font is substantially narrower than substituted
-        // font, reduce the font size accordingly
-        if (w1 > 0.01 && w1 < 0.9 * w2) {
-          w1 /= w2;
-          m11 *= w1;
-          m21 *= w1;
-          recreateFont = true;
-        }
-      }
-    }
-  }
-
-  if (recreateFont)
-  {
-    fontMat[0] = m11;  fontMat[1] = m12;
-    fontMat[2] = m21;  fontMat[3] = m22;
-    font = fontEngine->getFont(fontFile, fontMat, oprs->getMatrix());
-  }
-
-  if (fontsrc && !fontsrc->isFile)
-      fontsrc->unref();
-  return;
-
- err2:
-  delete id;
- err1:
-  if (fontsrc && !fontsrc->isFile)
-      fontsrc->unref();
-  return;
-}
-
-void OPVPOutputDev::stroke(GfxState *state) {
-  OPVPSplashPath *path;
-  GfxColorSpace *cs;
-
-  /* check None separate color */
-  if ((cs = state->getStrokeColorSpace()) == NULL) return;
-  if (cs->getMode() == csSeparation) {
-    GooString *name;
-
-    name = (dynamic_cast<GfxSeparationColorSpace *>(cs))->getName();
-    if (name == NULL) return;
-    if (name->cmp("None") == 0) return;
-  }
-
-  path = convertPath(state, state->getPath());
-  oprs->stroke(path);
-  delete path;
-}
-
-void OPVPOutputDev::fill(GfxState *state) {
-  OPVPSplashPath *path;
-  GfxColorSpace *cs;
-
-  /* check None separate color */
-  if ((cs = state->getFillColorSpace()) == NULL) return;
-  if (cs->getMode() == csSeparation) {
-    GooString *name;
-
-    name = (dynamic_cast<GfxSeparationColorSpace *>(cs))->getName();
-    if (name == NULL) return;
-    if (name->cmp("None") == 0) return;
-  }
-
-  path = convertPath(state, state->getPath());
-  oprs->fill(path, false);
-  delete path;
-}
-
-void OPVPOutputDev::eoFill(GfxState *state) {
-  OPVPSplashPath *path;
-  GfxColorSpace *cs;
-
-  /* check None separate color */
-  if ((cs = state->getFillColorSpace()) == NULL) return;
-  if (cs->getMode() == csSeparation) {
-    GooString *name;
-
-    name = (dynamic_cast<GfxSeparationColorSpace *>(cs))->getName();
-    if (name == NULL) return;
-    if (name->cmp("None") == 0) return;
-  }
-
-  path = convertPath(state, state->getPath());
-  oprs->fill(path, true);
-  delete path;
-}
-
-void OPVPOutputDev::clip(GfxState *state) {
-  OPVPSplashPath *path;
-
-  path = convertPath(state, state->getPath());
-  oprs->clipToPath(path, false);
-  delete path;
-}
-
-void OPVPOutputDev::eoClip(GfxState *state) {
-  OPVPSplashPath *path;
-
-  path = convertPath(state, state->getPath());
-  oprs->clipToPath(path, true);
-  delete path;
-}
-
-OPVPSplashPath *OPVPOutputDev::bitmapToPath(SplashBitmap *bitmapA,
-    int width, int height)
-{
-  int x,y;
-  OPVPSplashPath *path;
-  int x1, x2;
-  SplashColor pix;
-
-  path =  new OPVPSplashPath();
-
-  for (y = 0;y < height;y++) {
-    for (x = 0;x < width;x++) {
-      bitmapA->getPixel(x,y,pix);
-      if (pix[0] == 0) {
-	/* start */
-	x1 = x;
-	for (x++;x < width;x++) {
-	  bitmapA->getPixel(x,y,pix);
-	  if (pix[0] != 0) {
-	    /* end */
-	    break;
-	  }
-	}
-	x2 = x-1;
-	path->moveTo(x1,y);
-	path->lineTo(x2,y);
-	path->lineTo(x2,(y+1));
-	path->lineTo(x1,(y+1));
-	path->close();
-      }
-    }
-  }
-  return path;
-}
-
-void OPVPOutputDev::clipToStrokePath(GfxState *state) {
-  SplashBitmap *tbitmap;
-  Splash *tsplash;
-  SplashPath *spath;
-  OPVPSplashPath *path, *path2;
-
-  // use splash for makeStrokePath
-  // create dummy bitmap for creating splash
-  tbitmap = new SplashBitmap(1, 1, 1, splashModeMono1, false);
-  tsplash = new Splash(tbitmap, false);
-  // set line parameters
-  //  except colors
-  updateSplashLineDash(state, tsplash);
-  tsplash->setLineJoin(state->getLineJoin());
-  tsplash->setLineCap(state->getLineCap());
-  tsplash->setMiterLimit(state->getMiterLimit());
-  tsplash->setLineWidth(state->getTransformedLineWidth());
-
-  path = convertPath(state, state->getPath());
-  spath = tsplash->makeStrokePath(path,0);
-  path2 = new OPVPSplashPath(spath);
-  delete spath;
-  delete path;
-  delete tsplash;
-  delete tbitmap;
-  oprs->clipToPath(path2, false);
-  delete path2;
-}
-
-OPVPSplashPath *OPVPOutputDev::convertPath(GfxState *state, GfxPath *path) {
-  OPVPSplashPath *sPath;
-  GfxSubpath *subpath;
-  double x1, y1, x2, y2, x3, y3;
-  int i, j;
-
-  sPath = new OPVPSplashPath();
-  for (i = 0; i < path->getNumSubpaths(); ++i) {
-    subpath = path->getSubpath(i);
-    if (subpath->getNumPoints() > 0) {
-      state->transform(subpath->getX(0), subpath->getY(0), &x1, &y1);
-      sPath->moveTo((SplashCoord)x1, (SplashCoord)y1);
-      j = 1;
-      while (j < subpath->getNumPoints()) {
-	if (subpath->getCurve(j)) {
-	  state->transform(subpath->getX(j), subpath->getY(j), &x1, &y1);
-	  state->transform(subpath->getX(j+1), subpath->getY(j+1), &x2, &y2);
-	  state->transform(subpath->getX(j+2), subpath->getY(j+2), &x3, &y3);
-	  sPath->curveTo((SplashCoord)x1, (SplashCoord)y1,
-			 (SplashCoord)x2, (SplashCoord)y2,
-			 (SplashCoord)x3, (SplashCoord)y3);
-	  j += 3;
-	} else {
-	  state->transform(subpath->getX(j), subpath->getY(j), &x1, &y1);
-	  sPath->lineTo((SplashCoord)x1, (SplashCoord)y1);
-	  ++j;
-	}
-      }
-      if (subpath->isClosed()) {
-	sPath->close();
-      }
-    }
-  }
-  return sPath;
-}
-
-void OPVPOutputDev::drawChar(GfxState *state, double x, double y,
-			       double dx, double dy,
-			       double originX, double originY,
-			       CharCode code, int nBytes,
-			       Unicode *u, int uLen) {
-  double x1, y1;
-  SplashPath *spath;
-  OPVPSplashPath *path;
-  int render;
-
-  // check for invisible text -- this is used by Acrobat Capture
-  render = state->getRender();
-  if (render == 3) {
-    return;
-  }
-
-  if (needFontUpdate) {
-    doUpdateFont(state);
-  }
-  if (!font) {
-    return;
-  }
-
-  x -= originX;
-  y -= originY;
-  state->transform(x,y,&x1,&y1);
-
-  // fill
-  if (!(render & 1)) {
-    oprs->fillChar((SplashCoord)x1, (SplashCoord)y1, code, font, u, fontMat);
-  }
-
-  // stroke
-  if ((render & 3) == 1 || (render & 3) == 2) {
-    if ((spath = font->getGlyphPath(code))) {
-      path = new OPVPSplashPath(spath);
-      delete spath;
-      path->closeAllSubPath();
-      path->offset((SplashCoord)x1, (SplashCoord)y1);
-      oprs->stroke(path);
-      delete path;
-    } else {
-      opvpError(-1,"No glyph outline infomation");
-    }
-  }
-
-  // clip
-  if (render & 4) {
-    if ((spath = font->getGlyphPath(code)) != NULL) {
-      path = new OPVPSplashPath(spath);
-      delete spath;
-      path->offset((SplashCoord)x1, (SplashCoord)y1);
-      if (textClipPath) {
-	textClipPath->append(path);
-	delete path;
-      } else {
-	textClipPath = path;
-      }
-    } else {
-      opvpError(-1,"No glyph outline infomation");
-    }
-  }
-}
-
-bool OPVPOutputDev::beginType3Char(GfxState *state, double x, double y,
-				      double dx, double dy,
-				      CharCode code, Unicode *u, int uLen) {
-  /* In a vector mode, cache is not needed */
-  return false;
-}
-
-void OPVPOutputDev::endType3Char(GfxState *state) {
-  /* In a vector mode, cache is not needed */
-  /* do nothing */
-}
-
-void OPVPOutputDev::type3D0(GfxState *state, double wx, double wy) {
-  /* In a vector mode, cache is not needed */
-  /* do nothing */
-}
-
-void OPVPOutputDev::type3D1(GfxState *state, double wx, double wy,
-			      double llx, double lly, double urx, double ury) {
-}
-
-void OPVPOutputDev::drawType3Glyph(T3FontCache *t3Font,
-				     T3FontCacheTag *tag, Guchar *data,
-				     double x, double y) {
-  SplashGlyphBitmap glyph;
-
-  glyph.x = -t3Font->glyphX;
-  glyph.y = -t3Font->glyphY;
-  glyph.w = t3Font->glyphW;
-  glyph.h = t3Font->glyphH;
-  glyph.aa = colorMode != splashModeMono1;
-  glyph.data = data;
-  glyph.freeData = false;
-  oprs->fillGlyph((SplashCoord)x, (SplashCoord)y, &glyph);
-}
-
-void OPVPOutputDev::endTextObject(GfxState *state) {
-  if (textClipPath) {
-    oprs->clipToPath(textClipPath, false);
-    delete textClipPath;
-    textClipPath = NULL;
-  }
-}
-
-struct SplashOutImageMaskData {
-  ImageStream *imgStr;
-  bool invert;
-  int width, height, y;
-};
-
-bool OPVPOutputDev::imageMaskSrc(void *data, SplashColorPtr line) {
-  SplashOutImageMaskData *imgMaskData = (SplashOutImageMaskData *)data;
-  Guchar *p;
-  SplashColorPtr q;
-  int x;
-
-  if (imgMaskData->y == imgMaskData->height) {
-    return false;
-  }
-  for (x = 0, p = imgMaskData->imgStr->getLine(), q = line;
-       x < imgMaskData->width;
-       ++x) {
-    *q++ = *p++ ^ imgMaskData->invert;
-  }
-  ++imgMaskData->y;
-  return true;
-}
-
-void OPVPOutputDev::drawImageMask(GfxState *state, Object *ref, Stream *str,
-				    int width, int height, bool invert,
-				    bool interpolate,
-				    bool inlineImg) {
-  const double *ctm;
-  SplashCoord mat[6];
-  SplashOutImageMaskData imgMaskData;
-
-  ctm = state->getCTM();
-  mat[0] = ctm[0];
-  mat[1] = ctm[1];
-  mat[2] = -ctm[2];
-  mat[3] = -ctm[3];
-  mat[4] = ctm[2] + ctm[4];
-  mat[5] = ctm[3] + ctm[5];
-
-  imgMaskData.imgStr = new ImageStream(str, width, 1, 1);
-  imgMaskData.imgStr->reset();
-  imgMaskData.invert = invert ? 0 : 1;
-  imgMaskData.width = width;
-  imgMaskData.height =  height;
-  imgMaskData.y = 0;
-
-  oprs->fillImageMask(&imageMaskSrc, &imgMaskData, width, height, mat,
-  		t3GlyphStack != NULL);
-  if (inlineImg) {
-    while (imgMaskData.y < height) {
-      imgMaskData.imgStr->getLine();
-      ++imgMaskData.y;
-    }
-  }
-
-  delete imgMaskData.imgStr;
-}
-
-struct SplashOutImageData {
-  ImageStream *imgStr;
-  GfxImageColorMap *colorMap;
-  SplashColorPtr lookup;
-  int *maskColors;
-  SplashColorMode colorMode;
-  int width, height, y;
-};
-
-bool OPVPOutputDev::imageSrc(void *data, SplashColorPtr line,
-                              Guchar *alphaLine)
-{
-  SplashOutImageData *imgData = (SplashOutImageData *)data;
-  Guchar *p;
-  SplashColorPtr q, col;
-  GfxRGB rgb;
-  GfxGray gray;
-#if SPLASH_CMYK
-  GfxCMYK cmyk;
-#endif
-  int nComps, x;
-
-  if (imgData->y == imgData->height) {
-    return false;
-  }
-
-  nComps = imgData->colorMap->getNumPixelComps();
-
-  if (imgData->lookup) {
-    switch (imgData->colorMode) {
-    case splashModeMono1:
-    case splashModeMono8:
-      for (x = 0, p = imgData->imgStr->getLine(), q = line;
-	   x < imgData->width;
-	   ++x, ++p) {
-	*q++ = imgData->lookup[*p];
-      }
-      break;
-    case splashModeRGB8:
-    case splashModeBGR8:
-      for (x = 0, p = imgData->imgStr->getLine(), q = line;
-	   x < imgData->width;
-	   ++x, ++p) {
-	col = &imgData->lookup[3 * *p];
-	*q++ = col[0];
-	*q++ = col[1];
-	*q++ = col[2];
-      }
-      break;
-#if SPLASH_CMYK
-    case splashModeCMYK8:
-      for (x = 0, p = imgData->imgStr->getLine(), q = line;
-	   x < imgData->width;
-	   ++x, ++p) {
-	col = &imgData->lookup[4 * *p];
-	*q++ = col[0];
-	*q++ = col[1];
-	*q++ = col[2];
-	*q++ = col[3];
-      }
-      break;
-#endif
-    default:
-      //~ unimplemented
-      break;
-  }
-  } else {
-    switch (imgData->colorMode) {
-    case splashModeMono1:
-    case splashModeMono8:
-      for (x = 0, p = imgData->imgStr->getLine(), q = line;
-	   x < imgData->width;
-	   ++x, p += nComps) {
-	imgData->colorMap->getGray(p, &gray);
-	*q++ = colToByte(gray);
-      }
-	break;
-    case splashModeRGB8:
-      for (x = 0, p = imgData->imgStr->getLine(), q = line;
-	   x < imgData->width;
-	   ++x, p += nComps) {
-	imgData->colorMap->getRGB(p, &rgb);
-	*q++ = colToByte(rgb.r);
-	*q++ = colToByte(rgb.g);
-	*q++ = colToByte(rgb.b);
-      }
-      break;
-    case splashModeBGR8:
-      for (x = 0, p = imgData->imgStr->getLine(), q = line;
-	   x < imgData->width;
-	   ++x, p += nComps) {
-	imgData->colorMap->getRGB(p, &rgb);
-	*q++ = colToByte(rgb.b);
-	*q++ = colToByte(rgb.g);
-	*q++ = colToByte(rgb.r);
-      }
-      break;
-#if SPLASH_CMYK
-    case splashModeCMYK8:
-      for (x = 0, p = imgData->imgStr->getLine(), q = line;
-	   x < imgData->width;
-	   ++x, p += nComps) {
-	imgData->colorMap->getCMYK(p, &cmyk);
-	*q++ = colToByte(cmyk.c);
-	*q++ = colToByte(cmyk.m);
-	*q++ = colToByte(cmyk.y);
-	*q++ = colToByte(cmyk.k);
-      }
-      break;
-#endif
-    default:
-      //~ unimplemented
-      break;
-    }
-  }
-
-  ++imgData->y;
-  return true;
-}
-
-bool OPVPOutputDev::alphaImageSrc(void *data, SplashColorPtr line,
-                                  Guchar *alphaLine) {
-  SplashOutImageData *imgData = (SplashOutImageData *)data;
-  Guchar *p;
-  SplashColorPtr q, col;
-  GfxRGB rgb;
-  GfxGray gray;
-#if SPLASH_CMYK
-  GfxCMYK cmyk;
-#endif
-  Guchar alpha;
-  int nComps, x, i;
-
-  if (imgData->y == imgData->height) {
-    return false;
-  }
-
-  nComps = imgData->colorMap->getNumPixelComps();
-
-  for (x = 0, p = imgData->imgStr->getLine(), q = line;
-       x < imgData->width;
-       ++x, p += nComps) {
-    alpha = 0;
-    for (i = 0; i < nComps; ++i) {
-      if (p[i] < imgData->maskColors[2*i] ||
-	  p[i] > imgData->maskColors[2*i+1]) {
-	alpha = 0xff;
-	break;
-      }
-    }
-    if (imgData->lookup) {
-      switch (imgData->colorMode) {
-      case splashModeMono1:
-      case splashModeMono8:
-	*q++ = alpha;
-	*q++ = imgData->lookup[*p];
-	break;
-      case splashModeRGB8:
-	*q++ = alpha;
-	col = &imgData->lookup[3 * *p];
-	*q++ = col[0];
-	*q++ = col[1];
-	*q++ = col[2];
-	break;
-      case splashModeBGR8:
-	col = &imgData->lookup[3 * *p];
-	*q++ = col[0];
-	*q++ = col[1];
-	*q++ = col[2];
-	*q++ = alpha;
-	break;
-#if SPLASH_CMYK
-      case splashModeCMYK8:
-	*q++ = alpha;
-	col = &imgData->lookup[4 * *p];
-	*q++ = col[0];
-	*q++ = col[1];
-	*q++ = col[2];
-	*q++ = col[3];
-	break;
-#endif
-      default:
-	//~ unimplemented
-	break;
-      }
-    } else {
-      switch (imgData->colorMode) {
-      case splashModeMono1:
-      case splashModeMono8:
-	imgData->colorMap->getGray(p, &gray);
-	*q++ = alpha;
-	*q++ = colToByte(gray);
-	break;
-      case splashModeRGB8:
-	imgData->colorMap->getRGB(p, &rgb);
-	*q++ = alpha;
-	*q++ = colToByte(rgb.r);
-	*q++ = colToByte(rgb.g);
-	*q++ = colToByte(rgb.b);
-	break;
-      case splashModeBGR8:
-	imgData->colorMap->getRGB(p, &rgb);
-	*q++ = colToByte(rgb.b);
-	*q++ = colToByte(rgb.g);
-	*q++ = colToByte(rgb.r);
-	*q++ = alpha;
-	break;
-#if SPLASH_CMYK
-      case splashModeCMYK8:
-	imgData->colorMap->getCMYK(p, &cmyk);
-	*q++ = alpha;
-	*q++ = colToByte(cmyk.c);
-	*q++ = colToByte(cmyk.m);
-	*q++ = colToByte(cmyk.y);
-	*q++ = colToByte(cmyk.k);
-	break;
-#endif
-      default:
-	//~ unimplemented
-	break;
-      }
-    }
-  }
-
-  ++imgData->y;
-  return true;
-}
-
-void OPVPOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,
-				int width, int height,
-				GfxImageColorMap *colorMap,
-			        bool interpolate,
-				int *maskColors, bool inlineImg) {
-  const double *ctm;
-  SplashCoord mat[6];
-  SplashOutImageData imgData;
-  SplashColorMode srcMode;
-  SplashImageSource src;
-  GfxGray gray;
-  GfxRGB rgb;
-#if SPLASH_CMYK
-  GfxCMYK cmyk;
-#endif
-  Guchar pix;
-  int n, i;
-
-  ctm = state->getCTM();
-  mat[0] = ctm[0];
-  mat[1] = ctm[1];
-  mat[2] = -ctm[2];
-  mat[3] = -ctm[3];
-  mat[4] = ctm[2] + ctm[4];
-  mat[5] = ctm[3] + ctm[5];
-
-  imgData.imgStr = new ImageStream(str, width,
-				   colorMap->getNumPixelComps(),
-				   colorMap->getBits());
-  imgData.imgStr->reset();
-  imgData.colorMap = colorMap;
-  imgData.maskColors = maskColors;
-  imgData.colorMode = colorMode;
-  imgData.width = width;
-  imgData.height = height;
-  imgData.y = 0;
-
-  // special case for one-channel (monochrome/gray/separation) images:
-  // build a lookup table here
-  imgData.lookup = NULL;
-  if (colorMap->getNumPixelComps() == 1) {
-    n = 1 << colorMap->getBits();
-    switch (colorMode) {
-    case splashModeMono1:
-    case splashModeMono8:
-      imgData.lookup = (SplashColorPtr)gmallocn(n,1);
-      for (i = 0; i < n; ++i) {
-	pix = (Guchar)i;
-	colorMap->getGray(&pix, &gray);
-	imgData.lookup[i] = colToByte(gray);
-      }
-      break;
-    case splashModeRGB8:
-      imgData.lookup = (SplashColorPtr)gmallocn(n,3);
-      for (i = 0; i < n; ++i) {
-	pix = (Guchar)i;
-	colorMap->getRGB(&pix, &rgb);
-	imgData.lookup[3*i] = colToByte(rgb.r);
-	imgData.lookup[3*i+1] = colToByte(rgb.g);
-	imgData.lookup[3*i+2] = colToByte(rgb.b);
-      }
-      break;
-    case splashModeBGR8:
-      imgData.lookup = (SplashColorPtr)gmallocn(n,3);
-      for (i = 0; i < n; ++i) {
-	pix = (Guchar)i;
-	colorMap->getRGB(&pix, &rgb);
-	imgData.lookup[3*i] = colToByte(rgb.b);
-	imgData.lookup[3*i+1] = colToByte(rgb.g);
-	imgData.lookup[3*i+2] = colToByte(rgb.r);
-      }
-      break;
-#if SPLASH_CMYK
-    case splashModeCMYK8:
-      imgData.lookup = (SplashColorPtr)gmallocn(n,4);
-      for (i = 0; i < n; ++i) {
-	pix = (Guchar)i;
-	colorMap->getCMYK(&pix, &cmyk);
-	imgData.lookup[4*i] = colToByte(cmyk.c);
-	imgData.lookup[4*i+1] = colToByte(cmyk.m);
-	imgData.lookup[4*i+2] = colToByte(cmyk.y);
-	imgData.lookup[4*i+3] = colToByte(cmyk.k);
-      }
-      break;
-#endif
-    default:
-      //~ unimplemented
-      break;
-    }
-  }
-
-  if (colorMode == splashModeMono1) {
-    srcMode = splashModeMono8;
-  } else {
-    srcMode = colorMode;
-  }
-  src = maskColors ? &alphaImageSrc : &imageSrc;
-  oprs->drawImage(src, &imgData, srcMode, maskColors ? true : false,
-                  width, height, mat);
-  if (inlineImg) {
-    while (imgData.y < height) {
-      imgData.imgStr->getLine();
-      ++imgData.y;
-    }
-  }
-
-  gfree(imgData.lookup);
-  delete imgData.imgStr;
-  str->close();
-}
-
-struct SplashOutMaskedImageData {
-  ImageStream *imgStr;
-  GfxImageColorMap *colorMap;
-  SplashBitmap *mask;
-  SplashColorPtr lookup;
-  SplashColorMode colorMode;
-  int width, height, y;
-};
-
-bool OPVPOutputDev::maskedImageSrc(void *data, SplashColorPtr line,
-     Guchar *alphaLine) {
-  SplashOutMaskedImageData *imgData = (SplashOutMaskedImageData *)data;
-  Guchar *p;
-  SplashColor maskColor;
-  SplashColorPtr q, col;
-  GfxRGB rgb;
-  GfxGray gray;
-#if SPLASH_CMYK
-  GfxCMYK cmyk;
-#endif
-  Guchar alpha;
-  int nComps, x;
-
-  if (imgData->y == imgData->height) {
-    return false;
-  }
-
-  nComps = imgData->colorMap->getNumPixelComps();
-
-  for (x = 0, p = imgData->imgStr->getLine(), q = line;
-       x < imgData->width;
-       ++x, p += nComps) {
-    imgData->mask->getPixel(x, imgData->y, maskColor);
-    alpha = maskColor[0] ? 0xff : 0x00;
-    if (imgData->lookup) {
-      switch (imgData->colorMode) {
-      case splashModeMono1:
-      case splashModeMono8:
-	*q++ = alpha;
-	*q++ = imgData->lookup[*p];
-	break;
-      case splashModeRGB8:
-	*q++ = alpha;
-	col = &imgData->lookup[3 * *p];
-	*q++ = col[0];
-	*q++ = col[1];
-	*q++ = col[2];
-	break;
-      case splashModeBGR8:
-	col = &imgData->lookup[3 * *p];
-	*q++ = col[0];
-	*q++ = col[1];
-	*q++ = col[2];
-	*q++ = alpha;
-	break;
-#if SPLASH_CMYK
-      case splashModeCMYK8:
-	*q++ = alpha;
-	col = &imgData->lookup[4 * *p];
-	*q++ = col[0];
-	*q++ = col[1];
-	*q++ = col[2];
-	*q++ = col[3];
-	break;
-#endif
-      default:
-	//~ unimplemented
-	break;
-      }
-    } else {
-      switch (imgData->colorMode) {
-      case splashModeMono1:
-      case splashModeMono8:
-	imgData->colorMap->getGray(p, &gray);
-	*q++ = alpha;
-	*q++ = colToByte(gray);
-	break;
-      case splashModeRGB8:
-	imgData->colorMap->getRGB(p, &rgb);
-	*q++ = alpha;
-	*q++ = colToByte(rgb.r);
-	*q++ = colToByte(rgb.g);
-	*q++ = colToByte(rgb.b);
-	break;
-      case splashModeBGR8:
-	imgData->colorMap->getRGB(p, &rgb);
-	*q++ = colToByte(rgb.b);
-	*q++ = colToByte(rgb.g);
-	*q++ = colToByte(rgb.r);
-	*q++ = alpha;
-	break;
-#if SPLASH_CMYK
-      case splashModeCMYK8:
-	imgData->colorMap->getCMYK(p, &cmyk);
-	*q++ = alpha;
-	*q++ = colToByte(cmyk.c);
-	*q++ = colToByte(cmyk.m);
-	*q++ = colToByte(cmyk.y);
-	*q++ = colToByte(cmyk.k);
-	break;
-#endif
-      default:
-	//~ unimplemented
-	break;
-      }
-    }
-  }
-
-  ++imgData->y;
-  return true;
-}
-
-void OPVPOutputDev::drawMaskedImage(GfxState *state, Object *ref,
-				      Stream *str, int width, int height,
-				      GfxImageColorMap *colorMap,
-				      bool interpolate,
-				      Stream *maskStr, int maskWidth,
-				      int maskHeight, bool maskInvert,
-				      bool maskInterpolate) {
-  const double *ctm;
-  SplashCoord mat[6];
-  SplashOutMaskedImageData imgData;
-  SplashOutImageMaskData imgMaskData;
-  SplashColorMode srcMode;
-  SplashBitmap *maskBitmap;
-  Splash *maskSplash;
-  SplashColor maskColor;
-  GfxGray gray;
-  GfxRGB rgb;
-#if SPLASH_CMYK
-  GfxCMYK cmyk;
-#endif
-  Guchar pix;
-  int n, i;
-
-  //----- scale the mask image to the same size as the source image
-
-  mat[0] = (SplashCoord)width;
-  mat[1] = 0;
-  mat[2] = 0;
-  mat[3] = (SplashCoord)height;
-  mat[4] = 0;
-  mat[5] = 0;
-  imgMaskData.imgStr = new ImageStream(maskStr, maskWidth, 1, 1);
-  imgMaskData.imgStr->reset();
-  imgMaskData.invert = maskInvert ? 0 : 1;
-  imgMaskData.width = maskWidth;
-  imgMaskData.height = maskHeight;
-  imgMaskData.y = 0;
-  maskBitmap = new SplashBitmap(width, height, 1, splashModeMono1, false);
-  maskSplash = new Splash(maskBitmap, false);
-  maskColor[0] = 0;
-  maskSplash->clear(maskColor);
-  maskColor[0] = 1;
-  maskSplash->setFillPattern(new SplashSolidColor(maskColor));
-  maskSplash->fillImageMask(&imageMaskSrc, &imgMaskData,
-			    maskWidth, maskHeight, mat, false);
-  delete imgMaskData.imgStr;
-  maskStr->close();
-  delete maskSplash;
-
-  //----- draw the source image
-
-  ctm = state->getCTM();
-  mat[0] = ctm[0];
-  mat[1] = ctm[1];
-  mat[2] = -ctm[2];
-  mat[3] = -ctm[3];
-  mat[4] = ctm[2] + ctm[4];
-  mat[5] = ctm[3] + ctm[5];
-
-  imgData.imgStr = new ImageStream(str, width,
-				   colorMap->getNumPixelComps(),
-				   colorMap->getBits());
-  imgData.imgStr->reset();
-  imgData.colorMap = colorMap;
-  imgData.mask = maskBitmap;
-  imgData.colorMode = colorMode;
-  imgData.width = width;
-  imgData.height = height;
-  imgData.y = 0;
-
-  // special case for one-channel (monochrome/gray/separation) images:
-  // build a lookup table here
-  imgData.lookup = NULL;
-  if (colorMap->getNumPixelComps() == 1) {
-    n = 1 << colorMap->getBits();
-    switch (colorMode) {
-    case splashModeMono1:
-    case splashModeMono8:
-      imgData.lookup = (SplashColorPtr)gmallocn(n,1);
-      for (i = 0; i < n; ++i) {
-	pix = (Guchar)i;
-	colorMap->getGray(&pix, &gray);
-	imgData.lookup[i] = colToByte(gray);
-      }
-      break;
-    case splashModeRGB8:
-      imgData.lookup = (SplashColorPtr)gmallocn(n,3);
-      for (i = 0; i < n; ++i) {
-	pix = (Guchar)i;
-	colorMap->getRGB(&pix, &rgb);
-	imgData.lookup[3*i] = colToByte(rgb.r);
-	imgData.lookup[3*i+1] = colToByte(rgb.g);
-	imgData.lookup[3*i+2] = colToByte(rgb.b);
-      }
-      break;
-    case splashModeBGR8:
-      imgData.lookup = (SplashColorPtr)gmallocn(n,3);
-      for (i = 0; i < n; ++i) {
-	pix = (Guchar)i;
-	colorMap->getRGB(&pix, &rgb);
-	imgData.lookup[3*i] = colToByte(rgb.b);
-	imgData.lookup[3*i+1] = colToByte(rgb.g);
-	imgData.lookup[3*i+2] = colToByte(rgb.r);
-      }
-      break;
-#if SPLASH_CMYK
-    case splashModeCMYK8:
-      imgData.lookup = (SplashColorPtr)gmallocn(n,4);
-      for (i = 0; i < n; ++i) {
-	pix = (Guchar)i;
-	colorMap->getCMYK(&pix, &cmyk);
-	imgData.lookup[4*i] = colToByte(cmyk.c);
-	imgData.lookup[4*i+1] = colToByte(cmyk.m);
-	imgData.lookup[4*i+2] = colToByte(cmyk.y);
-	imgData.lookup[4*i+3] = colToByte(cmyk.k);
-      }
-      break;
-#endif
-    default:
-      //~ unimplemented
-      break;
-    }
-  }
-
-  switch (colorMode) {
-  case splashModeMono1:
-  case splashModeMono8:
-    srcMode = splashModeMono8;
-    break;
-  case splashModeRGB8:
-    srcMode = splashModeRGB8;
-    break;
-  case splashModeBGR8:
-    srcMode = splashModeBGR8;
-    break;
-#if SPLASH_CMYK
-  case splashModeCMYK8:
-    srcMode = splashModeCMYK8;
-    break;
-#endif
-  default:
-    //~ unimplemented
-    srcMode = splashModeRGB8;
-    break;
-  }  
-  oprs->drawImage(&maskedImageSrc, &imgData, srcMode, true,
-                  width, height, mat);
-
-  delete maskBitmap;
-  gfree(imgData.lookup);
-  delete imgData.imgStr;
-  str->close();
-}
-
-void OPVPOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref,
-					  Stream *str, int width, int height,
-					  GfxImageColorMap *colorMap,
-					  bool interpolate,
-					  Stream *maskStr,
-					  int maskWidth, int maskHeight,
-					  GfxImageColorMap *maskColorMap,
-					  bool maskInterpolate) {
-  const double *ctm;
-  SplashCoord mat[6];
-  SplashOutImageData imgData;
-  SplashOutImageData imgMaskData;
-  SplashColorMode srcMode;
-  SplashBitmap *maskBitmap;
-  Splash *maskSplash;
-  SplashColor maskColor;
-  GfxGray gray;
-  GfxRGB rgb;
-#if SPLASH_CMYK
-  GfxCMYK cmyk;
-#endif
-  Guchar pix;
-  int n, i;
-
-  ctm = state->getCTM();
-  mat[0] = ctm[0];
-  mat[1] = ctm[1];
-  mat[2] = -ctm[2];
-  mat[3] = -ctm[3];
-  mat[4] = ctm[2] + ctm[4];
-  mat[5] = ctm[3] + ctm[5];
-
-  //----- set up the soft mask
-
-  imgMaskData.imgStr = new ImageStream(maskStr, maskWidth,
-				       maskColorMap->getNumPixelComps(),
-				       maskColorMap->getBits());
-  imgMaskData.imgStr->reset();
-  imgMaskData.colorMap = maskColorMap;
-  imgMaskData.maskColors = NULL;
-  imgMaskData.colorMode = splashModeMono8;
-  imgMaskData.width = maskWidth;
-  imgMaskData.height = maskHeight;
-  imgMaskData.y = 0;
-  n = 1 << maskColorMap->getBits();
-  imgMaskData.lookup = (SplashColorPtr)gmallocn(n,1);
-  for (i = 0; i < n; ++i) {
-    pix = (Guchar)i;
-    maskColorMap->getGray(&pix, &gray);
-    imgMaskData.lookup[i] = colToByte(gray);
-  }
-  maskBitmap = new SplashBitmap(maskWidth,maskHeight,
-				1, splashModeMono8, false);
-  maskSplash = new Splash(maskBitmap, false);
-  maskColor[0] = 0;
-  maskSplash->clear(maskColor);
-#if POPPLER_VERSION_MAJOR <= 0 && (POPPLER_VERSION_MINOR <= 20 || (POPPLER_VERSION_MINOR == 21 && POPPLER_VERSION_MICRO <= 2))
-  maskSplash->drawImage(&imageSrc, &imgMaskData,
-			splashModeMono8, false, maskWidth, maskHeight, mat);
-#elif POPPLER_VERSION_MAJOR <= 0 && POPPLER_VERSION_MINOR <= 33
-  maskSplash->drawImage(&imageSrc, &imgMaskData,
-			splashModeMono8, false, maskWidth, maskHeight,
-                        mat,false);
-#else
-  maskSplash->drawImage(&imageSrc, 0, &imgMaskData,
-                          splashModeMono8, false, maskWidth, maskHeight,
-			                          mat,false);
-#endif
-  delete imgMaskData.imgStr;
-  maskStr->close();
-  gfree(imgMaskData.lookup);
-  delete maskSplash;
-  oprs->setSoftMask(maskBitmap);
-
-  //----- draw the source image
-
-  imgData.imgStr = new ImageStream(str, width,
-				   colorMap->getNumPixelComps(),
-				   colorMap->getBits());
-  imgData.imgStr->reset();
-  imgData.colorMap = colorMap;
-  imgData.maskColors = NULL;
-  imgData.colorMode = colorMode;
-  imgData.width = width;
-  imgData.height = height;
-  imgData.y = 0;
-
-  // special case for one-channel (monochrome/gray/separation) images:
-  // build a lookup table here
-  imgData.lookup = NULL;
-  if (colorMap->getNumPixelComps() == 1) {
-    n = 1 << colorMap->getBits();
-    switch (colorMode) {
-    case splashModeMono1:
-    case splashModeMono8:
-      imgData.lookup = (SplashColorPtr)gmallocn(n,1);
-      for (i = 0; i < n; ++i) {
-	pix = (Guchar)i;
-	colorMap->getGray(&pix, &gray);
-	imgData.lookup[i] = colToByte(gray);
-      }
-      break;
-    case splashModeRGB8:
-      imgData.lookup = (SplashColorPtr)gmallocn(n,3);
-      for (i = 0; i < n; ++i) {
-	pix = (Guchar)i;
-	colorMap->getRGB(&pix, &rgb);
-	imgData.lookup[3*i] = colToByte(rgb.r);
-	imgData.lookup[3*i+1] = colToByte(rgb.g);
-	imgData.lookup[3*i+2] = colToByte(rgb.b);
-      }
-      break;
-    case splashModeBGR8:
-      imgData.lookup = (SplashColorPtr)gmallocn(n,3);
-      for (i = 0; i < n; ++i) {
-	pix = (Guchar)i;
-	colorMap->getRGB(&pix, &rgb);
-	imgData.lookup[3*i] = colToByte(rgb.b);
-	imgData.lookup[3*i+1] = colToByte(rgb.g);
-	imgData.lookup[3*i+2] = colToByte(rgb.r);
-      }
-      break;
-#if SPLASH_CMYK
-    case splashModeCMYK8:
-      imgData.lookup = (SplashColorPtr)gmallocn(n,4);
-      for (i = 0; i < n; ++i) {
-	pix = (Guchar)i;
-	colorMap->getCMYK(&pix, &cmyk);
-	imgData.lookup[4*i] = colToByte(cmyk.c);
-	imgData.lookup[4*i+1] = colToByte(cmyk.m);
-	imgData.lookup[4*i+2] = colToByte(cmyk.y);
-	imgData.lookup[4*i+3] = colToByte(cmyk.k);
-      }
-      break;
-#endif
-    default:
-      //~ unimplemented
-      break;
-    }
-  }
-
-  switch (colorMode) {
-  case splashModeMono1:
-  case splashModeMono8:
-    srcMode = splashModeMono8;
-    break;
-  case splashModeRGB8:
-    srcMode = splashModeRGB8;
-    break;
-  case splashModeBGR8:
-    srcMode = splashModeBGR8;
-    break;
-#if SPLASH_CMYK
-  case splashModeCMYK8:
-    srcMode = splashModeCMYK8;
-    break;
-#endif
-  default:
-    //~ unimplemented
-    srcMode = splashModeRGB8;
-    break;
-  }  
-  oprs->drawImage(&imageSrc, &imgData, srcMode, false, width, height, mat);
-
-  oprs->setSoftMask(NULL);
-  gfree(imgData.lookup);
-  delete imgData.imgStr;
-  str->close();
-}
-
-int OPVPOutputDev::getBitmapWidth() {
-  return bitmap->getWidth();
-}
-
-int OPVPOutputDev::getBitmapHeight() {
-  return bitmap->getHeight();
-}
-
-void OPVPOutputDev::xorRectangle(int x0, int y0, int x1, int y1,
-				   SplashPattern *pattern) {
-    /* no need in printing */
-}
-
-void OPVPOutputDev::setFillColor(int r, int g, int b) {
-  GfxRGB rgb;
-  GfxGray gray;
-#if SPLASH_CMYK
-  GfxCMYK cmyk;
-#endif
-
-  rgb.r = byteToCol(r);
-  rgb.g = byteToCol(g);
-  rgb.b = byteToCol(b);
-  gray = (GfxColorComp)(0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.g + 0.5);
-  if (gray > gfxColorComp1) {
-    gray = gfxColorComp1;
-  }
-#if SPLASH_CMYK
-  cmyk.c = gfxColorComp1 - rgb.r;
-  cmyk.m = gfxColorComp1 - rgb.g;
-  cmyk.y = gfxColorComp1 - rgb.b;
-  cmyk.k = 0;
-  oprs->setFillPattern(getColor(gray, &rgb, &cmyk));
-#else
-  oprs->setFillPattern(getColor(gray, &rgb));
-#endif
-}
-
-int OPVPOutputDev::OPVPStartJob(char *jobInfo)
-{
-    return oprs->OPVPStartJob(jobInfo);
-}
-
-int OPVPOutputDev::OPVPEndJob()
-{
-    return oprs->OPVPEndJob();
-}
-
-int OPVPOutputDev::OPVPStartDoc(char *docInfo)
-{
-    return oprs->OPVPStartDoc(docInfo);
-}
-
-int OPVPOutputDev::OPVPEndDoc()
-{
-    return oprs->OPVPEndDoc();
-}
-
-int OPVPOutputDev::OPVPStartPage(char *pageInfo,
-  int rasterWidth, int rasterHeight)
-{
-    paperWidth = rasterWidth;
-    paperHeight = rasterHeight;
-    return oprs->OPVPStartPage(pageInfo,rasterWidth);
-}
-
-int OPVPOutputDev::OPVPEndPage()
-{
-    return oprs->OPVPEndPage();
-}
-
-int OPVPOutputDev::outSlice()
-{
-    return oprs->outSlice();
-}
-
-void OPVPOutputDev::psXObject(Stream *psStream, Stream *level1Stream)
-{
-  opvpError(-1,"psXObject is found, but it is not supported");
-}
diff --git a/filter/pdftoopvp/OPVPOutputDev.h b/filter/pdftoopvp/OPVPOutputDev.h
deleted file mode 100644
index f3d0825..0000000
--- a/filter/pdftoopvp/OPVPOutputDev.h
+++ /dev/null
@@ -1,250 +0,0 @@
-//========================================================================
-//
-// OPVPOutputDev.h
-//
-// Copyright 2005 AXE,Inc.
-//
-//========================================================================
-
-#ifndef OPVPOUTPUTDEV_H
-#define OPVPOUTPUTDEV_H
-
-#include <config.h>
-
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
-#include "goo/gtypes.h"
-#include "splash/SplashTypes.h"
-#include "config.h"
-#include "OutputDev.h"
-#include "GfxState.h"
-#include "GfxFont.h"
-
-class GfxState;
-class GfxPath;
-class Gfx8BitFont;
-class SplashBitmap;
-class OPRS;
-class OPVPSplashPath;
-class SplashPattern;
-class SplashFontEngine;
-class SplashFont;
-class T3FontCache;
-struct T3FontCacheTag;
-struct T3GlyphStack;
-struct GfxRGB;
-
-//------------------------------------------------------------------------
-
-// number of Type 3 fonts to cache
-#define splashOutT3FontCacheSize 8
-
-//------------------------------------------------------------------------
-// OPVPOutputDev
-//------------------------------------------------------------------------
-
-class OPVPOutputDev: public OutputDev {
-public:
-
-  // Constructor.
-  OPVPOutputDev();
-
-  // Second Constructor
-  int init(SplashColorMode colorModeA, bool colorProfile, bool reverseVideoA,
-		  SplashColor paperColorA,
-		  const char *driverName, int outputFD,
-		  const char *printerModel,
-		  int nOptions,
-		  const char *optionKeys[], const char *optionVals[]);
-
-  // Destructor.
-  virtual ~OPVPOutputDev();
-
-  //----- get info about output device
-
-  // Does this device use upside-down coordinates?
-  // (Upside-down means (0,0) is the top left corner of the page.)
-  virtual bool upsideDown() { return true; }
-
-  // Does this device use drawChar() or drawString()?
-  virtual bool useDrawChar() { return true; }
-
-  // Does this device use beginType3Char/endType3Char?  Otherwise,
-  // text in Type 3 fonts will be drawn with drawChar/drawString.
-  virtual bool interpretType3Chars() { return true; }
-
-  //----- initialization and control
-
-  // Start a page.
-  virtual void startPage(int pageNum, GfxState *state);
-
-  // End a page.
-  virtual void endPage();
-
-  //----- save/restore graphics state
-  virtual void saveState(GfxState *state);
-  virtual void restoreState(GfxState *state);
-
-  //----- update graphics state
-  virtual void updateAll(GfxState *state);
-  virtual void updateCTM(GfxState *state, double m11, double m12,
-			 double m21, double m22, double m31, double m32);
-  virtual void updateLineDash(GfxState *state);
-  virtual void updateFlatness(GfxState *state);
-  virtual void updateLineJoin(GfxState *state);
-  virtual void updateLineCap(GfxState *state);
-  virtual void updateMiterLimit(GfxState *state);
-  virtual void updateLineWidth(GfxState *state);
-  virtual void updateFillColor(GfxState *state);
-  virtual void updateStrokeColor(GfxState *state);
-
-  //----- update text state
-  virtual void updateFont(GfxState *state);
-
-  //----- path painting
-  virtual void stroke(GfxState *state);
-  virtual void fill(GfxState *state);
-  virtual void eoFill(GfxState *state);
-
-  //----- path clipping
-  virtual void clip(GfxState *state);
-  virtual void eoClip(GfxState *state);
-  virtual void clipToStrokePath(GfxState *state);
-
-  //----- text drawing
-  virtual void drawChar(GfxState *state, double x, double y,
-			double dx, double dy,
-			double originX, double originY,
-			CharCode code, int nBytes, Unicode *u, int uLen);
-  virtual bool beginType3Char(GfxState *state, double x, double y,
-			       double dx, double dy,
-			       CharCode code, Unicode *u, int uLen);
-  virtual void endType3Char(GfxState *state);
-  virtual void endTextObject(GfxState *state);
-
-  //----- image drawing
-  virtual void drawImageMask(GfxState *state, Object *ref, Stream *str,
-			     int width, int height, bool invert,
-			     bool interpolate,
-			     bool inlineImg);
-  virtual void drawImage(GfxState *state, Object *ref, Stream *str,
-			 int width, int height, GfxImageColorMap *colorMap,
-			 bool interpolate,
-			 int *maskColors, bool inlineImg);
-  virtual void drawMaskedImage(GfxState *state, Object *ref, Stream *str,
-			       int width, int height,
-			       GfxImageColorMap *colorMap,
-			       bool interpolate,
-			       Stream *maskStr, int maskWidth, int maskHeight,
-			       bool maskInvert, bool maskeInterpolate);
-  virtual void drawSoftMaskedImage(GfxState *state, Object *ref, Stream *str,
-				   int width, int height,
-				   GfxImageColorMap *colorMap,
-				   bool interpolate,
-				   Stream *maskStr,
-				   int maskWidth, int maskHeight,
-				   GfxImageColorMap *maskColorMap,
-				   bool maskInterpolate);
-
-  //----- Type 3 font operators
-  virtual void type3D0(GfxState *state, double wx, double wy);
-  virtual void type3D1(GfxState *state, double wx, double wy,
-		       double llx, double lly, double urx, double ury);
-
-  //----- special access
-
-  // Called to indicate that a new PDF document has been loaded.
-  void startDoc(XRef *xrefA);
-
-  bool isReverseVideo() { return reverseVideo; }
-
-  // Get the bitmap and its size.
-  SplashBitmap *getBitmap() { return bitmap; }
-  int getBitmapWidth();
-  int getBitmapHeight();
-
-  // Get the Splash object.
-  OPRS *getOPRS() { return oprs; }
-
-  // XOR a rectangular region in the bitmap with <pattern>.  <pattern>
-  // is passed to Splash::setFillPattern, so it should not be used
-  // after calling this function.
-  void xorRectangle(int x0, int y0, int x1, int y1, SplashPattern *pattern);
-
-  // Set the Splash fill color.
-  void setFillColor(int r, int g, int b);
-
-  void setUnderlayCbk(void (*cbk)(void *data), void *data)
-    { underlayCbk = cbk; underlayCbkData = data; }
-
-  int OPVPStartJob(char *jobInfo);
-  int OPVPEndJob();
-  int OPVPStartDoc(char *docInfo);
-  int OPVPEndDoc();
-  int OPVPStartPage(char *pageInfo, int rasterWidth, int rasterHeight);
-  int OPVPEndPage();
-  int outSlice();
-  virtual void psXObject(Stream *psStream, Stream *level1Stream);
-  void setScale(double w, double h, double leftMarginA, double bottomMarginA,
-    int rotateA, int yoffsetA, int sliceHeightA);
-
-private:
-
-  SplashPattern *getColor(GfxGray gray, GfxRGB *rgb);
-  OPVPSplashPath *convertPath(GfxState *state, GfxPath *path);
-  void drawType3Glyph(T3FontCache *t3Font,
-		      T3FontCacheTag *tag, Guchar *data,
-		      double x, double y);
-  void patternFillChar(GfxState *state,
-    double x, double y, CharCode code);
-
-  static bool imageMaskSrc(void *data, SplashColorPtr line);
-  static bool imageSrc(void *data, SplashColorPtr line,
-                              Guchar *alphaLine);
-  static bool alphaImageSrc(void *data, SplashColorPtr line,
-                              Guchar *alphaLine);
-  static bool maskedImageSrc(void *data, SplashColorPtr line,
-                              Guchar *alphaLine);
-
-  OPVPSplashPath *bitmapToPath(SplashBitmap *bitmapA, int width, int height);
-  void closeAllSubPath(OPVPSplashPath *path);
-  void patternFillImageMask(GfxState *state,
-    SplashImageMaskSource src, void *srcData, int w, int h, SplashCoord *mat);
-  void doUpdateFont(GfxState *state);
-  void transLineDash(GfxState *state, SplashCoord **adash,
-    int *adashLength, SplashCoord *aphase);
-  void updateSplashLineDash(GfxState *state, Splash *splash);
-
-  SplashColorMode colorMode;
-  bool reverseVideo;		// reverse video mode
-  SplashColor paperColor;	// paper color
-
-  XRef *xref;			// xref table for current document
-
-  SplashBitmap *bitmap;
-  OPRS *oprs;
-  SplashFontEngine *fontEngine;
-
-  T3FontCache *			// Type 3 font cache
-    t3FontCache[splashOutT3FontCacheSize];
-  int nT3Fonts;			// number of valid entries in t3FontCache
-  T3GlyphStack *t3GlyphStack;	// Type 3 glyph context stack
-
-  SplashFont *font;		// current font
-  bool needFontUpdate;		// set when the font needs to be updated
-  OPVPSplashPath *textClipPath;	// clipping path built with text object
-
-  void (*underlayCbk)(void *data);
-  void *underlayCbkData;
-  double fontMat[4];
-  double scaleWidth, scaleHeight;
-  int paperWidth, paperHeight;
-  double leftMargin, bottomMargin;
-  int rotate;
-  int yoffset;
-  int sliceHeight;
-};
-
-#endif
diff --git a/filter/pdftoopvp/oprs/OPRS.cxx b/filter/pdftoopvp/oprs/OPRS.cxx
deleted file mode 100644
index 21cabc0..0000000
--- a/filter/pdftoopvp/oprs/OPRS.cxx
+++ /dev/null
@@ -1,604 +0,0 @@
-//========================================================================
-//
-// OPRS.cc
-//
-//========================================================================
-
-#include <config.h>
-#ifdef HAVE_CPP_POPPLER_VERSION_H
-#include "cpp/poppler-version.h"
-#endif
-
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
-#include <stdlib.h>
-#include <string.h>
-#include <string.h>
-#include <dlfcn.h>
-#include <stdarg.h>
-#include <math.h>
-#if defined __OpenBSD__
-#include <sys/endian.h>
-#if BYTE_ORDER == BIG_ENDIAN
-#define __BYTE_ORDER __BIG_ENDIAN
-#else
-#define __BYTE_ORDER __LITTLE_ENDIAN
-#endif
-#endif
-
-#include "goo/gmem.h"
-#include "splash/SplashErrorCodes.h"
-#include "splash/SplashMath.h"
-#include "splash/SplashBitmap.h"
-#include "splash/SplashState.h"
-#include "splash/SplashXPathScanner.h"
-#include "splash/SplashPattern.h"
-#include "splash/SplashScreen.h"
-#include "splash/SplashFont.h"
-#include "splash/SplashGlyphBitmap.h"
-#include "splash/Splash.h"
-#include "OPVPSplash.h"
-#include "OPVPSplashClip.h"
-#include "OPVPSplashPath.h"
-#include "OPVPSplashXPath.h"
-#include "OPRS.h"
-
-//------------------------------------------------------------------------
-// Splash
-//------------------------------------------------------------------------
-
-#define SPLASH(x) (rasterMode ? (splash->x) : (opvpSplash->x))
-
-OPRS::OPRS() 
-{
-  opvp = 0;
-  splash = 0;
-  opvpSplash = 0;
-  rasterMode = false;
-}
-
-int OPRS::setBitmap(SplashBitmap *bitmapA) {
-  if (splash != 0) {
-    delete splash;
-  }
-  splash = new Splash(bitmapA, false);
-  rasterMode = true;
-  return 0;
-}
-
-OPRS::~OPRS() {
-  if (splash != 0) {
-    delete splash;
-    splash = 0;
-  }
-  if (opvpSplash != 0) {
-    opvpSplash->restoreAllDriverState();
-    delete opvpSplash;
-    opvpSplash = 0;
-  }
-}
-
-//------------------------------------------------------------------------
-// state read
-//------------------------------------------------------------------------
-
-
-SplashPattern *OPRS::getStrokePattern() {
-  return SPLASH(getStrokePattern());
-}
-
-SplashPattern *OPRS::getFillPattern() {
-  return SPLASH(getFillPattern());
-}
-
-SplashScreen *OPRS::getScreen() {
-  return SPLASH(getScreen());
-}
-
-SplashCoord OPRS::getLineWidth() {
-  return SPLASH(getLineWidth());
-}
-
-int OPRS::getLineCap() {
-  return SPLASH(getLineCap());
-}
-
-int OPRS::getLineJoin() {
-  return SPLASH(getLineJoin());
-}
-
-SplashCoord OPRS::getMiterLimit() {
-  return SPLASH(getMiterLimit());
-}
-
-SplashCoord OPRS::getFlatness() {
-  return 1;
-}
-
-SplashCoord *OPRS::getLineDash() {
-  return SPLASH(getLineDash());
-}
-
-int OPRS::getLineDashLength() {
-  return SPLASH(getLineDashLength());
-}
-
-SplashCoord OPRS::getLineDashPhase() {
-  return SPLASH(getLineDashPhase());
-}
-
-OPVPSplashClip *OPRS::getClip() {
-  if (rasterMode) {
-    SplashClip *sclip = splash->getClip();
-    OPVPSplashClip *r = new OPVPSplashClip(sclip);
-    delete sclip;
-    return r;
-  } else {
-    return opvpSplash->getClip();
-  }
-}
-
-//------------------------------------------------------------------------
-// state write
-//------------------------------------------------------------------------
-
-void OPRS::setStrokePattern(SplashPattern *strokePattern) {
-    SPLASH(setStrokePattern(strokePattern));
-}
-
-void OPRS::setFillPattern(SplashPattern *fillPattern) {
-    SPLASH(setFillPattern(fillPattern));
-}
-
-void OPRS::setScreen(SplashScreen *screen) {
-    SPLASH(setScreen(screen));
-}
-
-void OPRS::setLineWidth(SplashCoord lineWidth) {
-    SPLASH(setLineWidth(lineWidth));
-}
-
-void OPRS::setMiterLimit(SplashCoord miterLimit) {
-    SPLASH(setMiterLimit(miterLimit));
-}
-
-void OPRS::setLineCap(int lineCap) {
-    SPLASH(setLineCap(lineCap));
-}
-
-void OPRS::setLineJoin(int lineJoin) {
-    SPLASH(setLineJoin(lineJoin));
-}
-
-void OPRS::setFlatness(SplashCoord flatness) {
-/* ignore flatness */
-}
-
-void OPRS::setLineDash(SplashCoord *lineDash, int lineDashLength,
-			 SplashCoord lineDashPhase) {
-    SPLASH(setLineDash(lineDash,lineDashLength,lineDashPhase));
-}
-
-SplashError OPRS::clipToPath(OPVPSplashPath *path, bool eo) {
-    return SPLASH(clipToPath(path,eo));
-}
-
-//------------------------------------------------------------------------
-// state save/restore
-//------------------------------------------------------------------------
-
-void OPRS::saveState() {
-    SPLASH(saveState());
-}
-
-SplashError OPRS::restoreState() {
-    SPLASH(restoreState());
-    return splashOk;
-}
-
-//------------------------------------------------------------------------
-// drawing operations
-//------------------------------------------------------------------------
-
-void OPRS::clear(SplashColor color) {
-    SPLASH(clear(color));
-}
-
-SplashError OPRS::stroke(OPVPSplashPath *path) {
-    return SPLASH(stroke(path));
-}
-
-SplashError OPRS::fill(OPVPSplashPath *path, bool eo) {
-    return SPLASH(fill(path,eo));
-}
-
-SplashError OPRS::fillChar(SplashCoord x, SplashCoord y,
-			     int c, SplashFont *font, Unicode *u, 
-			     double *fontMat) {
-    if (rasterMode) {
-	return splash->fillChar(x,y,c,font);
-    } else {
-	return opvpSplash->fillChar(x,y,c,font,u,fontMat);
-    }
-}
-
-SplashError OPRS::fillGlyph(SplashCoord x, SplashCoord y,
-			      SplashGlyphBitmap *glyph) {
-    SPLASH(fillGlyph(x,y,glyph));
-    return splashOk;
-}
-
-SplashError OPRS::fillImageMask(SplashImageMaskSource src, void *srcData,
-			  int w, int h, SplashCoord *mat, bool glyphMode) {
-    return SPLASH(fillImageMask(src,srcData,w,h,mat,glyphMode));
-}
-
-SplashError OPRS::drawImage(SplashImageSource src, void *srcData,
-			      SplashColorMode srcMode, bool srcAlpha,
-			      int w, int h, SplashCoord *mat) {
-    if (rasterMode) {
-#if POPPLER_VERSION_MAJOR <= 0 && (POPPLER_VERSION_MINOR <= 20 || (POPPLER_VERSION_MINOR == 21 && POPPLER_VERSION_MICRO <= 2))
-	return splash->drawImage(src,srcData,srcMode,srcAlpha,w,h,mat);
-#elif POPPLER_VERSION_MAJOR <= 0 && POPPLER_VERSION_MINOR <= 33
-	return splash->drawImage(src,srcData,srcMode,srcAlpha,w,h,mat,false);
-#else
-	return splash->drawImage(src,0,srcData,srcMode,srcAlpha,w,h,mat,false);
-#endif
-    } else {
-	return opvpSplash->drawImage(src,srcData,srcMode,srcAlpha,w,h,mat);
-    }
-}
-
-/*
- * initialize and load vector-driver
- */
-int OPRS::init(const char *driverName, int outputFD,
-  const char *printerModel, int nOptions,
-  const char *optionKeys[], const char *optionVals[])
-{
-    opvp = OPVPWrapper::loadDriver(driverName,outputFD,printerModel);
-    if (opvp == 0) return -1;
-    rasterMode = false;
-    if (!rasterMode) {
-	opvpSplash = new OPVPSplash(opvp,nOptions,
-	  optionKeys, optionVals);
-    }
-    return 0;
-}
-
-int OPRS::OPVPStartJob(char *jobInfo)
-{
-    if (!opvp->supportStartJob) {
-      return 0;
-    }
-    return opvp->StartJob((const opvp_char_t *)jobInfo);
-}
-
-int OPRS::OPVPEndJob()
-{
-    if (!opvp->supportEndJob) {
-      return 0;
-    }
-    return opvp->EndJob();
-}
-
-int OPRS::OPVPStartDoc(char *docInfo)
-{
-    if (!opvp->supportStartDoc) {
-      return 0;
-    }
-    return opvp->StartDoc((const opvp_char_t *)docInfo);
-}
-
-int OPRS::OPVPEndDoc()
-{
-    if (!opvp->supportEndDoc) {
-      return 0;
-    }
-    return opvp->EndDoc();
-}
-
-int OPRS::OPVPStartPage(char *pageInfo, int rasterWidth)
-{
-    int r;
-
-    if (opvp->supportStartPage) {
-	if ((r = opvp->StartPage((const opvp_char_t *)pageInfo)) < 0) {
-	  return r;
-	}
-    }
-    if (rasterMode) {
-	if (!opvp->supportStartRaster) {
-	    error("No StartRaster error in raster mode\n");
-	    return -1;
-	}
-	if (opvp->supportSetCurrentPoint) {
-	    opvp_fix_t x,y;
-
-	    OPVP_F2FIX(0.0,x);
-	    OPVP_F2FIX(0.0,y);
-	    opvp->SetCurrentPoint(x,y);
-	}
-	opvp->StartRaster(rasterWidth);
-    }
-    return 0;
-}
-
-int OPRS::OPVPEndPage()
-{
-    int r;
-
-    if (rasterMode) {
-	if (!opvp->supportEndRaster) {
-	    error("No EndRaster error in raster mode\n");
-	    return -1;
-	}
-	opvp->EndRaster();
-    }
-    if (opvp->supportEndPage) {
-	if ((r = opvp->EndPage()) < 0) {
-	    return r;
-	}
-    }
-    return splashOk;
-}
-
-unsigned char *OPRS::getScanLineDataMono1(unsigned char *dst,
-  unsigned char *bitmap, int rasterWidth)
-{
-    int n = (rasterWidth+7)/8;
-
-    memcpy(dst,bitmap,n);
-    return bitmap+n;
-}
-
-unsigned char *OPRS::getScanLineDataMono8(unsigned char *dst,
-  unsigned char *bitmap, int rasterWidth)
-{
-    memcpy(dst,bitmap,rasterWidth);
-    return bitmap+rasterWidth;
-}
-
-unsigned char *OPRS::getScanLineDataRGB8(unsigned char *dst,
-  unsigned char *bitmap, int rasterWidth)
-{
-    int i;
-
-    for (i = 0;i < rasterWidth;i++) {
-#if defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN
-	bitmap++;
-	*dst++ = *bitmap++;
-	*dst++ = *bitmap++;
-	*dst++ = *bitmap++;
-#else
-	dst[2] = *bitmap++;
-	dst[1] = *bitmap++;
-	dst[0] = *bitmap++;
-	bitmap++;
-	dst += 3;
-#endif
-    }
-    return bitmap;
-}
-
-unsigned char *OPRS::getScanLineDataBGR8Packed(unsigned char *dst,
-   unsigned char *bitmap, int rasterWidth)
-{
-    memcpy(dst,bitmap,rasterWidth*3);
-    return bitmap+rasterWidth*3;
-}
-
-OPRS::GetScanLineDataFunT OPRS::getGetScanLineDataFun(SplashBitmap *bitmap)
-{
-    switch (bitmap->getMode()) {
-    case splashModeMono1:
-	return getScanLineDataMono1;
-    case splashModeMono8:
-	return getScanLineDataMono8;
-    case splashModeRGB8:
-	return getScanLineDataRGB8;
-    default:
-	OPRS::error("Unknown bitmap mode\n");
-	break;
-    }
-    return getScanLineDataMono8;
-}
-
-int OPRS::getRasterSize(SplashBitmap *bitmap)
-{
-    int rw = bitmap->getWidth();
-
-    switch (bitmap->getMode()) {
-    case splashModeMono1:
-	return (rw+7)/8;
-    case splashModeMono8:
-	return rw;
-    case splashModeRGB8:
-        return rw*3;
-    default:
-	OPRS::error("Unknown bitmap mode\n");
-	break;
-    }
-    return 0;
-}
-
-bool OPRS::checkAll1(unsigned char *bp, int n, int width, int mode)
-{
-    int lastbytemask = 0xff;
-    int i;
-
-    if (mode == splashModeMono1) {
-	lastbytemask <<= (width & 0x7);
-	lastbytemask &= 0xff;
-    }
-    for (i = 0;i < n-1;i++) {
-	if (*bp++ != 0xff) return false;
-    }
-    return (*bp & lastbytemask) == lastbytemask;
-}
-
-int OPRS::outSlice()
-{
-    if (rasterMode) {
-	/* out bitmap */
-	int rasterWidth;
-	int nScanLines;
-	int rasterSize;
-	unsigned char *p;
-	int i;
-	SplashBitmap *bitmap;
-	SplashColorPtr cp;
-	unsigned char *bp;
-	GetScanLineDataFunT fun;
-	int mode;
-
-	if (!opvp->supportStartRaster || !opvp->supportTransferRasterData
-	   || !opvp->supportEndRaster) {
-	  OPRS::error("No raster supporting printer driver\n");
-	  return -1;
-	}
-
-	bitmap = splash->getBitmap();
-	rasterWidth = bitmap->getWidth();
-	nScanLines = bitmap->getHeight();
-	rasterSize = getRasterSize(bitmap);
-	if ((bp = new unsigned char[rasterSize]) == 0) {
-	    OPRS::error("Not enough memory\n");
-	    return -1;
-	}
-	cp = (bitmap->getDataPtr());
-	p = reinterpret_cast<unsigned char *>(cp);
-	fun = getGetScanLineDataFun(bitmap);
-	mode = bitmap->getMode();
-	for (i = 0;i < nScanLines;i++) {
-	    p = (*fun)(bp,p,rasterWidth);
-	    if (opvp->supportSkipRaster
-	        && checkAll1(bp,rasterSize,rasterWidth,mode)) {
-	      /* all white, skip raster */
-		opvp->SkipRaster(1);
-	    } else {
-		opvp->TransferRasterData(rasterSize,bp);
-	    }
-	}
-	delete[] bp;
-    }
-    return 0;
-}
-
-int OPRS::setColorMode(int colorModeA, bool colorProfile)
-{
-    opvp_cspace_t cspace = OPVP_CSPACE_STANDARDRGB;
-
-    if (opvp->supportGetColorSpace) opvp->GetColorSpace(&cspace);
-    switch (cspace){
-    case OPVP_CSPACE_BW:
-	if (colorModeA != splashModeMono1) {
-	  OPRS::error("not mono mode is specified on a monochrome printer\n");
-	  return -1;
-	}
-	break;
-    case OPVP_CSPACE_DEVICEGRAY:
-	if (colorModeA != splashModeMono1 && colorModeA != splashModeMono8) {
-	    OPRS::error("colorMode is specified on not a color printer\n");
-	    return -1;
-	}
-	break;
-    case OPVP_CSPACE_DEVICERGB:
-	if (colorProfile) break;
-    default:
-	/* rgb color */
-	if (colorProfile) {
-	    /* try set colorspace to DEVICERGB */
-	    if (opvp->supportSetColorSpace) opvp->SetColorSpace(
-	       OPVP_CSPACE_DEVICERGB);
-	    if (opvp->supportGetColorSpace) opvp->GetColorSpace(&cspace);
-	    if (cspace == OPVP_CSPACE_DEVICERGB) break;
-	    /* fail to set,  fall through */
-	}
-	if (opvp->supportSetColorSpace) opvp->SetColorSpace(
-	   OPVP_CSPACE_STANDARDRGB);
-	break;
-    }
-    if (!rasterMode) {
-	opvpSplash->setColorMode(colorModeA);
-    }
-    return 0;
-}
-
-SplashBitmap *OPRS::getBitmap()
-{
-    return SPLASH(getBitmap());
-}
-
-void OPRS::setDebugMode(bool debugModeA)
-{
-    SPLASH(setDebugMode(debugModeA));
-}
-
-void OPRS::initGS(int colorMode, int w, int h, SplashColor paperColor)
-{
-  SplashColor color;
-
-  if (!rasterMode && opvp->supportInitGS) {
-    opvp->InitGS();
-  }
-  if (opvp->supportSetPaintMode) {
-      opvp->SetPaintMode(OPVP_PAINTMODE_TRANSPARENT);
-  }
-  switch (colorMode) {
-  case splashModeMono1: color[0] = 0; break;
-  case splashModeMono8: color[0] = 0; break;
-  case splashModeRGB8: color[0] = color[1] = color[2] = 0; break;
-  }
-  if (!rasterMode) {
-    opvpSplash->setStateBypass(true);
-  }
-  SPLASH(setStrokePattern(new SplashSolidColor(color)));
-  SPLASH(setFillPattern(new SplashSolidColor(color)));
-  SPLASH(setLineCap(splashLineCapButt));
-  SPLASH(setLineJoin(splashLineJoinMiter));
-  SPLASH(setLineDash(0, 0, 0));
-  SPLASH(setLineWidth(0));
-  SPLASH(setMiterLimit(10));
-  SPLASH(setFlatness(1));
-  SPLASH(clipResetToRect(0,0,w-1,h-1));
-  SPLASH(clear(paperColor));
-  if (!rasterMode) {
-    opvpSplash->setStateBypass(false);
-  }
-}
-
-void OPRS::error(const char *msg, ...)
-{
-    va_list args;
-
-    fprintf(stderr,"ERROR:OPRS:");
-    va_start(args, msg);
-    vfprintf(stderr, msg, args);
-    va_end(args);
-    fflush(stderr);
-}
-
-void OPRS::endPage()
-{
-    /* restore state */
-    while (SPLASH(restoreState()) == splashOk);
-    if (!rasterMode) {
-	opvpSplash->endPage();
-    }
-}
-
-void OPRS::setSoftMask(SplashBitmap *softMaskA)
-{
-    /* Soft Mask is not supported in vector mode. */
-    if (rasterMode) {
-	splash->setSoftMask(softMaskA);
-    }
-}
-
-SplashCoord *OPRS::getMatrix()
-{
-    return SPLASH(getMatrix());
-}
diff --git a/filter/pdftoopvp/oprs/OPRS.h b/filter/pdftoopvp/oprs/OPRS.h
deleted file mode 100644
index e47804c..0000000
--- a/filter/pdftoopvp/oprs/OPRS.h
+++ /dev/null
@@ -1,188 +0,0 @@
-//========================================================================
-//
-// OPRS.h
-//
-//========================================================================
-
-#ifndef OPRS_H
-#define OPRS_H
-
-#include <config.h>
-
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
-#include "splash/SplashTypes.h"
-#include "opvp_common.h"
-#include "splash/Splash.h"
-#include "OPVPSplash.h"
-#include "OPVPWrapper.h"
-
-#define OPVP_BUFF_SIZE 256
-
-class SplashBitmap;
-class SplashGlyphBitmap;
-class SplashState;
-class SplashPattern;
-class SplashScreen;
-class OPVPSplashPath;
-class SplashXPath;
-class OPVPSplashClip;
-class SplashFont;
-
-//------------------------------------------------------------------------
-// OPRS
-//------------------------------------------------------------------------
-
-class OPRS {
-public:
-
-  static void error(const char *msg, ...);
-  OPRS();
-  ~OPRS();
-
-  int setBitmap(SplashBitmap *bitmapA);
-
-  //----- state read
-
-  SplashPattern *getStrokePattern();
-  SplashPattern *getFillPattern();
-  SplashScreen *getScreen();
-  SplashCoord getLineWidth();
-  int getLineCap();
-  int getLineJoin();
-  SplashCoord getMiterLimit();
-  SplashCoord getFlatness();
-  SplashCoord *getLineDash();
-  int getLineDashLength();
-  SplashCoord getLineDashPhase();
-  OPVPSplashClip *getClip();
-
-  //----- state write
-
-  void setStrokePattern(SplashPattern *strokeColor);
-  void setFillPattern(SplashPattern *fillColor);
-  void setScreen(SplashScreen *screen);
-  void setLineWidth(SplashCoord lineWidth);
-  void setMiterLimit(SplashCoord miterLimit);
-  void setLineCap(int lineCap);
-  void setLineJoin(int lineJoin);
-  void setFlatness(SplashCoord flatness);
-  // the <lineDash> array will be copied
-  void setLineDash(SplashCoord *lineDash, int lineDashLength,
-		   SplashCoord lineDashPhase);
-  SplashError clipToPath(OPVPSplashPath *path, bool eo);
-
-  //----- state save/restore
-
-  void saveState();
-  SplashError restoreState();
-
-  void setSoftMask(SplashBitmap *softMaskA);
-
-  //----- drawing operations
-
-  // Fill the bitmap with <color>.  This is not subject to clipping.
-  void clear(SplashColor color);
-
-  // Stroke a path using the current stroke pattern.
-  SplashError stroke(OPVPSplashPath *path);
-
-  // Fill a path using the current fill pattern.
-  SplashError fill(OPVPSplashPath *path, bool eo);
-
-  // Draw a character, using the current fill pattern.
-  SplashError fillChar(SplashCoord x, SplashCoord y, int c, SplashFont *font,
-    Unicode *u, double *fontMat);
-
-  // Draw a glyph, using the current fill pattern.  This function does
-  // not free any data, i.e., it ignores glyph->freeData.
-  SplashError fillGlyph(SplashCoord x, SplashCoord y,
-			SplashGlyphBitmap *glyph);
-
-  // Draws an image mask using the fill color.  This will read <w>*<h>
-  // pixels from <src>, in raster order, starting with the top line.
-  // "1" pixels will be drawn with the current fill color; "0" pixels
-  // are transparent.  The matrix:
-  //    [ mat[0] mat[1] 0 ]
-  //    [ mat[2] mat[3] 0 ]
-  //    [ mat[4] mat[5] 1 ]
-  // maps a unit square to the desired destination for the image, in
-  // PostScript style:
-  //    [x' y' 1] = [x y 1] * mat
-  // Note that the Splash y axis points downward, and the image source
-  // is assumed to produce pixels in raster order, starting from the
-  // top line.
-  SplashError fillImageMask(SplashImageMaskSource src, void *srcData,
-			    int w, int h, SplashCoord *mat, bool glyphMode);
-
-  // Draw an image.  This will read <w>*<h> pixels from <src>, in
-  // raster order, starting with the top line.  These pixels are
-  // assumed to be in the source mode, <srcMode>.  The following
-  // combinations of source and target modes are supported:
-  //    source       target
-  //    ------       ------
-  //    Mono1        Mono1
-  //    Mono8        Mono1   -- with dithering
-  //    Mono8        Mono8
-  //    RGB8         RGB8
-  //    BGR8packed   BGR8Packed
-  // The matrix behaves as for fillImageMask.
-  SplashError drawImage(SplashImageSource src, void *srcData,
-			SplashColorMode srcMode, bool srcAlpha,
-			int w, int h, SplashCoord *mat);
-
-  //~ drawMaskedImage
-
-  //----- misc
-
-  // Return the associated bitmap.
-  SplashBitmap *getBitmap();
-
-  // Toggle debug mode on or off.
-  void setDebugMode(bool debugModeA);
-
-  int init(const char *driverName, int outputFD,
-      const char *printerModel, int nOptions,
-      const char *optionKeys[], const char *optionVals[]);
-  void initGS(int colorMode, int w, int h, SplashColor paperColor);
-  int setColorMode(int colorModeA, bool colorProfile);
-  int unloadVectorDriver();
-
-  int OPVPStartJob(char *jobInfo);
-  int OPVPEndJob();
-  int OPVPStartDoc(char *docInfo);
-  int OPVPEndDoc();
-  int OPVPStartPage(char *pageInfo, int rasterWidth);
-  int OPVPEndPage();
-  int outSlice();
-  Splash *getSplash() { return splash; }
-  int getRasterMode() { return rasterMode; }
-  void endPage();
-  SplashCoord *getMatrix();
-
-private:
-  int rasterMode;
-  OPVPSplash *opvpSplash;
-  Splash *splash;
-  OPVPWrapper *opvp;
-  int getRasterSize(SplashBitmap *bitmap);
-
-  typedef unsigned char *(*GetScanLineDataFunT)(unsigned char *dst,
-    unsigned char *bitmap, int rasterWidth);
-
-  static unsigned char *getScanLineDataMono1(unsigned char *dst,
-    unsigned char *bitmap, int rasterWidth);
-  static unsigned char *getScanLineDataMono8(unsigned char *dst,
-    unsigned char *bitmap, int rasterWidth);
-  static unsigned char *getScanLineDataRGB8(unsigned char *dst,
-    unsigned char *bitmap, int rasterWidth);
-  static unsigned char *getScanLineDataBGR8Packed(unsigned char *dst,
-    unsigned char *bitmap, int rasterWidth);
-
-  GetScanLineDataFunT getGetScanLineDataFun(SplashBitmap *bitmap);
-  bool checkAll1(unsigned char *bp, int n, int width, int mode);
-};
-
-#endif
diff --git a/filter/pdftoopvp/oprs/OPVPSplash.cxx b/filter/pdftoopvp/oprs/OPVPSplash.cxx
deleted file mode 100644
index 89b7d33..0000000
--- a/filter/pdftoopvp/oprs/OPVPSplash.cxx
+++ /dev/null
@@ -1,2293 +0,0 @@
-//========================================================================
-//
-// OPVPSplash.cc
-//
-//========================================================================
-
-#include <config.h>
-#ifdef HAVE_CPP_POPPLER_VERSION_H
-#include "cpp/poppler-version.h"
-#endif
-
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-#include <limits.h>
-#include "goo/gmem.h"
-#include "splash/SplashErrorCodes.h"
-#include "splash/SplashMath.h"
-#include "splash/SplashBitmap.h"
-#include "splash/SplashXPathScanner.h"
-#include "splash/SplashPattern.h"
-#include "splash/SplashScreen.h"
-#include "splash/SplashFont.h"
-#include "splash/SplashGlyphBitmap.h"
-#include "splash/Splash.h"
-#include "OPRS.h"
-#include "OPVPSplashState.h"
-#include "OPVPSplash.h"
-#include "OPVPSplashPath.h"
-#include "OPVPSplashXPath.h"
-#include "OPVPSplashClip.h"
-
-//------------------------------------------------------------------------
-// OPVPSplash
-//------------------------------------------------------------------------
-
-inline void OPVPSplash::transform(SplashCoord *matrix,
-                              SplashCoord xi, SplashCoord yi,
-                              SplashCoord *xo, SplashCoord *yo) {
-  //                          [ m[0] m[1] 0 ]
-  // [xo yo 1] = [xi yi 1] *  [ m[2] m[3] 0 ]
-  //                          [ m[4] m[5] 1 ]
-  *xo = xi * matrix[0] + yi * matrix[2] + matrix[4];
-  *yo = xi * matrix[1] + yi * matrix[3] + matrix[5];
-}
-
-OPVPSplash::OPVPSplash(OPVPWrapper *opvpA,
-  int nOptions, const char *optionKeys[], const char *optionVals[])
-{
-  const char *opv;
-
-  opvp = opvpA;
-  // with default screen params
-  state = new OPVPSplashState(0,0,false,(SplashScreenParams *)NULL);
-  debugMode = false;
-  stateBypass = false;
-  clipPath = 0;
-  if (getOption("OPVP_OLDLIPSDRIVER",nOptions,
-     optionKeys,optionVals) != NULL) {
-    oldLipsDriver = true;
-  } else {
-    oldLipsDriver = false;
-  }
-  if (getOption("OPVP_CLIPPATHNOTSAVED",nOptions,
-     optionKeys,optionVals) != NULL) {
-    clipPathNotSaved = true;
-  } else {
-    clipPathNotSaved = false;
-  }
-  if (getOption("OPVP_NOSHEARIMAGE",nOptions,
-     optionKeys,optionVals) != NULL) {
-    noShearImage = true;
-  } else {
-    noShearImage = false;
-  }
-  if (getOption("OPVP_NOLINESTYLE",nOptions,
-     optionKeys,optionVals) != NULL) {
-    noLineStyle = true;
-  } else {
-    noLineStyle = false;
-  }
-  if (!opvpA->supportSetLineStyle || !opvpA->supportSetLineDash
-     || !opvpA->supportSetLineDashOffset) {
-    noLineStyle = true;
-  }
-  if (getOption("OPVP_NOCLIPPATH",nOptions,
-     optionKeys,optionVals) != NULL) {
-    noClipPath = true;
-  } else {
-    noClipPath = false;
-  }
-  if (getOption("OPVP_IGNOREMITERLIMIT",nOptions,
-     optionKeys,optionVals) != NULL) {
-    ignoreMiterLimit = true;
-  } else {
-    ignoreMiterLimit = false;
-  }
-  if (getOption("OPVP_NOMITERLIMIT",nOptions,
-     optionKeys,optionVals) != NULL) {
-    noMiterLimit = true;
-  } else {
-    noMiterLimit = false;
-  }
-  if (!opvpA->supportSetMiterLimit) {
-    noMiterLimit = true;
-  }
-  if ((opv = getOption("OPVP_BITMAPCHARTHRESHOLD",nOptions,
-     optionKeys,optionVals)) != NULL) {
-    bitmapCharThreshold = atoi(opv);
-  } else {
-    bitmapCharThreshold = OPVP_BITMAPCHAR_THRESHOLD;
-  }
-  if ((opv = getOption("OPVP_MAXCLIPPATHLENGTH",nOptions,
-     optionKeys,optionVals)) != NULL) {
-    maxClipPathLength = atoi(opv);
-  } else {
-    maxClipPathLength = OPVP_MAX_CLIPPATH_LENGTH;
-  }
-  if ((opv = getOption("OPVP_MAXFILLPATHLENGTH",nOptions,
-     optionKeys,optionVals)) != NULL) {
-    maxFillPathLength = atoi(opv);
-  } else {
-    maxFillPathLength = OPVP_MAX_FILLPATH_LENGTH;
-  }
-  if (getOption("OPVP_NOIMAGEMASK",nOptions,
-     optionKeys,optionVals) != NULL) {
-    noImageMask = true;
-  } else {
-    noImageMask = false;
-  }
-  if (getOption("OPVP_NOBITMAPCHAR",nOptions,
-     optionKeys,optionVals) != NULL) {
-    bitmapCharThreshold = 0;
-  }
-  if (!opvpA->supportSetClipPath) {
-    noClipPath = true;
-  }
-  savedNoClipPath = noClipPath;
-  saveDriverStateCount = 0;
-  if (noImageMask) {
-    /* We draw bitmapChar with imageMask feature.
-      So, when noImageMask, noBitmapChar */
-    bitmapCharThreshold = 0;
-  }
-#ifdef OPTION_DEBUG
-fprintf(stderr,"noClipPath=%d\n",noClipPath);
-fprintf(stderr,"oldLipsDriver=%d\n",oldLipsDriver);
-fprintf(stderr,"noLineStyle=%d\n",noLineStyle);
-fprintf(stderr,"noMiterLimit=%d\n",noMiterLimit);
-fprintf(stderr,"ignoreMiterLimit=%d\n",ignoreMiterLimit);
-fprintf(stderr,"noShearImage=%d\n",noShearImage);
-fprintf(stderr,"clipPathNotSaved=%d\n",clipPathNotSaved);
-fprintf(stderr,"bitmapCharThreshold=%d\n",bitmapCharThreshold);
-fprintf(stderr,"maxClipPathLength=%d\n",maxClipPathLength);
-#endif
-}
-
-OPVPSplash::~OPVPSplash()
-{
-  while (state->next) {
-    restoreState();
-  }
-  delete state;
-  if (opvp->supportClosePrinter) {
-    opvp->ClosePrinter();
-  }
-  delete opvp;
-}
-
-//------------------------------------------------------------------------
-// state read
-//------------------------------------------------------------------------
-
-
-SplashPattern *OPVPSplash::getStrokePattern() {
-  return state->strokePattern;
-}
-
-SplashPattern *OPVPSplash::getFillPattern() {
-  return state->fillPattern;
-}
-
-SplashScreen *OPVPSplash::getScreen() {
-  return state->screen;
-}
-
-SplashCoord OPVPSplash::getLineWidth() {
-  return state->lineWidth;
-}
-
-int OPVPSplash::getLineCap() {
-  return state->lineCap;
-}
-
-int OPVPSplash::getLineJoin() {
-  return state->lineJoin;
-}
-
-SplashCoord OPVPSplash::getMiterLimit() {
-  return state->miterLimit;
-}
-
-SplashCoord OPVPSplash::getFlatness() {
-  return state->flatness;
-}
-
-SplashCoord *OPVPSplash::getLineDash() {
-  return state->lineDash;
-}
-
-int OPVPSplash::getLineDashLength() {
-  return state->lineDashLength;
-}
-
-SplashCoord OPVPSplash::getLineDashPhase() {
-  return state->lineDashPhase;
-}
-
-OPVPSplashClip *OPVPSplash::getClip() {
-  return state->clip;
-}
-
-//------------------------------------------------------------------------
-// state write
-//------------------------------------------------------------------------
-
-opvp_cspace_t OPVPSplash::getOPVPColorSpace()
-{
-  switch (colorMode) {
-  case splashModeMono1:
-    return OPVP_CSPACE_BW;
-    break;
-  case splashModeMono8:
-    return OPVP_CSPACE_DEVICEGRAY;
-    break;
-  case splashModeRGB8:
-  default:
-    break;
-  }
-  return OPVP_CSPACE_STANDARDRGB;
-}
-
-void OPVPSplash::makeBrush(SplashPattern *pattern, opvp_brush_t *brush)
-{
-  brush->colorSpace = getOPVPColorSpace();
-  brush->pbrush = NULL;
-  brush->color[3] = -1;
-  brush->xorg = brush->yorg = 0;
-  if (pattern == NULL) {
-    /* set default black color */
-    brush->color[2] = 0;
-    brush->color[1] = 0;
-    brush->color[0] = 0;
-  } else if (typeid(*pattern) == typeid(SplashSolidColor)) {
-    /* solid color */
-    SplashColor color;
-
-    pattern->getColor(0,0,color);
-    switch (colorMode) {
-    case splashModeMono1:
-      brush->color[2] = color[0];
-      brush->color[1] = 0;
-      brush->color[0] = 0;
-      break;
-    case splashModeMono8:
-      brush->color[2] = color[0];
-      brush->color[1] = 0;
-      brush->color[0] = 0;
-      break;
-    case splashModeRGB8:
-      brush->color[2] = splashRGB8R(color);
-      brush->color[1] = splashRGB8G(color);
-      brush->color[0] = splashRGB8B(color);
-      break;
-    default:
-      OPRS::error("Unknown color mode\n");
-      brush->color[2] = splashRGB8R(color);
-      brush->color[1] = splashRGB8G(color);
-      brush->color[0] = splashRGB8B(color);
-      break;
-    }
-  } else {
-    /* error */
-    return;
-  }
-}
-
-bool OPVPSplash::equalPattern(SplashPattern *pat1, SplashPattern *pat2)
-{
-  SplashColor c1, c2;
-  if (pat1 == NULL || pat2 == NULL) {
-    return pat1 == pat2;
-  }
-  if (typeid(*pat1) != typeid(*pat2)) return false;
-
-  pat1->getColor(0,0,c1);
-  pat2->getColor(0,0,c2);
-  switch (colorMode) {
-  case splashModeMono1:
-    return c1[0] == c2[0];
-    break;
-  case splashModeMono8:
-    return c1[0] == c2[0];
-    break;
-  case splashModeRGB8:
-    return c1[0] == c2[0] && c1[1] == c2[1] && c1[2] == c2[2];
-    break;
-  default:
-    break;
-  }
-  return true;
-}
-
-void OPVPSplash::setStrokePattern(SplashPattern *strokePattern) {
-  opvp_brush_t brush;
-
-  if (!stateBypass && equalPattern(strokePattern,state->strokePattern)) {
-    delete strokePattern;
-    return;
-  }
-  state->setStrokePattern(strokePattern);
-  makeBrush(strokePattern,&brush);
-  if (opvp->SetStrokeColor(&brush) != 0) {
-    OPRS::error("SetStrokeColor error\n");
-    return;
-  }
-}
-
-void OPVPSplash::setFillPattern(SplashPattern *fillPattern) {
-  opvp_brush_t brush;
-
-  if (!stateBypass && equalPattern(fillPattern,state->fillPattern)) {
-    delete fillPattern;
-    return;
-  }
-  state->setFillPattern(fillPattern);
-  makeBrush(fillPattern,&brush);
-  if (opvp->SetFillColor(&brush) != 0) {
-    OPRS::error("SetFillColor error\n");
-    return;
-  }
-}
-
-void OPVPSplash::setScreen(SplashScreen *screen) {
-  state->setScreen(screen);
-}
-
-void OPVPSplash::setLineWidth(SplashCoord lineWidth) {
-  if (stateBypass || state->lineWidth != lineWidth) {
-      opvp_fix_t width;
-
-      state->lineWidth = lineWidth;
-      OPVP_F2FIX(lineWidth,width);
-      if (opvp->SetLineWidth(width) < 0) {
-	OPRS::error("SetLineWidth error\n");
-	return;
-      }
-  }
-}
-
-void OPVPSplash::setLineCap(int lineCap) {
-  if (stateBypass || state->lineCap != lineCap) {
-      opvp_linecap_t cap;
-
-      state->lineCap = lineCap;
-      switch (lineCap) {
-      case splashLineCapButt:
-	cap = OPVP_LINECAP_BUTT;
-	break;
-      case splashLineCapRound:
-	cap = OPVP_LINECAP_ROUND;
-	break;
-      case splashLineCapProjecting:
-	cap = OPVP_LINECAP_SQUARE;
-	break;
-      default:
-	/* error */
-	cap = OPVP_LINECAP_BUTT;
-	break;
-      }
-      if (opvp->SetLineCap(cap) < 0) {
-	OPRS::error("SetLineCap error\n");
-	return;
-      }
-  }
-}
-
-void OPVPSplash::setLineJoin(int lineJoin) {
-  if (stateBypass || state->lineJoin != lineJoin) {
-      opvp_linejoin_t join;
-
-      state->lineJoin = lineJoin;
-      switch (lineJoin) {
-      case splashLineJoinMiter:
-	join = OPVP_LINEJOIN_MITER;
-	break;
-      case splashLineJoinRound:
-	join = OPVP_LINEJOIN_ROUND;
-	break;
-      case splashLineJoinBevel:
-	join = OPVP_LINEJOIN_BEVEL;
-	break;
-      default:
-	/* error */
-	join = OPVP_LINEJOIN_MITER;
-	break;
-      }
-      if (opvp->SetLineJoin(join) < 0) {
-	OPRS::error("SetLineJoin error\n");
-	return;
-      }
-  }
-}
-
-void OPVPSplash::setMiterLimit(SplashCoord miterLimit) {
-  if (stateBypass || state->miterLimit != miterLimit) {
-      opvp_fix_t limit;
-
-      state->miterLimit = miterLimit;
-      if (noMiterLimit) return;
-      if (oldLipsDriver) {
-	/* for old driver for lips */
-	/* miterLimit is length/2 */
-	miterLimit = miterLimit*state->lineWidth*0.5;
-      }
-      OPVP_F2FIX(miterLimit,limit);
-      if (opvp->SetMiterLimit(limit) < 0) {
-	OPRS::error("SetMiterLimit error\n");
-	return;
-      }
-  }
-}
-
-void OPVPSplash::setFlatness(SplashCoord flatness) {
-  if (flatness < 1) {
-    state->flatness = 1;
-  } else {
-    state->flatness = flatness;
-  }
-}
-
-void OPVPSplash::setLineDash(SplashCoord *lineDash, int lineDashLength,
-			 SplashCoord lineDashPhase) {
-  int i;
-  opvp_fix_t *pdash;
-  bool equal;
-
-  if (stateBypass || lineDash != state->lineDash) {
-    if (lineDash == NULL || lineDashLength == 0) {
-      if (!noLineStyle
-        && opvp->SetLineStyle(OPVP_LINESTYLE_SOLID) < 0) {
-	OPRS::error("SetLineStyle error\n");
-	return;
-      }
-      state->setLineDash(lineDash, lineDashLength, lineDashPhase);
-      return;
-    } else if (stateBypass || state->lineDash == NULL) {
-      if (!noLineStyle
-        && opvp->SetLineStyle(OPVP_LINESTYLE_DASH) < 0) {
-	OPRS::error("SetLineStyle error\n");
-	return;
-      }
-    }
-  }
-  if (lineDash == NULL || lineDashLength == 0) return;
-  if (!noLineStyle) {
-    equal = (state->lineDash != NULL);
-    pdash = new opvp_fix_t[lineDashLength];
-    for (i = 0;i < lineDashLength;i++) {
-      if (equal && lineDash[i] != state->lineDash[i]) equal = false;
-      OPVP_F2FIX(lineDash[i],pdash[i]);
-    }
-    if (!equal && opvp->SetLineDash(lineDashLength,pdash) < 0) {
-      OPRS::error("SetLineDash error\n");
-      goto err;
-    }
-    if (stateBypass || lineDashPhase != state->lineDashPhase) {
-      opvp_fix_t offset;
-
-      OPVP_F2FIX(lineDashPhase,offset);
-      if (opvp->SetLineDashOffset(offset) < 0) {
-	OPRS::error("SetLineDashOffset error\n");
-	goto err;
-      }
-    }
-err:
-    delete[] pdash;
-  }
-  state->setLineDash(lineDash, lineDashLength, lineDashPhase);
-}
-
-SplashError OPVPSplash::doClipPath(OPVPSplashPath *path, bool eo,
-  OPVPClipPath *prevClip)
-{
-  SplashError result;
-
-  if (path->getLength() > maxClipPathLength) {
-    if (!noClipPath) {
-      if (prevClip != 0 &&
-          prevClip->getPath()->getLength() <= maxClipPathLength) {
-	/* previous clipping is printer clipping */
-	if (opvp->ResetClipPath() != 0) {
-	      OPRS::error("ResetClipPath error\n");
-	  return splashErrOPVP;
-	}
-      }
-      noClipPath = true;
-    }
-  } else {
-    noClipPath = savedNoClipPath;
-  }
-  if (!noClipPath && path->getLength() > 0) {
-    /* when path->length == 0, no drawable arae, and no output 
-       so, it isn't need to set ClipPath */
-    if ((result = path->makePath(opvp)) != splashOk) {
-      return result;
-    }
-    if (opvp->SetClipPath(
-	 eo ? OPVP_CLIPRULE_EVENODD : OPVP_CLIPRULE_WINDING) < 0) {
-      OPRS::error("SetClipPath error\n");
-      return splashErrOPVP;
-    }
-  }
-  return splashOk;
-}
-
-SplashError OPVPSplash::makeRectanglePath(SplashCoord x0,
-  SplashCoord y0, SplashCoord x1, SplashCoord y1, OPVPSplashPath **p)
-{
-  SplashError result;
-
-  *p = new OPVPSplashPath();
-  if ((result = (*p)->moveTo(x0,y0)) != splashOk) return result;
-  if ((result = (*p)->lineTo(x1,y0)) != splashOk) return result;
-  if ((result = (*p)->lineTo(x1,y1)) != splashOk) return result;
-  if ((result = (*p)->lineTo(x0,y1)) != splashOk) return result;
-  if ((result = (*p)->close()) != splashOk) return result;
-  return splashOk;
-}
-
-void OPVPSplash::clipResetToRect(SplashCoord x0, SplashCoord y0,
-			     SplashCoord x1, SplashCoord y1) {
-  OPVPSplashPath *p;
-  OPVPClipPath *cp;
-
-  while ((cp = OPVPClipPath::pop()) != NULL) delete cp;
-  if (clipPath != 0) {
-    delete clipPath;
-    clipPath = 0;
-  }
-
-  if (makeRectanglePath(x0,y0,x1,y1,&p) != splashOk) return;
-
-  if (doClipPath(p,true,clipPath) != splashOk) return;
-  clipPath = new OPVPClipPath(p,true);
-  state->clip->resetToRect(x0, y0, x1, y1);
-}
-
-SplashError OPVPSplash::clipToPath(OPVPSplashPath *path, bool eo) {
-  SplashError result;
-  SplashCoord x0, y0, x1, y1;
-  SplashCoord x2, y2, x3, y3;
-  SplashClipResult clipResult;
-  int xMin, yMin, xMax, yMax;
-
-  if (path == 0) return splashErrBogusPath;
-  if (path->getLength() == 0) return splashOk;
-  if (clipPath == 0) {
-    /* no clip region exist */
-    if ((result = state->clip->clipToPath(path, state->matrix,
-                   state->flatness, eo)) != splashOk) {
-      return result;
-    }
-    path = path->copy();
-  } else {
-    OPVPSplashPath *oldPath = clipPath->getPath();
-    if (path->isRectanglePath(&x0,&y0,&x1,&y1)) {
-      if ((clipResult = state->clip->testRect(
-         splashRound(x0), splashRound(y0), splashRound(x1), splashRound(y1)))
-	 == splashClipAllOutside) {
-	 /* no drawable area */
-	if ((result = state->clip->clipToPath(path, state->matrix,
-	      state->flatness, eo)) != splashOk) {
-	  return result;
-	}
-	path = new OPVPSplashPath();
-      } else if (clipResult == splashClipPartial) {
-	if (oldPath->isRectanglePath(&x2,&y2,&x3,&y3)) {
-	  if ((result = state->clip->clipToPath(path, state->matrix,
-	       state->flatness, eo)) != splashOk) {
-	    return result;
-	  }
-	  /* both rectangle */
-	  if (x0 < x2) x0 = x2;
-	  if (y0 < y2) y0 = y2;
-	  if (x1 > x3) x1 = x3;
-	  if (y1 > y3) y1 = y3;
-	  if ((result = makeRectanglePath(x0,y0,x1,y1,&path)) != splashOk) {
-	    return result;
-	  }
-	} else {
-	  state->clip->getBBox(&xMin,&yMin,&xMax,&yMax);
-	  if (splashRound(x0) <= xMin && splashRound(y0) <= yMin
-	      && splashRound(x1) >= xMax && splashRound(y1)) {
-		/* The old path is all inside the new path */
-		/* We may ignore the new path */
-	    return splashOk;
-	  }
-	  if ((result = state->clip->clipToPath(path, state->matrix, 
-	       state->flatness, eo)) != splashOk) {
-	    return result;
-	  }
-	  if (state->clip->getNumPaths() > 0) {
-	      path = state->clip->makePath();
-	  } else {
-	      path = new OPVPSplashPath();
-	  }
-	}
-      } else {
-	/* splashClipAllInside */
-	/* We may ignore the previous region. */
-	if ((result = state->clip->clipToPath(path, state->matrix,
-	     state->flatness, eo)) != splashOk) {
-	  return result;
-	}
-	path = path->copy();
-      }
-    } else {
-      /* non rectangle path */
-
-      OPVPSplashXPath *xpath = new OPVPSplashXPath(path, state->matrix, 
-                                     state->flatness, false);
-
-      xpath->sort();
-      SplashXPathScanner *scanner = new SplashXPathScanner(xpath,eo,
-        INT_MIN,INT_MAX);
-      scanner->getBBox(&xMin,&yMin,&xMax,&yMax);
-      delete scanner;
-      delete xpath;
-      if ((clipResult = state->clip->testRect(xMin,yMin,xMax,yMax))
-         == splashClipAllOutside) {
-	 /* no efect */
-	 /* no drawable area */
-	if ((result = state->clip->clipToPath(path, state->matrix,
-	     state->flatness, eo)) != splashOk) {
-	  return result;
-	}
-	path = new OPVPSplashPath();
-      } else if (clipResult == splashClipPartial) {
-	OPVPSplashClip *nclip = new OPVPSplashClip(xMin,yMin,xMax,yMax,false);
-	nclip->clipToPath(path,state->matrix,state->flatness,eo);
-	state->clip->getBBox(&xMin,&yMin,&xMax,&yMax);
-	if ((clipResult = nclip->testRect(xMin,yMin,xMax,yMax))
-	   == splashClipAllOutside) {
-	  /* no drawable area */
-	  delete nclip;
-	  if ((result = state->clip->clipToPath(path, state->matrix,
-	         state->flatness, eo)) != splashOk) {
-	    return result;
-	  }
-	  path = new OPVPSplashPath();
-	} else {
-	    delete nclip;
-	    if (clipResult == splashClipAllInside) {
-	      /* The old path is all inside the new path */
-	      /* We may ignore the new path */
-	      return splashOk;
-	    }
-	    if ((result = state->clip->clipToPath(path, state->matrix,
-	         state->flatness, eo)) != splashOk) {
-	      return result;
-	    }
-	    if (state->clip->getNumPaths() > 0) {
-	      path = state->clip->makePath();
-	    } else {
-	      path = new OPVPSplashPath();
-	    }
-	}
-      } else {
-	/* splashClipAllInside */
-	/* We may ignore the previous region. */
-	if ((result = state->clip->clipToPath(path, state->matrix,
-	      state->flatness, eo)) != splashOk) {
-	  return result;
-	}
-	path = path->copy();
-      }
-    }
-  }
-  if ((result = doClipPath(path,eo,clipPath)) != splashOk) {
-    delete path;
-    return result;
-  }
-  if (clipPath != 0) delete clipPath;
-  clipPath = new OPVPClipPath(path,eo);
-
-  return splashOk;
-}
-
-//------------------------------------------------------------------------
-// state save/restore
-//------------------------------------------------------------------------
-
-void OPVPSplash::saveState() {
-  OPVPSplashState *newState;
-
-  newState = state->copy();
-  newState->next = state;
-  state = newState;
-  if (clipPath != 0) clipPath->push();
-  if (opvp->SaveGS() != 0) {
-    OPRS::error("SaveGS error\n");
-    return;
-  }
-  saveDriverStateCount++;
-}
-
-SplashError OPVPSplash::restoreState() {
-  OPVPSplashState *oldState;
-  OPVPClipPath *oldClip;
-  OPVPSplashPath *path;
-  bool saved = false;
-
-  if (!state->next) {
-    return splashErrNoSave;
-  }
-  oldState = state;
-  state = state->next;
-  delete oldState;
-  if (saveDriverStateCount > 0 && opvp->RestoreGS() != 0) {
-    OPRS::error("RestoreGS error\n");
-    return splashErrOPVP;
-  }
-  saveDriverStateCount--;
-  oldClip = clipPath;
-  if (clipPath != 0) {
-    saved = clipPath->getSaved();
-    delete clipPath;
-    clipPath = 0;
-  }
-  clipPath = OPVPClipPath::pop();
-  if (clipPath != 0) {
-    path = clipPath->getPath();
-    if (path->getLength() > maxClipPathLength) {
-      if (clipPathNotSaved && !noClipPath) {
-	if (opvp->ResetClipPath() != 0) {
-	      OPRS::error("ResetClipPath error\n");
-	    return splashErrOPVP;
-	}
-	noClipPath = true;
-      }
-    } else {
-      noClipPath = savedNoClipPath;
-    }
-  } else {
-    noClipPath = savedNoClipPath;
-  }
-  if (clipPathNotSaved && !noClipPath) {
-    if (clipPath != 0) {
-      if (!saved) {
-	  SplashError result;
-
-	  if ((result = doClipPath(clipPath->getPath(),clipPath->getEo(),
-	           oldClip))
-		!= splashOk) return result;
-      }
-    } else if (oldClip != 0) {
-      if (opvp->ResetClipPath() != 0) {
-	OPRS::error("ResetClipPath error\n");
-	return splashErrOPVP;
-      }
-    }
-  }
-  return splashOk;
-}
-
-//------------------------------------------------------------------------
-// drawing operations
-//------------------------------------------------------------------------
-
-void OPVPSplash::clear(SplashColor color)
-{
-  opvp_brush_t brush;
-
-  brush.colorSpace = getOPVPColorSpace();
-  brush.pbrush = NULL;
-  brush.color[3] = -1;
-  brush.xorg = brush.yorg = 0;
-  switch (colorMode) {
-  case splashModeMono1:
-    brush.color[2] = color[0];
-    brush.color[1] = 0;
-    brush.color[0] = 0;
-    break;
-  case splashModeMono8:
-    brush.color[2] = color[0];
-    brush.color[1] = 0;
-    brush.color[0] = 0;
-    break;
-  case splashModeRGB8:
-    brush.color[2] = splashRGB8R(color);
-    brush.color[1] = splashRGB8G(color);
-    brush.color[0] = splashRGB8B(color);
-    break;
-  default:
-    OPRS::error("Unknown color mode\n");
-    brush.color[2] = splashRGB8R(color);
-    brush.color[1] = splashRGB8G(color);
-    brush.color[0] = splashRGB8B(color);
-    break;
-  }
-  opvp->SetBgColor(&brush);
-}
-
-/*
-  Translate arc to Bezier Curve
-
-  input start point (x0,y0) , center (cx, cy) and end point (x3, y3)
-  return Bezier curve control points (rx1,ry1 and rx2, ry2)
-
-  an angle should be less than eqaul 90 degree
-
-*/
-void OPVPSplash::arcToCurve(SplashCoord x0, SplashCoord y0,
-  SplashCoord x3, SplashCoord y3,
-  SplashCoord cx, SplashCoord cy, SplashCoord *rx1, SplashCoord *ry1,
-  SplashCoord *rx2, SplashCoord *ry2)
-{
-#define ROTX(x,y) (x*rotcos-y*rotsin)*r+cx
-#define ROTY(x,y) (x*rotsin+y*rotcos)*r+cy
-
-  SplashCoord x1,y1,x2,y2;
-  SplashCoord r;
-  SplashCoord rotcos, rotsin;
-  SplashCoord ox,oy,hx,hy,d;
-
-  hx = (x0+x3)/2;
-  hy = (y0+y3)/2;
-  r = splashDist(x0,y0,cx,cy);
-  d = splashDist(x0,y0,hx,hy);
-  rotcos = (hx-cx)/d;
-  rotsin = (hy-cy)/d;
-  oy = (splashDist(x0,y0,x3,y3)/2)/r;
-  ox = splashDist(hx,hy,cx,cy)/r;
-  x1 = ((4-ox)/3);
-  y1 = ((1-ox)*(3-ox)/(3*oy));
-  x2 = x1;
-  y2 = -y1;
-  *rx1 = ROTX(x1,y1);
-  *ry1 = ROTY(x1,y1);
-  *rx2 = ROTX(x2,y2);
-  *ry2 = ROTY(x2,y2);
-#undef ROTX
-#undef ROTY
-}
-
-SplashError OPVPSplash::strokeByMyself(OPVPSplashPath *path)
-{
-  SplashPath *dPath;
-  OPVPSplashPath *oPath;
-  Splash *osplash;
-  SplashPattern *savedPattern;
-
-  /* draw dashed line by myself */
-  if (path->getLength() == 0) {
-    return splashOk;
-  }
-
-  osplash = new Splash(new SplashBitmap(1,1,4,splashModeMono1,false),false);
-  state->setState(osplash);
-  dPath = osplash->makeStrokePath(path,state->lineWidth);
-  oPath = new OPVPSplashPath(dPath);
-  delete dPath;
-
-  if (state->lineWidth <= 1) {
-    OPVPSplashXPath *xPath;
-    xPath = new OPVPSplashXPath(oPath, state->matrix, state->flatness, false);
-    xPath->strokeNarrow(this,state);
-    delete xPath;
-  } else {
-    /* change fill pattern temprarily */
-    savedPattern = state->fillPattern->copy();
-    setFillPattern(state->strokePattern->copy());
-
-    fillByMyself(oPath,false);
-
-    /* restore fill pattern */
-    setFillPattern(savedPattern);
-  }
-  delete osplash;
-  return splashOk;
-}
-
-SplashError OPVPSplash::stroke(OPVPSplashPath *path) {
-  SplashError result;
-
-  if (clipPath != 0 && clipPath->getPath()->getLength() == 0) {
-      return splashOk;
-  }
-  if ((state->lineDash != NULL
-     && state->lineDashLength > 0 && noLineStyle)) {
-    return strokeByMyself(path);
-  }
-  if (noMiterLimit && (!ignoreMiterLimit) && state->lineWidth != 0
-      && state->lineJoin == splashLineJoinMiter) {
-    return strokeByMyself(path);
-  }
-  if (noClipPath) {
-    int xMin, yMin, xMax, yMax;
-    SplashClipResult clipResult;
-    int fatOffset = splashCeil(state->lineWidth/2);
-    int miterLimit = splashCeil(state->miterLimit/2);
-
-    if (fatOffset < miterLimit) fatOffset = miterLimit;
-    path->getBBox(&xMin,&yMin,&xMax,&yMax);
-    xMin -= fatOffset;
-    yMin -= fatOffset;
-    xMax += fatOffset;
-    yMax += fatOffset;
-    clipResult = state->clip->testRect(xMin,yMin,xMax,yMax);
-    if (clipResult == splashClipAllOutside) {
-      /* not need to draw */
-      return splashOk;
-    } else if (clipResult == splashClipPartial) {
-      return strokeByMyself(path);
-    }
-    /* splashClipAllInside */
-    /* fall through */
-  }
-  if ((result = path->makePath(opvp)) != 0) return result;
-  if (opvp->StrokePath() < 0) {
-    OPRS::error("StrokePath error\n");
-    return splashErrOPVP;
-  }
-  return splashOk;
-}
-
-SplashError OPVPSplash::fillByMyself(OPVPSplashPath *path, bool eo)
-{
-  OPVPSplashXPath *xPath;
-  SplashXPathScanner *scanner;
-  int xMinI, yMinI, xMaxI, yMaxI, x0, x1, y;
-  SplashClipResult clipRes, clipRes2;
-
-  if (path->getLength() == 0) {
-    return splashOk;
-  }
-  xPath = new OPVPSplashXPath(path, state->matrix, state->flatness, true);
-  xPath->sort();
-  scanner = new SplashXPathScanner(xPath, eo, INT_MIN, INT_MAX);
-
-  // get the min and max x and y values
-  scanner->getBBox(&xMinI, &yMinI, &xMaxI, &yMaxI);
-
-  // check clipping
-  if ((clipRes = state->clip->testRect(xMinI, yMinI, xMaxI, yMaxI))
-      != splashClipAllOutside) {
-    SplashPattern *savedPattern;
-
-    /* change stroke pattern temporarily */
-    savedPattern = state->strokePattern->copy();
-    setStrokePattern(state->fillPattern->copy());
-
-    for (y = yMinI; y < yMaxI; ++y) {
-#if POPPLER_VERSION_MAJOR > 0 || POPPLER_VERSION_MINOR >= 70
-      SplashXPathScanIterator iterator(*scanner, y);
-      while (iterator.getNextSpan(&x0, &x1))
-#else
-      while (scanner->getNextSpan(y, &x0, &x1))
-#endif
-      {
-        if (x0 == x1) continue;
-	if (clipRes == splashClipAllInside) {
-	  drawSpan(x0, x1-1, y, true);
-	} else {
-	  clipRes2 = state->clip->testSpan(x0, x1, y);
-	  drawSpan(x0, x1-1, y, clipRes2 == splashClipAllInside);
-	}
-      }
-    }
-    /* restore stroke pattern */
-    setStrokePattern(savedPattern);
-  }
-
-  delete scanner;
-  delete xPath;
-  return splashOk;
-}
-
-SplashError OPVPSplash::fill(OPVPSplashPath *path, bool eo) {
-  SplashError result;
-  opvp_fillmode_t mode;
-
-  if (path->getLength() <= 1) return splashOk;
-  if (clipPath != 0 && clipPath->getPath()->getLength() == 0) {
-      return splashOk;
-  }
-  if (path->getLength() > maxFillPathLength) {
-      return fillByMyself(path,eo);
-  }
-  if (noClipPath) {
-    int xMin, yMin, xMax, yMax;
-    SplashClipResult clipResult;
-
-    path->getBBox(&xMin,&yMin,&xMax,&yMax);
-    clipResult = state->clip->testRect(xMin,yMin,xMax,yMax);
-    if (clipResult == splashClipAllOutside) {
-      /* not need to draw */
-      return splashOk;
-    } else if (clipResult == splashClipPartial) {
-      return fillByMyself(path,eo);
-    }
-    /* splashClipAllInside */
-    /* fall through */
-  }
-  if ((result = path->makePath(opvp)) != 0) return result;
-  mode = eo ? OPVP_FILLMODE_EVENODD : OPVP_FILLMODE_WINDING;
-  if (opvp->SetFillMode(mode) < 0) {
-    OPRS::error("SetFillMode error\n");
-    return splashErrOPVP;
-  }
-  if (opvp->FillPath() < 0) {
-    OPRS::error("FillPath error\n");
-    return splashErrOPVP;
-  }
-  return splashOk;
-}
-
-void OPVPSplash::fillGlyph(SplashCoord x, SplashCoord y,
-  SplashGlyphBitmap *glyph)
-{
-  opvp_fix_t opvpx,opvpy;
-  int opvpbytes;
-  int x0, y0;
-  Guchar *bp;
-  SplashClipResult clipRes;
-  SplashCoord xt, yt;
-
-  transform(state->matrix,x,y,&xt,&yt);
-  x0 = splashFloor(xt)-glyph->x;
-  y0 = splashFloor(yt)-glyph->y;
-  clipRes = state->clip->testRect(x0,y0,
-		     x0 + glyph->w - 1,
-		     y0 + glyph->h - 1);
-  if (clipRes == splashClipAllOutside) return;
-  OPVP_i2Fix((x0),(opvpx));
-  OPVP_i2Fix((y0),(opvpy));
-  if (opvp->SetCurrentPoint(opvpx,opvpy) < 0) {
-    OPRS::error("SetCurrentPoint error\n");
-  }
-
-  if (oldLipsDriver && (((glyph->w+7)/8) & 3) != 0) {
-    /* not 4bytes aligned, so make aligned */
-    int i;
-    int m = (glyph->w+7)/8;
-    
-    opvpbytes = (m+3)/4;
-    opvpbytes *= 4;
-    bp = (Guchar *)gmallocn(glyph->h,opvpbytes);
-    for (i = 0;i < glyph->h;i++) {
-      memcpy(bp+i*opvpbytes,glyph->data+i*m,m);
-    }
-  } else {
-    bp = glyph->data;
-    opvpbytes = (glyph->w+7)/8;
-  }
-  if ((!noClipPath || clipRes != splashClipPartial) && !noImageMask) {
-    if (opvp->DrawImage(glyph->w,glyph->h,opvpbytes,OPVP_IFORMAT_MASK,
-	 glyph->w,glyph->h,(void *)bp) < 0) {
-      OPRS::error("DrawImage error\n");
-    }
-  } else {
-    int tx,ty;
-    int sx = 0;
-    SplashPattern *savedPattern;
-    SplashCoord *savedLineDash = 0;
-    int savedLineDashLength;
-    SplashCoord savedLineDashPhase;
-    SplashCoord savedLineWidth;
-
-    /* change stroke pattern temprarily */
-    savedPattern = state->strokePattern->copy();
-    setStrokePattern(state->fillPattern->copy());
-    /* change lins style temporarily */
-    savedLineDashLength = state->lineDashLength;
-    savedLineDashPhase = state->lineDashPhase;
-    if (savedLineDashLength > 0 && state->lineDash != 0) {
-      savedLineDash = new SplashCoord[savedLineDashLength];
-      memcpy(savedLineDash, state->lineDash,
-	savedLineDashLength*sizeof(SplashCoord));
-    }
-    setLineDash(0,0,0);
-    savedLineWidth = state->lineWidth;
-    setLineWidth(0.0);
-
-
-    for (ty = 0;ty < glyph->h;ty++) {
-      bool dmode = false;
-      for (tx = 0;tx < glyph->w;tx++) {
-	bool on = (bp[opvpbytes*ty+(tx/8)] & (0x80 >> (tx & 7))) != 0;
-
-	if (on && !dmode) {
-	  sx = tx;
-	  dmode = true;
-	} else if (!on && dmode) {
-	  drawSpan(x0+sx,x0+tx-1,y0+ty,true);
-	  dmode = false;
-	}
-      }
-      if (dmode) {
-	drawSpan(x0+sx,x0+tx-1,y0+ty,true);
-      }
-    }
-    /* restore stroke pattern */
-    setStrokePattern(savedPattern);
-    /* restore line style */
-    setLineDash(savedLineDash,savedLineDashLength,
-      savedLineDashPhase);
-    if (savedLineDash != 0) {
-      delete[] savedLineDash;
-    }
-    setLineWidth(savedLineWidth);
-  }
-  if (bp != glyph->data) gfree(bp);
-}
-
-SplashError OPVPSplash::fillChar(SplashCoord x, SplashCoord y,
-			     int c, SplashFont *font,
-			     Unicode *u, double *fontMat) {
-  SplashError err = splashOk;
-  SplashPath *spath;
-  OPVPSplashPath *path;
-  SplashCoord xt, yt;
-  double mx,my;
-
-  transform(state->matrix, x, y, &xt, &yt);
-  if ((spath = font->getGlyphPath(c)) == 0) return splashOk;
-  path = new OPVPSplashPath(spath);
-  delete spath;
-  if (bitmapCharThreshold > 0) {
-    mx = splashAbs(fontMat[0]);
-    if (mx < splashAbs(fontMat[1])) {
-	mx = splashAbs(fontMat[1]);
-    }
-    my = splashAbs(fontMat[3]);
-    if (my < splashAbs(fontMat[2])) {
-	my = splashAbs(fontMat[2]);
-    }
-    if (path == 0 || (mx*my < bitmapCharThreshold)) {
-      /* if a char is enough small, then out a char as a bitmask */
-      SplashGlyphBitmap glyph;
-      int x0, y0, xFrac, yFrac;
-      SplashClipResult clipRes;
-
-      x0 = splashFloor(xt);
-      xFrac = splashFloor((xt - x0) * splashFontFraction);
-      y0 = splashFloor(yt);
-      yFrac = splashFloor((yt - y0) * splashFontFraction);
-      if (font->getGlyph(c, xFrac, yFrac, &glyph, x0, y0, state->clip,
-          &clipRes)) {
-	if (path != 0) delete path;
-	if (glyph.w == 0 || glyph.h == 0) {
-	  /* empty glyph */
-	  return splashOk;
-	}
-	if (clipRes != splashClipAllOutside) {
-	    fillGlyph(xt, yt, &glyph);
-	}
-	if (glyph.freeData) {
-	  gfree(glyph.data);
-	}
-	return err;
-      }
-    }
-    /* fall through and out a char as a path */
-  }
-  if (path == 0) {
-    //OPRS::error("FillPath error\n");
-    err = splashErrOPVP;
-    goto err0;
-  }
-  path->offset(xt,yt);
-  err = fill(path,false);
-err0:
-  if (path != 0) delete path;
-  return err;
-}
-
-SplashError OPVPSplash::fillImageMaskFastWithCTM(SplashImageMaskSource src,
-       void *srcData, int w, int h, int tx, int ty,SplashCoord *mat) {
-  int i, j;
-  opvp_fix_t opvpx,opvpy;
-  int opvpbytes;
-  opvp_ctm_t opvpctm;
-  Guchar *buf = 0, *bp;
-  SplashError result = splashOk;
-  SplashColorPtr lineBuf;
-
-  opvpbytes = (w+7)/8;
-  /* align 4 */
-  opvpbytes = (opvpbytes+3)/4;
-  opvpbytes *= 4;
-  buf = (Guchar *)gmallocn(h,opvpbytes);
-  lineBuf = (SplashColorPtr)gmallocn(8,opvpbytes);
-
-  for (i = 0;i < h;i++) {
-    int k;
-
-    bp = buf+opvpbytes*i;
-    (*src)(srcData, lineBuf);
-    for (j = 0;j < w;j += k) {
-      Guchar d;
-
-      d = 0;
-      for (k = 0;k < 8 && j+k < w;k++) {
-	d <<= 1;
-	if (lineBuf[j+k] != 0) d |= 1;
-      }
-      d <<= 8-k;
-      *bp++ = d;
-    }
-  }
-  free(lineBuf);
-  opvpctm.a = mat[0];
-  opvpctm.b = mat[1];
-  opvpctm.c = mat[2];
-  opvpctm.d = mat[3];
-  opvpctm.e = mat[4];
-  opvpctm.f = mat[5];
-  OPVP_i2Fix((tx),(opvpx));
-  OPVP_i2Fix((ty),(opvpy));
-  if (opvp->SetCurrentPoint(opvpx,opvpy) < 0) {
-    OPRS::error("SetCurrentPoint error\n");
-  }
-
-  if (opvp->SetCTM(&opvpctm) < 0) {
-    OPRS::error("SetCTM error\n");
-  }
-  if (opvp->DrawImage(w,h,opvpbytes,OPVP_IFORMAT_MASK,1,1,(void *)(buf)) < 0) {
-    OPRS::error("DrawImage error\n");
-    result = splashErrOPVP;
-  }
-  /* reset CTM */
-  opvpctm.a = 1.0;
-  opvpctm.b = 0.0;
-  opvpctm.c = 0.0;
-  opvpctm.d = 1.0;
-  opvpctm.e = 0.0;
-  opvpctm.f = 0.0;
-  if (opvp->SetCTM(&opvpctm) < 0) {
-    OPRS::error("SetCTM error\n");
-  }
-
-  if (buf != 0) gfree(buf);
-  return result;
-}
-
-SplashError OPVPSplash::fillImageMask(SplashImageMaskSource src, void *srcData,
-			  int w, int h, SplashCoord *mat, bool glyphMode) {
-  bool rot;
-  SplashCoord xScale, yScale, xShear, yShear;
-  int tx, ty, scaledWidth, scaledHeight, xSign, ySign;
-  int ulx, uly, llx, lly, urx, ury, lrx, lry;
-  int ulx1, uly1, llx1, lly1, urx1, ury1, lrx1, lry1;
-  int xMin, xMax, yMin, yMax;
-  SplashClipResult clipRes;
-  SplashColorPtr pixBuf;
-  SplashColorPtr p;
-  int x, y;
-  int i;
-  SplashPattern *savedPattern;
-  SplashCoord *savedLineDash = 0;
-  int savedLineDashLength;
-  SplashCoord savedLineDashPhase;
-  SplashCoord savedLineWidth;
-
-  if (debugMode) {
-    printf("fillImageMask: w=%d h=%d mat=[%.2f %.2f %.2f %.2f %.2f %.2f]\n",
-	   w, h, mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);
-  }
-
-  // check for singular matrix
-  if (splashAbs(mat[0] * mat[3] - mat[1] * mat[2]) < 0.000001) {
-    return splashErrSingularMatrix;
-  }
-
-  // compute scale, shear, rotation, translation parameters
-  rot = splashAbs(mat[1]) > splashAbs(mat[0]);
-  if (rot) {
-    xScale = -mat[1];
-    yScale = mat[2] - (mat[0] * mat[3]) / mat[1];
-    xShear = -mat[3] / yScale;
-    yShear = -mat[0] / mat[1];
-  } else {
-    xScale = mat[0];
-    yScale = mat[3] - (mat[1] * mat[2]) / mat[0];
-    xShear = mat[2] / yScale;
-    yShear = mat[1] / mat[0];
-  }
-  tx = splashRound(mat[4]);
-  ty = splashRound(mat[5]);
-  scaledWidth = abs(splashRound(mat[4] + xScale) - tx) + 1;
-  scaledHeight = abs(splashRound(mat[5] + yScale) - ty) + 1;
-  xSign = (xScale < 0) ? -1 : 1;
-  ySign = (yScale < 0) ? -1 : 1;
-
-  // clipping
-  ulx1 = 0;
-  uly1 = 0;
-  urx1 = xSign * (scaledWidth - 1);
-  ury1 = splashRound(yShear * urx1);
-  llx1 = splashRound(xShear * ySign * (scaledHeight - 1));
-  lly1 = ySign * (scaledHeight - 1) + splashRound(yShear * llx1);
-  lrx1 = xSign * (scaledWidth - 1) +
-           splashRound(xShear * ySign * (scaledHeight - 1));
-  lry1 = ySign * (scaledHeight - 1) + splashRound(yShear * lrx1);
-  if (rot) {
-    ulx = tx + uly1;    uly = ty - ulx1;
-    urx = tx + ury1;    ury = ty - urx1;
-    llx = tx + lly1;    lly = ty - llx1;
-    lrx = tx + lry1;    lry = ty - lrx1;
-  } else {
-    ulx = tx + ulx1;    uly = ty + uly1;
-    urx = tx + urx1;    ury = ty + ury1;
-    llx = tx + llx1;    lly = ty + lly1;
-    lrx = tx + lrx1;    lry = ty + lry1;
-  }
-  xMin = (ulx < urx) ? (ulx < llx) ? (ulx < lrx) ? ulx : lrx
-                                   : (llx < lrx) ? llx : lrx
-		     : (urx < llx) ? (urx < lrx) ? urx : lrx
-                                   : (llx < lrx) ? llx : lrx;
-  xMax = (ulx > urx) ? (ulx > llx) ? (ulx > lrx) ? ulx : lrx
-                                   : (llx > lrx) ? llx : lrx
-		     : (urx > llx) ? (urx > lrx) ? urx : lrx
-                                   : (llx > lrx) ? llx : lrx;
-  yMin = (uly < ury) ? (uly < lly) ? (uly < lry) ? uly : lry
-                                   : (lly < lry) ? lly : lry
-		     : (ury < lly) ? (ury < lry) ? ury : lry
-                                   : (lly < lry) ? lly : lry;
-  yMax = (uly > ury) ? (uly > lly) ? (uly > lry) ? uly : lry
-                                   : (lly > lry) ? lly : lry
-		     : (ury > lly) ? (ury > lry) ? ury : lry
-                                   : (lly > lry) ? lly : lry;
-  clipRes = state->clip->testRect(xMin, yMin, xMax, yMax);
-  if (clipRes == splashClipAllOutside) return splashOk;
-
-  if (!noClipPath || clipRes == splashClipAllInside) {
-    if (!noShearImage && !noImageMask) {
-      if (fillImageMaskFastWithCTM(src,srcData,w,h,tx,ty,mat)
-	  == splashOk) {
-	return splashOk;
-      }
-    }
-  }
-
-  SplashError result = splashOk;
-  /* change stroke pattern temprarily */
-  savedPattern = state->strokePattern->copy();
-  setStrokePattern(state->fillPattern->copy());
-
-  /* change lins style temporarily */
-  savedLineDashLength = state->lineDashLength;
-  savedLineDashPhase = state->lineDashPhase;
-  if (savedLineDashLength > 0 && state->lineDash != 0) {
-    savedLineDash = new SplashCoord[savedLineDashLength];
-    memcpy(savedLineDash, state->lineDash,
-      savedLineDashLength*sizeof(SplashCoord));
-  }
-  setLineDash(0,0,0);
-  savedLineWidth = state->lineWidth;
-  setLineWidth(0.0);
-
-  /* calculate inverse matrix */
-  SplashCoord imat[4];
-  double det = mat[0] * mat[3] - mat[1] * mat[2];
-  imat[0] = mat[3]/det;
-  imat[1] = -mat[1]/det;
-  imat[2] = -mat[2]/det;
-  imat[3] = mat[0]/det;
-
-  /* read source image */
-  pixBuf = (SplashColorPtr)gmallocn(h , w);
-
-  p = pixBuf;
-  for (i = 0; i < h; ++i) {
-    (*src)(srcData, p);
-    p += w;
-  }
-  int width = xMax-xMin+1;
-  int height = yMax-yMin+1;
-  OPVPSplashClip *clip = state->clip->copy();
-
-  if (w < scaledWidth || h < scaledHeight) {
-    OPVPSplashPath cpath;
-
-    cpath.moveTo(tx,ty);
-    cpath.lineTo(mat[0]+tx,mat[1]+ty);
-    cpath.lineTo(mat[0]+mat[2]+tx,mat[1]+mat[3]+ty);
-    cpath.lineTo(mat[2]+tx,mat[3]+ty);
-    clip->clipToPath(&cpath,state->matrix,1.0,false);
-  }
-  for (y = 0;y < height;y++) {
-    int dy = y+yMin-ty;
-    int sx = 0;
-    bool dmode = false;
-
-    for (x = 0;x < width;x++) {
-      if (!clip->test(x+xMin,y+yMin)) {
-	if (dmode) {
-	  drawSpan(xMin+sx,xMin+x-1,yMin+y,true);
-	  dmode = false;
-	}
-	continue;
-      }
-      int ox,oy;
-      /* calculate original coordinate */
-      int dx = x+xMin-tx;
-      ox = (int)trunc((imat[0]*dx+imat[2]*dy)*w);
-      oy = (int)trunc((imat[1]*dx+imat[3]*dy)*h);
-      if (ox >= 0 && ox < w && oy >= 0 && oy < h) {
-	bool on = pixBuf[oy*w+ox] != 0;
-
-	if (on && !dmode) {
-	  dmode = true;
-	  sx = x;
-	} else if (!on && dmode) {
-	  drawSpan(xMin+sx,xMin+x-1,yMin+y,true);
-	  dmode = false;
-	}
-      } else if (dmode) {
-	drawSpan(xMin+sx,xMin+x-1,yMin+y,true);
-	dmode = false;
-      }
-    }
-    if (dmode) {
-      drawSpan(xMin+sx,xMin+x-1,yMin+y,true);
-    }
-  }
-  delete clip;
-  gfree(pixBuf);
-
-  /* restore stroke pattern */
-  setStrokePattern(savedPattern);
-  /* restore line style */
-  setLineDash(savedLineDash,savedLineDashLength,
-    savedLineDashPhase);
-  if (savedLineDash != 0) {
-    delete[] savedLineDash;
-  }
-  setLineWidth(savedLineWidth);
-
-  return result;
-}
-
-SplashError OPVPSplash::drawImageNotShear(SplashImageSource src,
-                              void *srcData,
-			      int w, int h,
-			      int tx, int ty,
-			      int scaledWidth, int scaledHeight,
-			      int xSign, int ySign, bool rot) {
-  int i, j;
-  opvp_fix_t opvpx,opvpy;
-  int opvpbytes, linesize;
-  opvp_ctm_t opvpctm;
-  SplashError result = splashOk;
-  Guchar *buf = 0, *bp;
-  SplashColorPtr lineBuf = 0, color;
-  float e,f;
-  int hs,he, hstep;
-  int ow = w;
-  int lineBufSize;
-
-  if (rot) {
-    int t = h;
-
-    h = w;
-    w = t;
-    t = scaledHeight;
-    scaledHeight = scaledWidth;
-    scaledWidth = t;
-    if (xSign != ySign) {
-	xSign = xSign >= 0 ? -1 : 1;
-    } else {
-	ySign = ySign >= 0 ? -1 : 1;
-    }
-  }
-
-  if (xSign > 0) {
-    OPVP_i2Fix((tx),(opvpx));
-    e = tx;
-  } else {
-    OPVP_i2Fix((tx-scaledWidth),(opvpx));
-    e = tx-scaledWidth;
-  }
-  if (ySign > 0) {
-    OPVP_i2Fix((ty),(opvpy));
-    f = ty;
-  } else {
-    OPVP_i2Fix((ty-scaledHeight),(opvpy));
-    f = ty-scaledHeight;
-  }
-  if (opvp->SetCurrentPoint(opvpx,opvpy) < 0) {
-    OPRS::error("SetCurrentPoint error\n");
-    return splashErrOPVP;
-  }
-  switch (colorMode) {
-  case splashModeMono1:
-  case splashModeMono8:
-    linesize = w;
-    opvpbytes = (w+3)/4;
-    opvpbytes *= 4;
-    lineBufSize = (ow+3)/4;
-    lineBufSize *= 4;
-    break;
-  case splashModeRGB8:
-    linesize = w*3;;
-    opvpbytes = (w*3+3)/4;
-    opvpbytes *= 4;
-    lineBufSize = (ow*3+3)/4;
-    lineBufSize *= 4;
-    break;
-  default:
-    OPRS::error("Image: no supported color mode\n");
-    return splashErrOPVP;
-    break;
-  }
-  if (ySign >= 0) {
-    hstep = 1;
-    hs = 0;
-    he = h;
-  } else {
-    hstep = -1;
-    hs = h-1;
-    he = -1;
-  }
-  buf = (Guchar *)gmallocn(h,opvpbytes);
-  lineBuf = (SplashColorPtr)gmallocn(lineBufSize,1);
-  switch (colorMode) {
-  case splashModeMono1:
-  case splashModeMono8:
-    if (rot) {
-      if (xSign >= 0) {
-	for (i = 0;i < w;i++) {
-	  (*src)(srcData, lineBuf, NULL);
-	  color = lineBuf;
-	  for (j = hs;j != he;j += hstep) {
-	    bp = buf+i+j*opvpbytes;
-	    *bp = *color++;
-	  }
-	}
-      } else {
-	for (i = 0;i < w;i++) {
-	  (*src)(srcData, lineBuf, NULL);
-	  color = lineBuf;
-	  for (j = hs;j != he;j += hstep) {
-	    bp = buf+linesize-1-i+j*opvpbytes;
-	    *bp = *color++;
-	  }
-	}
-      }
-    } else {
-      if (xSign >= 0) {
-	for (i = hs;i != he;i += hstep) {
-	  bp = buf+opvpbytes*i;
-	  (*src)(srcData, lineBuf, NULL);
-	  color = lineBuf;
-	  for (j = 0;j < w;j++) {
-	    *bp++ = *color++;
-	  }
-	}
-      } else {
-	for (i = hs;i != he;i += hstep) {
-	  bp = buf+opvpbytes*i+linesize-1;
-	  (*src)(srcData, lineBuf, NULL);
-	  color = lineBuf;
-	  for (j = 0;j < w;j++) {
-	    *bp-- = *color++;
-	  }
-	}
-      }
-    }
-    break;
-  case splashModeRGB8:
-    if (rot) {
-      if (xSign >= 0) {
-	for (i = 0;i < w;i++) {
-	  (*src)(srcData, lineBuf, NULL);
-	  color = lineBuf;
-	  for (j = hs;j != he;j += hstep) {
-	    bp = buf+i*3+j*opvpbytes;
-	    bp[0] = *color++;
-	    bp[1] = *color++;
-	    bp[2] = *color++;
-	  }
-	}
-      } else {
-	for (i = 0;i < w;i++) {
-	  (*src)(srcData, lineBuf, NULL);
-	  color = lineBuf;
-	  for (j = hs;j != he;j += hstep) {
-	    bp = buf+linesize-3-i*3+j*opvpbytes;
-	    bp[0] = *color++;
-	    bp[1] = *color++;
-	    bp[2] = *color++;
-	  }
-	}
-      }
-    } else {
-      if (xSign >= 0) {
-	for (i = hs;i != he;i += hstep) {
-	  bp = buf+opvpbytes*i;
-	  (*src)(srcData, lineBuf, NULL);
-	  color = lineBuf;
-	  for (j = 0;j < w;j++) {
-	    *bp++ = *color++;
-	    *bp++ = *color++;
-	    *bp++ = *color++;
-	  }
-	}
-      } else {
-	for (i = hs;i != he;i += hstep) {
-	  bp = buf+opvpbytes*i+linesize-1;
-	  (*src)(srcData, lineBuf, NULL);
-	  color = lineBuf;
-	  for (j = 0;j < w;j++) {
-	    *bp-- = color[2];
-	    *bp-- = color[1];
-	    *bp-- = color[0];
-	    color += 3;
-	  }
-	}
-      }
-    }
-    break;
-  default:
-    OPRS::error("Image: no supported color mode\n");
-    result = splashErrOPVP;
-    goto err1;
-    break;
-  }
-  if (lineBuf != 0) gfree(lineBuf);
-
-  /* canonlisp driver use CTM only, ignores currentPoint */
-  /* So, set start point to CTM */
-  opvpctm.a = 1.0;
-  opvpctm.b = 0.0;
-  opvpctm.c = 0.0;
-  opvpctm.d = 1.0;
-  opvpctm.e = e;
-  opvpctm.f = f;
-  if (opvp->SetCTM(&opvpctm) < 0) {
-    OPRS::error("SetCTM error\n");
-  }
-
-  if (opvp->DrawImage(w,h,opvpbytes,OPVP_IFORMAT_RAW,
-       scaledWidth,scaledHeight,(void *)(buf)) < 0) {
-    OPRS::error("DrawImage error\n");
-    result = splashErrOPVP;
-    goto err1;
-  }
-err1:
-  /* reset CTM */
-  opvpctm.e = 0.0;
-  opvpctm.f = 0.0;
-  if (opvp->SetCTM(&opvpctm) < 0) {
-    OPRS::error("SetCTM error\n");
-  }
-
-  if (buf != 0) gfree(buf);
-  return result;
-}
-
-SplashError OPVPSplash::drawImageFastWithCTM(SplashImageSource src,
-                              void *srcData,
-			      int w, int h, int tx, int ty,
-			      SplashCoord *mat) {
-  int i;
-  opvp_fix_t opvpx,opvpy;
-  int opvpbytes;
-  opvp_ctm_t opvpctm;
-  Guchar *buf = 0, *bp;
-
-  switch (colorMode) {
-  case splashModeMono1:
-  case splashModeMono8:
-    opvpbytes = (w+3)/4;
-    opvpbytes *= 4;
-    break;
-  case splashModeRGB8:
-    opvpbytes = (w*3+3)/4;
-    opvpbytes *= 4;
-    break;
-  default:
-    OPRS::error("Image: no supported color mode\n");
-    return splashErrOPVP;
-    break;
-  }
-  buf = (Guchar *)gmallocn(h,opvpbytes);
-
-  switch (colorMode) {
-  case splashModeMono1:
-  case splashModeMono8:
-    for (i = 0;i < h;i++) {
-      bp = buf+opvpbytes*i;
-      (*src)(srcData, (SplashColorPtr)bp, NULL);
-    }
-    break;
-  case splashModeRGB8:
-    for (i = 0;i < h;i++) {
-      bp = buf+opvpbytes*i;
-      (*src)(srcData, (SplashColorPtr)bp, NULL);
-    }
-    break;
-  default:
-    OPRS::error("Image: no supported color mode\n");
-    goto err0;
-    break;
-  }
-
-  opvpctm.a = mat[0];
-  opvpctm.b = mat[1];
-  opvpctm.c = mat[2];
-  opvpctm.d = mat[3];
-  opvpctm.e = mat[4];
-  opvpctm.f = mat[5];
-  OPVP_i2Fix((tx),(opvpx));
-  OPVP_i2Fix((ty),(opvpy));
-  if (opvp->SetCurrentPoint(opvpx,opvpy) < 0) {
-    OPRS::error("SetCurrentPoint error\n");
-  }
-
-  if (opvp->SetCTM(&opvpctm) < 0) {
-    OPRS::error("SetCTM error\n");
-  }
-  if (opvp->DrawImage(w,h,opvpbytes,OPVP_IFORMAT_RAW,1,1,(void *)(buf)) < 0) {
-    OPRS::error("DrawImage error\n");
-  }
-err0:
-  /* reset CTM */
-  opvpctm.a = 1.0;
-  opvpctm.b = 0.0;
-  opvpctm.c = 0.0;
-  opvpctm.d = 1.0;
-  opvpctm.e = 0.0;
-  opvpctm.f = 0.0;
-  if (opvp->SetCTM(&opvpctm) < 0) {
-    OPRS::error("SetCTM error\n");
-  }
-
-  if (buf != 0) gfree(buf);
-  return splashOk;
-}
-
-SplashError OPVPSplash::drawImage(SplashImageSource src, void *srcData,
-			      SplashColorMode srcMode, bool srcAlpha,
-			      int w, int h, SplashCoord *mat) {
-  bool ok, rot;
-  SplashCoord xScale, yScale, xShear, yShear;
-  int tx, ty, scaledWidth, scaledHeight, xSign, ySign;
-  int ulx, uly, llx, lly, urx, ury, lrx, lry;
-  int ulx1, uly1, llx1, lly1, urx1, ury1, lrx1, lry1;
-  int xMin, xMax, yMin, yMax;
-  SplashClipResult clipRes;
-  SplashColorPtr pixBuf, p;
-  int x, y;
-  int i;
-
-  if (debugMode) {
-    printf("drawImage: srcMode=%d w=%d h=%d mat=[%.2f %.2f %.2f %.2f %.2f %.2f]\n",
-	   srcMode, w, h, mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);
-  }
-
-  // check color modes
-  ok = false; // make gcc happy
-  switch (colorMode) {
-  case splashModeMono1:
-    ok = srcMode == splashModeMono1 || srcMode == splashModeMono8;
-    break;
-  case splashModeMono8:
-    ok = srcMode == splashModeMono8;
-    break;
-  case splashModeRGB8:
-    ok = srcMode == splashModeRGB8;
-    break;
-  }
-  if (!ok) {
-    OPRS::error("Image Mode mismatch\n");
-    return splashErrModeMismatch;
-  }
-
-  // check for singular matrix
-  if (splashAbs(mat[0] * mat[3] - mat[1] * mat[2]) < 0.000001) {
-    OPRS::error("Image Not Singular Matrix\n");
-    return splashErrSingularMatrix;
-  }
-
-  // compute scale, shear, rotation, translation parameters
-  rot = splashAbs(mat[1]) > splashAbs(mat[0]);
-  if (rot) {
-    xScale = -mat[1];
-    yScale = mat[2] - (mat[0] * mat[3]) / mat[1];
-    xShear = -mat[3] / yScale;
-    yShear = -mat[0] / mat[1];
-  } else {
-    xScale = mat[0];
-    yScale = mat[3] - (mat[1] * mat[2]) / mat[0];
-    xShear = mat[2] / yScale;
-    yShear = mat[1] / mat[0];
-  }
-  tx = splashRound(mat[4]);
-  ty = splashRound(mat[5]);
-  scaledWidth = abs(splashRound(mat[4] + xScale) - tx) + 1;
-  scaledHeight = abs(splashRound(mat[5] + yScale) - ty) + 1;
-  xSign = (xScale < 0) ? -1 : 1;
-  ySign = (yScale < 0) ? -1 : 1;
-
-  // clipping
-  ulx1 = 0;
-  uly1 = 0;
-  urx1 = xSign * (scaledWidth - 1);
-  ury1 = splashRound(yShear * urx1);
-  llx1 = splashRound(xShear * ySign * (scaledHeight - 1));
-  lly1 = ySign * (scaledHeight - 1) + splashRound(yShear * llx1);
-  lrx1 = xSign * (scaledWidth - 1) +
-           splashRound(xShear * ySign * (scaledHeight - 1));
-  lry1 = ySign * (scaledHeight - 1) + splashRound(yShear * lrx1);
-  if (rot) {
-    ulx = tx + uly1;    uly = ty - ulx1;
-    urx = tx + ury1;    ury = ty - urx1;
-    llx = tx + lly1;    lly = ty - llx1;
-    lrx = tx + lry1;    lry = ty - lrx1;
-  } else {
-    ulx = tx + ulx1;    uly = ty + uly1;
-    urx = tx + urx1;    ury = ty + ury1;
-    llx = tx + llx1;    lly = ty + lly1;
-    lrx = tx + lrx1;    lry = ty + lry1;
-  }
-  xMin = (ulx < urx) ? (ulx < llx) ? (ulx < lrx) ? ulx : lrx
-                                   : (llx < lrx) ? llx : lrx
-		     : (urx < llx) ? (urx < lrx) ? urx : lrx
-                                   : (llx < lrx) ? llx : lrx;
-  xMax = (ulx > urx) ? (ulx > llx) ? (ulx > lrx) ? ulx : lrx
-                                   : (llx > lrx) ? llx : lrx
-		     : (urx > llx) ? (urx > lrx) ? urx : lrx
-                                   : (llx > lrx) ? llx : lrx;
-  yMin = (uly < ury) ? (uly < lly) ? (uly < lry) ? uly : lry
-                                   : (lly < lry) ? lly : lry
-		     : (ury < lly) ? (ury < lry) ? ury : lry
-                                   : (lly < lry) ? lly : lry;
-  yMax = (uly > ury) ? (uly > lly) ? (uly > lry) ? uly : lry
-                                   : (lly > lry) ? lly : lry
-		     : (ury > lly) ? (ury > lry) ? ury : lry
-                                   : (lly > lry) ? lly : lry;
-  if ((clipRes = state->clip->testRect(xMin, yMin, xMax, yMax))
-      == splashClipAllOutside) {
-    return splashOk;
-  }
-
-  if (!noClipPath || clipRes == splashClipAllInside) {
-    if (!srcAlpha && !noShearImage) {
-      if (drawImageFastWithCTM(src,srcData,w,h,tx,ty,mat) == splashOk) {
-	  return splashOk;
-      }
-    }
-    if (!srcAlpha && splashRound(xShear) == 0 && splashRound(yShear) == 0) {
-      /* no sheared case */
-      if (drawImageNotShear(src,srcData,w,h,tx,ty,
-	   scaledWidth, scaledHeight,xSign,ySign,rot) == splashOk) {
-	  return splashOk;
-      }
-    }
-  }
-
-  /* shear case */
-  SplashError result = splashOk;
-
-  /* calculate inverse matrix */
-  SplashCoord imat[4];
-  double det = mat[0] * mat[3] - mat[1] * mat[2];
-  imat[0] = mat[3]/det;
-  imat[1] = -mat[1]/det;
-  imat[2] = -mat[2]/det;
-  imat[3] = mat[0]/det;
-
-  opvp_fix_t opvpx,opvpy;
-  int opvpbytes, linesize;
-  int width = xMax-xMin+1;
-  int height = yMax-yMin+1;
-  opvp_ctm_t opvpctm;
-
-  switch (colorMode) {
-  case splashModeMono1:
-  case splashModeMono8:
-    if (srcAlpha) {
-      /*  alpha data exists */
-      linesize = w*2;
-    } else {
-      linesize = w;
-    }
-    opvpbytes = (width+3)/4;
-    opvpbytes *= 4;
-    break;
-  case splashModeRGB8:
-    if (srcAlpha) {
-      /* alpha data exists */
-      linesize = w*4;
-    } else {
-      linesize = w*3;
-    }
-    opvpbytes = (width*3+3)/4;
-    opvpbytes *= 4;
-    break;
-  default:
-    OPRS::error("Image: no supported color mode\n");
-    return splashErrOPVP;
-    break;
-  }
-
-  /* read source image */
-  pixBuf = (SplashColorPtr)gmallocn(h , linesize);
-
-  p = pixBuf;
-  for (i = 0; i < h; ++i) {
-    (*src)(srcData, p, NULL);
-    p += linesize;
-  }
-  /* allocate line buffer */
-  Guchar *lineBuf = (Guchar *)gmallocn(opvpbytes,1);
-  Guchar *onBuf = (Guchar *)gmallocn(width,1);
-  OPVPSplashClip *clip;
-  opvpctm.a = 1.0;
-  opvpctm.b = 0.0;
-  opvpctm.c = 0.0;
-  opvpctm.d = 1.0;
-
-  clip = state->clip->copy();
-  if (w < scaledWidth || h < scaledHeight) {
-    OPVPSplashPath cpath;
-
-    cpath.moveTo(tx,ty);
-    cpath.lineTo(mat[0]+tx,mat[1]+ty);
-    cpath.lineTo(mat[0]+mat[2]+tx,mat[1]+mat[3]+ty);
-    cpath.lineTo(mat[2]+tx,mat[3]+ty);
-    clip->clipToPath(&cpath,state->matrix,1.0,false);
-  }
-  for (y = 0;y < height;y++) {
-    int dy = y+yMin-ty;
-    memset(onBuf,0,width);
-    if (srcAlpha) {
-      /* with alpha data */
-      for (x = 0;x < width;x++) {
-	if (!clip->test(x+xMin,y+yMin)) continue;
-	int ox,oy;
-	/* calculate original coordinate */
-	int dx = x+xMin-tx;
-	ox = (int)trunc((imat[0]*dx+imat[2]*dy)*w);
-	oy = (int)trunc((imat[1]*dx+imat[3]*dy)*h);
-	if (ox >= 0 && ox < w && oy >= 0 && oy < h) {
-	  /* in the image */
-
-	  switch (colorMode) {
-	  case splashModeMono1:
-	  case splashModeMono8:
-	    onBuf[x] =  pixBuf[oy*linesize+ox] != 0;
-	    lineBuf[x] = pixBuf[oy*linesize+ox+1];
-	    break;
-	  case splashModeRGB8:
-	    p = pixBuf+oy*linesize+ox*4;
-	    onBuf[x] =  (*p++) != 0;
-	    lineBuf[x*3] = *p++;
-	    lineBuf[x*3+1] = *p++;
-	    lineBuf[x*3+2] = *p;
-	    break;
-	  default:
-	    OPRS::error("Image: no supported color mode\n");
-	    result = splashErrOPVP;
-	    goto err1;
-	    break;
-	  }
-	}
-      }
-    } else {
-      for (x = 0;x < width;x++) {
-	if (!clip->test(x+xMin,y+yMin)) continue;
-	int ox,oy;
-	/* calculate original coordinate */
-	int dx = x+xMin-tx;
-	ox = (int)trunc((imat[0]*dx+imat[2]*dy)*w);
-	oy = (int)trunc((imat[1]*dx+imat[3]*dy)*h);
-	if (ox >= 0 && ox < w && oy >= 0 && oy < h) {
-	  /* in the image */
-
-	  switch (colorMode) {
-	  case splashModeMono1:
-	  case splashModeMono8:
-	    lineBuf[x] = pixBuf[oy*linesize+ox];
-	    break;
-	  case splashModeRGB8:
-	    p = pixBuf+oy*linesize+ox*3;
-	    lineBuf[x*3] = *p++;
-	    lineBuf[x*3+1] = *p++;
-	    lineBuf[x*3+2] = *p;
-	    break;
-	  default:
-	    OPRS::error("Image: no supported color mode\n");
-	    result = splashErrOPVP;
-	    goto err1;
-	    break;
-	  }
-	  onBuf[x] = 1;
-	}
-      }
-    }
-    /* out pixel */
-    int sx = 0;
-    int ex;
-    while (sx < width) {
-      /* find start pixel */
-      for (;onBuf[sx] == 0 && sx < width;sx++);
-      if (sx >= width) break;
-      /* find end pixel */
-      for (ex = sx+1;onBuf[ex] != 0 && ex < width;ex++);
-      int n = ex-sx;
-      Guchar *bp;
-      int ns;
-
-      switch (colorMode) {
-      case splashModeMono1:
-      case splashModeMono8:
-	bp = lineBuf+sx;
-	ns = n;
-	break;
-      case splashModeRGB8:
-	bp = lineBuf+sx*3;
-	ns = n*3;
-	break;
-      default:
-	OPRS::error("Image: no supported color mode\n");
-	result = splashErrOPVP;
-	goto err1;
-	break;
-      }
-      ns = (ns+3)/4;
-      ns *= 4;
-
-      OPVP_i2Fix(xMin+sx,(opvpx));
-      OPVP_i2Fix(yMin+y,(opvpy));
-      if (opvp->SetCurrentPoint(opvpx,opvpy) < 0) {
-	OPRS::error("SetCurrentPoint error\n");
-	result = splashErrOPVP;
-	goto err1;
-      }
-      /* canonlisp driver use CTM only, ignores currentPoint */
-      /* So, set start point to CTM */
-      opvpctm.e = xMin+sx;
-      opvpctm.f = yMin+y;
-      if (opvp->SetCTM(&opvpctm) < 0) {
-	OPRS::error("SetCTM error\n");
-      }
-
-      if (opvp->DrawImage(n,1,ns,OPVP_IFORMAT_RAW,
-	   n,1,(void *)(bp)) < 0) {
-	OPRS::error("DrawImage error\n");
-	result = splashErrOPVP;
-	goto err1;
-      }
-
-      /* reset CTM */
-      opvpctm.e = 0.0;
-      opvpctm.f = 0.0;
-      if (opvp->SetCTM(&opvpctm) < 0) {
-	OPRS::error("SetCTM error\n");
-      }
-
-      sx = ex+1;
-    }
-  }
-
-
-err1:
-  delete clip;
-  gfree(pixBuf);
-  gfree(lineBuf);
-  gfree(onBuf);
-  return result;
-}
-
-void OPVPSplash::setColorMode(int colorModeA)
-{
-    colorMode = colorModeA;
-}
-
-void OPVPSplash::drawSpan(int x0, int x1, int y, bool noClip)
-{
-  int s,e;
-  opvp_point_t points[1];
-  opvp_fix_t opvpx, opvpy;
-  SplashCoord *savedLineDash = 0;
-  int savedLineDashLength;
-  SplashCoord savedLineDashPhase;
-  SplashCoord savedLineWidth;
-  bool noSpan;
-
-
-  if (opvp->NewPath() < 0) {
-    OPRS::error("NewPath error\n");
-    return;
-  }
-  if (noClip) {
-    noSpan = false;
-    OPVP_i2Fix(x0,opvpx);
-    OPVP_i2Fix(y,opvpy);
-    if (opvp->SetCurrentPoint(opvpx,opvpy) < 0) {
-      OPRS::error("SetCurrentPoint error\n");
-      return;
-    }
-    OPVP_i2Fix(x1+1,points[0].x);
-    OPVP_i2Fix(y,points[0].y);
-    if (opvp->LinePath(OPVP_PATHOPEN,1,points) < 0) {
-      OPRS::error("LinePath error\n");
-      return;
-    }
-  } else {
-    noSpan = true;
-    s = x0;
-    while (s < x1) {
-      /* find start point */
-      for (;s < x1;s++) {
-	if (state->clip->test(s, y)) break;
-      }
-      if (s < x1) {
-	/* start point was found */
-	/* then find end point */
-	for (e = s+1;e < x1;e++) {
-	  if (!state->clip->test(e, y)) break;
-	}
-	/* do make span */
-	noSpan = false;
-	OPVP_i2Fix(s,opvpx);
-	OPVP_i2Fix(y,opvpy);
-	if (opvp->SetCurrentPoint(opvpx,opvpy) < 0) {
-	  OPRS::error("SetCurrentPoint error\n");
-	  return;
-	}
-	OPVP_i2Fix(e,points[0].x);
-	OPVP_i2Fix(y,points[0].y);
-	if (opvp->LinePath(OPVP_PATHOPEN,1,points) < 0) {
-	  OPRS::error("LinePath error\n");
-	  return;
-	}
-	s = e;
-      }
-    }
-  }
-  if (opvp->EndPath() < 0) {
-    OPRS::error("EndPath error\n");
-    return;
-  }
-  if (noSpan) return;
-  /* change lins style temporarily */
-  savedLineDashLength = state->lineDashLength;
-  savedLineDashPhase = state->lineDashPhase;
-  if (savedLineDashLength > 0 && state->lineDash != 0) {
-    savedLineDash = new SplashCoord[savedLineDashLength];
-    memcpy(savedLineDash, state->lineDash,
-      savedLineDashLength*sizeof(SplashCoord));
-  }
-  setLineDash(0,0,0);
-  savedLineWidth = state->lineWidth;
-  setLineWidth(0.0);
-
-  if (opvp->StrokePath() < 0) {
-    OPRS::error("StrokePath error\n");
-    return;
-  }
-
-  /* restore line style */
-  setLineDash(savedLineDash,savedLineDashLength,
-    savedLineDashPhase);
-  if (savedLineDash != 0) {
-    delete[] savedLineDash;
-  }
-  setLineWidth(savedLineWidth);
-}
-
-/*
-  draw pixel with StrokePath
-  color is stroke color
-*/
-void OPVPSplash::drawPixel(int x, int y, bool noClip)
-{
-  opvp_point_t points[1];
-  opvp_fix_t opvpx, opvpy;
-
-  if (noClip || state->clip->test(x, y)) {
-    if (opvp->NewPath() < 0) {
-      OPRS::error("NewPath error\n");
-      return;
-    }
-    OPVP_i2Fix(x,opvpx);
-    OPVP_i2Fix(y,opvpy);
-    if (opvp->SetCurrentPoint(opvpx,opvpy) < 0) {
-      OPRS::error("NewPath error\n");
-      return;
-    }
-    OPVP_i2Fix(x+1,points[0].x);
-    OPVP_i2Fix(y,points[0].y);
-    if (opvp->LinePath(OPVP_PATHOPEN,1,points) < 0) {
-      OPRS::error("LinePath error\n");
-      return;
-    }
-    if (opvp->EndPath() < 0) {
-      OPRS::error("EndPath error\n");
-      return;
-    }
-    if (opvp->StrokePath() < 0) {
-      OPRS::error("StrokePath error\n");
-      return;
-    }
-  }
-}
-
-const char *OPVPSplash::getOption(const char *key, int nOptions,
-  const char *optionKeys[], const char *optionVals[])
-{
-  int i;
-
-  for (i = 0;i < nOptions;i++) {
-    if (strcmp(key,optionKeys[i]) == 0) {
-      return optionVals[i];
-    }
-  }
-  return 0;
-}
-
-void OPVPSplash::endPage()
-{
-  if (clipPath != 0) {
-    delete clipPath;
-    clipPath = 0;
-  }
-}
-
-void OPVPSplash::restoreAllDriverState()
-{
-  for (;saveDriverStateCount > 0;saveDriverStateCount--) {
-    opvp->RestoreGS();
-  }
-}
-
-SplashCoord *OPVPSplash::getMatrix()
-{
-    return state->matrix;
-}
-
-OPVPClipPath *OPVPClipPath::stackTop = 0;
-
-OPVPClipPath::OPVPClipPath(OPVPSplashPath *pathA, bool eoA)
-{
-  path = pathA;
-  eo = eoA;
-  next = 0;
-  saved = false;
-}
-
-void OPVPClipPath::push()
-{
-  OPVPClipPath *p;
-
-  p = stackTop;
-  stackTop = copy();
-  stackTop->next = p;
-  saved = true;
-}
-
-OPVPClipPath *OPVPClipPath::pop() {
-  OPVPClipPath *p = stackTop;
-  if (stackTop != 0) stackTop = stackTop->next;
-  return p;
-}
-
-OPVPClipPath *OPVPClipPath::copy()
-{
-  OPVPClipPath *p;
-
-  p = new OPVPClipPath(path->copy(),eo);
-  p->saved = saved;
-  return p;
-}
diff --git a/filter/pdftoopvp/oprs/OPVPSplash.h b/filter/pdftoopvp/oprs/OPVPSplash.h
deleted file mode 100644
index 200fda3..0000000
--- a/filter/pdftoopvp/oprs/OPVPSplash.h
+++ /dev/null
@@ -1,244 +0,0 @@
-//========================================================================
-//
-// OPVPSplash.h
-//
-//========================================================================
-
-#ifndef OPVPSPLASH_H
-#define OPVPSPLASH_H
-
-#include <config.h>
-
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
-#include <typeinfo>
-#include "splash/SplashTypes.h"
-#include "splash/SplashPattern.h"
-#include "splash/SplashErrorCodes.h"
-#include "OPVPSplashPath.h"
-#include "OPVPWrapper.h"
-#include "CharTypes.h"
-
-/* extra error code */
-#define splashErrOPVP 100
-
-#define OPVP_MAX_CLIPPATH_LENGTH 2000
-#define OPVP_MAX_FILLPATH_LENGTH 4000
-#define OPVP_BITMAPCHAR_THRESHOLD 2000
-#define OPVP_ROP_SRCCOPY 0xCC
-#define OPVP_ROP_S 0xCC
-#define OPVP_ROP_P 0xF0
-#define OPVP_ROP_PSDPxax 0xB8
-#define OPVP_ROP_DSPDxax 0xE2
-
-class SplashBitmap;
-class SplashGlyphBitmap;
-class OPVPSplashState;
-class SplashPattern;
-class SplashScreen;
-class OPVPSplashPath;
-class OPVPSplashXPath;
-class OPVPSplashClip;
-class SplashFont;
-
-class OPVPClipPath {
-public:
-  OPVPClipPath(OPVPSplashPath *pathA, bool eoA);
-  void push();
-  static OPVPClipPath *pop();
-  ~OPVPClipPath() { delete path; }
-  OPVPSplashPath *getPath() { return path; }
-  bool getEo() { return eo; }
-  bool getSaved() { return saved; }
-private:
-  OPVPClipPath *copy();
-  OPVPClipPath *next;
-  OPVPSplashPath *path;
-  bool eo;
-  bool saved;
-  static OPVPClipPath *stackTop;
-};
-
-//------------------------------------------------------------------------
-// Splash
-//------------------------------------------------------------------------
-
-class OPVPSplash {
-public:
-
-  // Create a new rasterizer object.
-  OPVPSplash(OPVPWrapper *opvpA,
-    int nOptions, const char *optionKeys[], const char *optionVals[]);
-
-  virtual ~OPVPSplash();
-
-  //----- state read
-
-  SplashPattern *getStrokePattern();
-  SplashPattern *getFillPattern();
-  SplashScreen *getScreen();
-  SplashCoord getLineWidth();
-  int getLineCap();
-  int getLineJoin();
-  SplashCoord getMiterLimit();
-  SplashCoord getFlatness();
-  SplashCoord *getLineDash();
-  int getLineDashLength();
-  SplashCoord getLineDashPhase();
-  OPVPSplashClip *getClip();
-
-  //----- state write
-
-  void setStrokePattern(SplashPattern *strokeColor);
-  void setFillPattern(SplashPattern *fillColor);
-  void setScreen(SplashScreen *screen);
-  void setLineWidth(SplashCoord lineWidth);
-  void setLineCap(int lineCap);
-  void setLineJoin(int lineJoin);
-  void setMiterLimit(SplashCoord miterLimit);
-  void setFlatness(SplashCoord flatness);
-  // the <lineDash> array will be copied
-  void setLineDash(SplashCoord *lineDash, int lineDashLength,
-		   SplashCoord lineDashPhase);
-  void clipResetToRect(SplashCoord x0, SplashCoord y0,
-		       SplashCoord x1, SplashCoord y1);
-  SplashError clipToPath(OPVPSplashPath *path, bool eo);
-
-  //----- state save/restore
-
-  void saveState();
-  SplashError restoreState();
-  void restoreAllDriverState();
-
-  //----- drawing operations
-
-  // Fill the bitmap with <color>.  This is not subject to clipping.
-  void clear(SplashColor color);
-
-  // Stroke a path using the current stroke pattern.
-  SplashError stroke(OPVPSplashPath *path);
-
-  // Fill a path using the current fill pattern.
-  SplashError fill(OPVPSplashPath *path, bool eo);
-
-  // Draw a character, using the current fill pattern.
-  SplashError fillChar(SplashCoord x, SplashCoord y, int c,
-    SplashFont *font, Unicode *u, double *fontMat);
-
-  // Draw a glyph, using the current fill pattern.  This function does
-  // not free any data, i.e., it ignores glyph->freeData.
-  // not used in vector mode
-  void fillGlyph(SplashCoord x, SplashCoord y,
-			SplashGlyphBitmap *glyph);
-
-  // Draws an image mask using the fill color.  This will read <w>*<h>
-  // pixels from <src>, in raster order, starting with the top line.
-  // "1" pixels will be drawn with the current fill color; "0" pixels
-  // are transparent.  The matrix:
-  //    [ mat[0] mat[1] 0 ]
-  //    [ mat[2] mat[3] 0 ]
-  //    [ mat[4] mat[5] 1 ]
-  // maps a unit square to the desired destination for the image, in
-  // PostScript style:
-  //    [x' y' 1] = [x y 1] * mat
-  // Note that the Splash y axis points downward, and the image source
-  // is assumed to produce pixels in raster order, starting from the
-  // top line.
-  SplashError fillImageMask(SplashImageMaskSource src, void *srcData,
-			    int w, int h, SplashCoord *mat, bool glyphMode);
-
-  // Draw an image.  This will read <w>*<h> pixels from <src>, in
-  // raster order, starting with the top line.  These pixels are
-  // assumed to be in the source mode, <srcMode>.  The following
-  // combinations of source and target modes are supported:
-  //    source       target
-  //    ------       ------
-  //    Mono1        Mono1
-  //    Mono8        Mono1   -- with dithering
-  //    Mono8        Mono8
-  //    RGB8         RGB8
-  //    BGR8packed   BGR8Packed
-  // The matrix behaves as for fillImageMask.
-  SplashError drawImage(SplashImageSource src, void *srcData,
-			SplashColorMode srcMode, bool srcAlpha,
-			int w, int h, SplashCoord *mat);
-
-  //~ drawMaskedImage
-
-  //----- misc
-
-  // Return the associated bitmap.
-  SplashBitmap *getBitmap() { return 0; }
-
-  // Toggle debug mode on or off.
-  void setDebugMode(bool debugModeA) { debugMode = debugModeA; }
-
-  void setColorMode(int colorModeA);
-  void setStateBypass(bool bypass) {stateBypass = bypass;}
-  void endPage();
-  SplashCoord *getMatrix();
-  void drawSpan(int x0, int x1, int y, bool noClip);
-#ifdef OLD_DRAW_IMAGE
-  void drawPixel(int x, int y, SplashColor *color, bool noClip);
-#endif
-  void drawPixel(int x, int y, bool noClip);
-  void arcToCurve(SplashCoord x0, SplashCoord y0,
-    SplashCoord x3, SplashCoord y3,
-    SplashCoord cx, SplashCoord cy, SplashCoord *rx1, SplashCoord *ry1,
-    SplashCoord *rx2, SplashCoord *ry2);
-
-private:
-  void makeBrush(SplashPattern *pattern, opvp_brush_t *brush);
-  SplashError doClipPath(OPVPSplashPath *path, bool eo,
-     OPVPClipPath *prevClip);
-  opvp_cspace_t getOPVPColorSpace();
-  bool equalPattern(SplashPattern *pt1, SplashPattern *pt2);
-  SplashError makeRectanglePath(SplashCoord x0, SplashCoord y0,
-    SplashCoord x1, SplashCoord y1, OPVPSplashPath **p);
-  SplashError drawImageFastWithCTM(SplashImageSource src, void *srcData,
-			      int w, int h, int tx, int ty,
-			      SplashCoord *mat);
-  SplashError drawImageNotShear(SplashImageSource src,
-                              void *srcData,
-			      int w, int h,
-			      int tx, int ty,
-			      int scaledWidth, int scaledHeight,
-			      int xSign, int ySign, bool rot);
-  SplashError fillImageMaskFastWithCTM(SplashImageMaskSource src,
-       void *srcData, int w, int h, int tx, int ty,SplashCoord *mat);
-  SplashError strokeByMyself(OPVPSplashPath *path);
-  SplashError fillByMyself(OPVPSplashPath *path, bool eo);
-  OPVPSplashXPath *makeDashedPath(OPVPSplashXPath *xPath);
-  void transform(SplashCoord *matrix, SplashCoord xi, SplashCoord yi,
-	   SplashCoord *xo, SplashCoord *yo);
-
-  const char *getOption(const char *key, int nOptions, const char *optionKeys[],
-    const char *optionVals[]);
-
-  OPVPWrapper *opvp;
-  int printerContext;
-
-  OPVPSplashState *state;
-  bool debugMode;
-  int colorMode;
-  bool stateBypass;
-  OPVPClipPath *clipPath;
-
-  bool oldLipsDriver;
-  bool clipPathNotSaved;
-  bool noShearImage;
-  bool noLineStyle;
-  bool noClipPath;
-  bool noMiterLimit;
-  bool ignoreMiterLimit;
-  bool savedNoClipPath;
-  bool noImageMask;
-  int bitmapCharThreshold;
-  int maxClipPathLength;
-  int maxFillPathLength;
-  int saveDriverStateCount;
-};
-
-#endif
diff --git a/filter/pdftoopvp/oprs/OPVPSplashClip.cxx b/filter/pdftoopvp/oprs/OPVPSplashClip.cxx
deleted file mode 100644
index d81fd3f..0000000
--- a/filter/pdftoopvp/oprs/OPVPSplashClip.cxx
+++ /dev/null
@@ -1,103 +0,0 @@
-#include <config.h>
-
-#ifdef HAVE_CPP_POPPLER_VERSION_H
-#include "cpp/poppler-version.h"
-#endif
-
-#include "splash/SplashXPathScanner.h"
-#include "OPVPSplashClip.h"
-
-void OPVPSplashClip::getBBox(int *xMinA, int *yMinA, int *xMaxA, int *yMaxA)
-{
-  int i;
-  int cxMin = splashRound(xMin), cyMin = splashRound(yMin);
-  int cxMax = splashRound(xMax), cyMax = splashRound(yMax);
-  int txMin, tyMin, txMax, tyMax;
-
-  for (i = 0; i < length; ++i) {
-    scanners[i]->getBBox(&txMin,&tyMin,&txMax,&tyMax);
-    if (txMin > cxMin) cxMin = txMin;
-    if (tyMin > cyMin) cyMin = tyMin;
-    if (txMax < cxMax) cxMax = txMax;
-    if (tyMax < cyMax) cyMax = tyMax;
-  }
-  *xMinA = cxMin;
-  *yMinA = cyMin;
-  *xMaxA = cxMax;
-  *yMaxA = cyMax;
-}
-
-OPVPSplashPath *OPVPSplashClip::makePath()
-{
-  int i,j;
-  int y, x0, x1;
-  int txMin, tyMin, txMax, tyMax;
-  Guchar *cbuf,*tbuf;
-  int blen;
-  OPVPSplashPath *p = new OPVPSplashPath();
-
-  getBBox(&txMin,&tyMin,&txMax,&tyMax);
-  if (txMin > txMax || tyMin > tyMax) return p;
-  blen = txMax-txMin+1;
-  cbuf = new Guchar[blen];
-  tbuf = new Guchar[blen];
-
-  for (y = tyMin;y <= tyMax;y++) {
-    /* clear buffer */
-    for (i = 0;i < blen;i++) {
-      cbuf[i] = 0;
-    }
-#if POPPLER_VERSION_MAJOR > 0 || POPPLER_VERSION_MINOR >= 70
-    SplashXPathScanIterator iterator(*scanners[0], y);
-    while (iterator.getNextSpan(&x0, &x1))
-#else
-    while (scanners[0]->getNextSpan(y,&x0,&x1))
-#endif
-    {
-      if (x0 < txMin) x0 = txMin;
-      if (x1 > txMax) x1 = txMax;
-      for (i = x0;i < x1;i++) {
-	cbuf[i-txMin] = 1;
-      }
-    }
-    for (j = 1; j < length; ++j) {
-      /* clear buffer */
-      for (i = 0;i < blen;i++) {
-	tbuf[i] = 0;
-      }
-#if POPPLER_VERSION_MAJOR > 0 || POPPLER_VERSION_MINOR >= 70
-      SplashXPathScanIterator iterator2(*scanners[j], y);
-      while (iterator2.getNextSpan(&x0, &x1))
-#else
-      while (scanners[j]->getNextSpan(y,&x0,&x1))
-#endif
-      {
-	if (x0 < txMin) x0 = txMin;
-	if (x1 > txMax) x1 = txMax;
-	for (i = x0;i < x1;i++) {
-	  tbuf[i-txMin] = 1;
-	}
-      }
-      /* and buffer */
-      for (i = 0;i < blen;i++) {
-	cbuf[i] &= tbuf[i];
-      }
-    }
-    /* scan buffer and add path */
-    for (i = 0;i < blen;i = j) {
-      if (cbuf[i] != 0) {
-	p->moveTo(i+txMin,y);
-	for (j = i+1;j < blen && cbuf[j] != 0;j++);
-	p->lineTo(j-1+txMin,y);
-	p->lineTo(j-1+txMin,y+1);
-	p->lineTo(i+txMin,y+1);
-	p->close();
-      } else {
-	j = i+1;
-      }
-    }
-  }
-  delete[] cbuf;
-  delete[] tbuf;
-  return p;
-}
diff --git a/filter/pdftoopvp/oprs/OPVPSplashClip.h b/filter/pdftoopvp/oprs/OPVPSplashClip.h
deleted file mode 100644
index 05bd57b..0000000
--- a/filter/pdftoopvp/oprs/OPVPSplashClip.h
+++ /dev/null
@@ -1,30 +0,0 @@
-#ifndef OPVPSPLASHCLIP_H
-#define OPVPSPLASHCLIP_H
-
-#include "splash/SplashClip.h"
-#include "OPVPSplashPath.h"
-
-class OPVPSplashClip : public SplashClip {
-public:
-
-  OPVPSplashClip(SplashCoord x0, SplashCoord y0,
-               SplashCoord x1, SplashCoord y1,
-	                    bool antialiasA) :
-     SplashClip(x0,y0,x1,y1,antialiasA) {
-  }
-
-  OPVPSplashClip(SplashClip *sclip) : SplashClip(sclip) {
-  }
-
-  OPVPSplashClip *copy() { return new OPVPSplashClip(this); }
-
-  ~OPVPSplashClip() {}
-  
-  void getBBox(int *xMinA, int *yMinA, int *xMaxA, int *yMaxA);
-  OPVPSplashPath *makePath();
-private:
-  OPVPSplashClip(OPVPSplashClip *clip) : SplashClip(clip) {
-  }
-};
-
-#endif
diff --git a/filter/pdftoopvp/oprs/OPVPSplashPath.cxx b/filter/pdftoopvp/oprs/OPVPSplashPath.cxx
deleted file mode 100644
index f03c128..0000000
--- a/filter/pdftoopvp/oprs/OPVPSplashPath.cxx
+++ /dev/null
@@ -1,185 +0,0 @@
-#include <config.h>
-#include <stdio.h>
-#include "splash/SplashMath.h"
-#include "OPVPSplashPath.h"
-#include "OPVPWrapper.h"
-#include "OPRS.h"
-
-void OPVPSplashPath::getBBox(int *xMinA, int *yMinA, int *xMaxA,
-    int *yMaxA)
-{
-  int i;
-  SplashCoord xMin, yMin, xMax, yMax;
-
-  if (length <= 0) {
-    /* return far away point */
-    *xMinA = *yMinA = *xMaxA = *yMaxA = 0xC0000000;
-    return;
-  }
-  xMin = xMax = pts[0].x;
-  yMin = yMax = pts[0].y;
-  for (i = 1;i < length;i++) {
-    if (pts[i].x > xMax) {
-      xMax = pts[i].x;
-    } else if (pts[i].x < xMin) {
-      xMin = pts[i].x;
-    }
-    if (pts[i].y > yMax) {
-      yMax = pts[i].y;
-    } else if (pts[i].y < yMin) {
-      yMin = pts[i].y;
-    }
-  }
-  *xMinA = splashRound(xMin);
-  *xMaxA = splashRound(xMax);
-  *yMinA = splashRound(yMin);
-  *yMaxA = splashRound(yMax);
-}
-
-bool OPVPSplashPath::isRectanglePath(
-  SplashCoord *xMin, SplashCoord *yMin, SplashCoord *xMax, SplashCoord *yMax)
-{
-  if (length != 5
-      || pts[0].x != pts[4].x
-      || pts[0].y != pts[4].y
-      || flags[0] != (splashPathFirst | splashPathClosed)
-      || flags[1] != 0
-      || flags[2] != 0
-      || flags[3] != 0
-      || flags[4] != (splashPathLast | splashPathClosed)) {
-    return false;
-  }
-  if (splashRound(pts[0].x) == splashRound(pts[1].x)) {
-    if (splashRound(pts[1].y) != splashRound(pts[2].y)
-      || splashRound(pts[2].x) != splashRound(pts[3].x)
-      || splashRound(pts[3].y) != splashRound(pts[4].y)) {
-      return false;
-    }
-  } else if (splashRound(pts[0].y) == splashRound(pts[1].y)) {
-    if (splashRound(pts[1].x) != splashRound(pts[2].x)
-      || splashRound(pts[2].y) != splashRound(pts[3].y)
-      || splashRound(pts[3].x) != splashRound(pts[4].x)) {
-      return false;
-    }
-  } else {
-    return false;
-  }
-  *xMin = pts[0].x;
-  *yMin = pts[0].y;
-  *xMax = pts[2].x;
-  *yMax = pts[2].y;
-  if (*xMin > *xMax) {
-    SplashCoord t = *xMin;
-
-    *xMin = *xMax;
-    *xMax = t;
-  }
-  if (*yMin > *yMax) {
-    SplashCoord t = *yMin;
-
-    *yMin = *yMax;
-    *yMax = t;
-  }
-  return true;
-}
-
-SplashError OPVPSplashPath::makePath(OPVPWrapper *opvp)
-{
-  int i,j;
-  opvp_fix_t x,y;
-
-  if (opvp->NewPath() < 0) {
-    OPRS::error("NewPath error\n");
-    return splashErrOPVP;
-  }
-  for (i = 0;i < length;i = j) {
-    int curve = 0; 
-    int n;
-    opvp_point_t *points;
-    int k;
-
-    if ((flags[i] & splashPathFirst) != 0) {
-      /* first point of a subpath */
-      if ((flags[i] & splashPathLast) == 0
-          || (flags[i] & splashPathClosed) != 0) {
-	OPVP_F2FIX((pts[i].x),(x));
-	OPVP_F2FIX((pts[i].y),(y));
-	if (opvp->SetCurrentPoint(x,y) < 0) {
-	  OPRS::error("SetCurrentPoint error\n");
-	  return splashErrOPVP;
-	}
-      }
-      j = i+1;
-      continue;
-    }
-    if (i+2 < length && flags[i] == splashPathCurve) {
-      /* curve */
-      curve = 1;
-      for (j = i;j+2 < length
-	 && flags[j] == splashPathCurve;j += 3);
-    } else {
-      curve = 0;
-      for (j = i;j < length
-	 && (flags[j] & splashPathCurve) == 0
-	 && (flags[j] & splashPathFirst) == 0;j++);
-    }
-
-    n = j-i;
-    points = new opvp_point_t[n];
-    /* copy points */
-    for (k = i; k < j;k++) {
-      OPVP_F2FIX((pts[k].x),(points[k-i].x));
-      OPVP_F2FIX((pts[k].y),(points[k-i].y));
-    }
-
-    if (curve) {
-      /* curve */
-      if (opvp->BezierPath(n,points) < 0) {
-	OPRS::error("BezierPath error\n");
-	return splashErrOPVP;
-      }
-    } else {
-      /* line */
-      bool closed = (flags[j-1] & splashPathClosed) != 0;
-
-      if (closed) {
-	if (opvp->LinePath(OPVP_PATHCLOSE,
-	      n,points) < 0) {
-	  OPRS::error("LinePath error\n");
-	  return splashErrOPVP;
-	}
-      } else {
-	if (opvp->LinePath(OPVP_PATHOPEN,
-	      n,points) < 0) {
-	  OPRS::error("LinePath error\n");
-	  return splashErrOPVP;
-	}
-      }
-    }
-    delete[] points;
-  }
-  if (opvp->EndPath() < 0) {
-    OPRS::error("EndPath error\n");
-    return splashErrOPVP;
-  }
-  return splashOk;
-}
-
-void OPVPSplashPath::closeAllSubPath()
-{
-  int i;
-  int f = 0;
-
-  for (i = 0;i < length;i++) {
-    if ((flags[i] & splashPathFirst) != 0) {
-      f = i;
-    }
-    if ((flags[i] & splashPathLast) != 0) {
-      if (pts[f].x == pts[i].x
-        && pts[f].y == pts[i].y) {
-	flags[f] |= splashPathClosed;
-	flags[i] |= splashPathClosed;
-      }
-    }
-  }
-}
diff --git a/filter/pdftoopvp/oprs/OPVPSplashPath.h b/filter/pdftoopvp/oprs/OPVPSplashPath.h
deleted file mode 100644
index 38bfeff..0000000
--- a/filter/pdftoopvp/oprs/OPVPSplashPath.h
+++ /dev/null
@@ -1,28 +0,0 @@
-#ifndef OPVPSPLASHPATH_H
-#define OPVPSPLASHPATH_H
-
-#include "splash/SplashPath.h"
-#include "OPVPWrapper.h"
-
-class OPVPSplashPath : public SplashPath {
-public:
-
-  OPVPSplashPath() {};
-
-  OPVPSplashPath(SplashPath *spath) : SplashPath(spath) {
-  }
-
-  // Copy a path.
-  OPVPSplashPath *copy() { return new OPVPSplashPath(this); }
-  
-  void getBBox(int *xMinA, int *yMinA, int *xMaxA, int *yMaxA);
-  bool isRectanglePath(SplashCoord *xMin, SplashCoord *yMin,
-    SplashCoord *xMax, SplashCoord *yMax);
-  SplashError makePath(OPVPWrapper *opvp);
-  void closeAllSubPath();
-private:
-  OPVPSplashPath(OPVPSplashPath *path) : SplashPath(path) {
-  }
-};
-
-#endif
diff --git a/filter/pdftoopvp/oprs/OPVPSplashState.cxx b/filter/pdftoopvp/oprs/OPVPSplashState.cxx
deleted file mode 100644
index f5ba705..0000000
--- a/filter/pdftoopvp/oprs/OPVPSplashState.cxx
+++ /dev/null
@@ -1,176 +0,0 @@
-//========================================================================
-//
-// SplashState.cc
-//
-//========================================================================
-
-#include <config.h>
-
-#ifdef USE_GCC_PRAGMAS
-#pragma implementation
-#endif
-
-#include <string.h>
-#ifdef HAVE_CPP_POPPLER_VERSION_H
-#include "cpp/poppler-version.h"
-#endif
-#include "goo/gmem.h"
-#include "splash/SplashPattern.h"
-#include "splash/SplashScreen.h"
-#include "splash/SplashBitmap.h"
-#include "splash/SplashState.h"
-#include "OPVPSplashState.h"
-#include "OPVPSplashClip.h"
-
-//------------------------------------------------------------------------
-// SplashState
-//------------------------------------------------------------------------
-
-OPVPSplashState::OPVPSplashState(int width, int height, bool vectorAntialias,
-			 SplashScreenParams *screenParams) {
-  SplashColor color;
-
-  matrix[0] = 1;  matrix[1] = 0;
-  matrix[2] = 0;  matrix[3] = 1;
-  matrix[4] = 0;  matrix[5] = 0;
-  memset(&color, 0, sizeof(SplashColor));
-  strokePattern = new SplashSolidColor(color);
-  fillPattern = new SplashSolidColor(color);
-  screen = new SplashScreen(screenParams);
-  blendFunc = NULL;
-  strokeAlpha = 1;
-  fillAlpha = 1;
-  lineWidth = 0;
-  lineCap = splashLineCapButt;
-  lineJoin = splashLineJoinMiter;
-  miterLimit = 10;
-  flatness = 1;
-  lineDash = NULL;
-  lineDashLength = 0;
-  lineDashPhase = 0;
-  strokeAdjust = false;
-  clip = new OPVPSplashClip(0, 0, width - 0.001,
-               height - 0.001, vectorAntialias);
-  softMask = NULL;
-  deleteSoftMask = false;
-  inNonIsolatedGroup = false;
-  next = NULL;
-}
-
-OPVPSplashState::OPVPSplashState(int width, int height, bool vectorAntialias,
-			 SplashScreen *screenA) {
-  SplashColor color;
-
-  matrix[0] = 1;  matrix[1] = 0;
-  matrix[2] = 0;  matrix[3] = 1;
-  matrix[4] = 0;  matrix[5] = 0;
-  memset(&color, 0, sizeof(SplashColor));
-  strokePattern = new SplashSolidColor(color);
-  fillPattern = new SplashSolidColor(color);
-  screen = screenA->copy();
-  blendFunc = NULL;
-  strokeAlpha = 1;
-  fillAlpha = 1;
-  lineWidth = 0;
-  lineCap = splashLineCapButt;
-  lineJoin = splashLineJoinMiter;
-  miterLimit = 10;
-  flatness = 1;
-  lineDash = NULL;
-  lineDashLength = 0;
-  lineDashPhase = 0;
-  strokeAdjust = false;
-  clip = new OPVPSplashClip(0, 0, width - 0.001,
-               height - 0.001, vectorAntialias);
-  softMask = NULL;
-  deleteSoftMask = false;
-  inNonIsolatedGroup = false;
-  next = NULL;
-}
-
-OPVPSplashState::OPVPSplashState(OPVPSplashState *state) {
-  memcpy(matrix, state->matrix, 6 * sizeof(SplashCoord));
-  strokePattern = state->strokePattern->copy();
-  fillPattern = state->fillPattern->copy();
-  screen = state->screen->copy();
-  blendFunc = state->blendFunc;
-  strokeAlpha = state->strokeAlpha;
-  fillAlpha = state->fillAlpha;
-  lineWidth = state->lineWidth;
-  lineCap = state->lineCap;
-  lineJoin = state->lineJoin;
-  miterLimit = state->miterLimit;
-  flatness = state->flatness;
-  if (state->lineDash) {
-    lineDashLength = state->lineDashLength;
-    lineDash = (SplashCoord *)gmallocn(lineDashLength, sizeof(SplashCoord));
-    memcpy(lineDash, state->lineDash, lineDashLength * sizeof(SplashCoord));
-  } else {
-    lineDash = NULL;
-    lineDashLength = 0;
-  }
-  lineDashPhase = state->lineDashPhase;
-  strokeAdjust = state->strokeAdjust;
-  clip = state->clip->copy();
-  softMask = state->softMask;
-  deleteSoftMask = false;
-  inNonIsolatedGroup = state->inNonIsolatedGroup;
-  next = NULL;
-}
-
-OPVPSplashState::~OPVPSplashState() {
-  delete strokePattern;
-  delete fillPattern;
-  delete screen;
-  gfree(lineDash);
-  delete clip;
-  if (deleteSoftMask && softMask) {
-    delete softMask;
-  }
-}
-
-void OPVPSplashState::setState(Splash *osplash) {
-  osplash->setMatrix(matrix);
-  osplash->setFlatness(flatness);
-  osplash->setLineDash(lineDash,lineDashLength,lineDashPhase);
-  osplash->setLineCap(lineCap);
-  osplash->setStrokeAdjust(strokeAdjust);
-  osplash->setMiterLimit(miterLimit);
-  osplash->setLineJoin(lineJoin);
-}
-
-void OPVPSplashState::setStrokePattern(SplashPattern *strokePatternA) {
-  delete strokePattern;
-  strokePattern = strokePatternA;
-}
-
-void OPVPSplashState::setFillPattern(SplashPattern *fillPatternA) {
-  delete fillPattern;
-  fillPattern = fillPatternA;
-}
-
-void OPVPSplashState::setScreen(SplashScreen *screenA) {
-  delete screen;
-  screen = screenA;
-}
-
-void OPVPSplashState::setLineDash(SplashCoord *lineDashA, int lineDashLengthA,
-			      SplashCoord lineDashPhaseA) {
-  gfree(lineDash);
-  lineDashLength = lineDashLengthA;
-  if (lineDashLength > 0) {
-    lineDash = (SplashCoord *)gmallocn(lineDashLength, sizeof(SplashCoord));
-    memcpy(lineDash, lineDashA, lineDashLength * sizeof(SplashCoord));
-  } else {
-    lineDash = NULL;
-  }
-  lineDashPhase = lineDashPhaseA;
-}
-
-void OPVPSplashState::setSoftMask(SplashBitmap *softMaskA) {
-  if (deleteSoftMask) {
-    delete softMask;
-  }
-  softMask = softMaskA;
-  deleteSoftMask = true;
-}
diff --git a/filter/pdftoopvp/oprs/OPVPSplashState.h b/filter/pdftoopvp/oprs/OPVPSplashState.h
deleted file mode 100644
index dc91e51..0000000
--- a/filter/pdftoopvp/oprs/OPVPSplashState.h
+++ /dev/null
@@ -1,93 +0,0 @@
-//========================================================================
-//
-// OPVPSplashState.h
-//
-//========================================================================
-
-#ifndef OPVPSPLASHSTATE_H
-#define OPVPSPLASHSTATE_H
-
-#ifdef USE_GCC_PRAGMAS
-#pragma interface
-#endif
-
-#ifdef HAVE_CPP_POPPLER_VERSION_H
-#include "cpp/poppler-version.h"
-#endif
-#include "splash/SplashTypes.h"
-#include "splash/SplashState.h"
-#include "splash/Splash.h"
-
-class SplashPattern;
-class SplashScreen;
-class OPVPSplashClip;
-class SplashBitmap;
-
-//------------------------------------------------------------------------
-// SplashState
-//------------------------------------------------------------------------
-
-class OPVPSplashState {
-public:
-
-  // Create a new state object, initialized with default settings.
-  OPVPSplashState(int width, int height, bool vectorAntialias,
-	      SplashScreenParams *screenParams);
-  OPVPSplashState(int width, int height, bool vectorAntialias,
-	      SplashScreen *screenA);
-
-  // Copy a state object.
-  OPVPSplashState *copy() { return new OPVPSplashState(this); }
-
-  ~OPVPSplashState();
-
-  void setState(Splash *osplash);
-
-  // Set the stroke pattern.  This does not copy <strokePatternA>.
-  void setStrokePattern(SplashPattern *strokePatternA);
-
-  // Set the fill pattern.  This does not copy <fillPatternA>.
-  void setFillPattern(SplashPattern *fillPatternA);
-
-  // Set the screen.  This does not copy <screenA>.
-  void setScreen(SplashScreen *screenA);
-
-  // Set the line dash pattern.  This copies the <lineDashA> array.
-  void setLineDash(SplashCoord *lineDashA, int lineDashLengthA,
-		   SplashCoord lineDashPhaseA);
-
-  // Set the soft mask bitmap.
-  void setSoftMask(SplashBitmap *softMaskA);
-
-private:
-
-  OPVPSplashState(OPVPSplashState *state);
-
-  SplashCoord matrix[6];
-  SplashPattern *strokePattern;
-  SplashPattern *fillPattern;
-  SplashScreen *screen;
-  SplashBlendFunc blendFunc;
-  SplashCoord strokeAlpha;
-  SplashCoord fillAlpha;
-  SplashCoord lineWidth;
-  int lineCap;
-  int lineJoin;
-  SplashCoord miterLimit;
-  SplashCoord flatness;
-  SplashCoord *lineDash;
-  int lineDashLength;
-  SplashCoord lineDashPhase;
-  bool strokeAdjust;
-  OPVPSplashClip *clip;
-  SplashBitmap *softMask;
-  bool deleteSoftMask;
-  bool inNonIsolatedGroup;
-
-  OPVPSplashState *next;	// used by OPVPSplash class
-
-  friend class OPVPSplash;
-  friend class OPVPSplashXPath;
-};
-
-#endif
diff --git a/filter/pdftoopvp/oprs/OPVPSplashXPath.cxx b/filter/pdftoopvp/oprs/OPVPSplashXPath.cxx
deleted file mode 100644
index 53ca21d..0000000
--- a/filter/pdftoopvp/oprs/OPVPSplashXPath.cxx
+++ /dev/null
@@ -1,88 +0,0 @@
-#include <config.h>
-#include <stdio.h>
-#ifdef HAVE_CPP_POPPLER_VERSION_H
-#include "cpp/poppler-version.h"
-#endif
-#include "splash/Splash.h"
-#include "splash/SplashMath.h"
-#include "OPVPSplashClip.h"
-#include "OPVPSplashXPath.h"
-#include "OPVPWrapper.h"
-#include "OPVPSplash.h"
-
-void OPVPSplashXPath::strokeNarrow(OPVPSplash *splash, OPVPSplashState *state)
-{
-  SplashXPathSeg *seg;
-  int x0, x1, x2, x3, y0, y1, x, y, t;
-  SplashCoord dx, dy, dxdy;
-  SplashClipResult clipRes;
-  int i;
-
-  for (i = 0, seg = segs; i < length; ++i, ++seg) {
-
-    x0 = splashFloor(seg->x0);
-    x1 = splashFloor(seg->x1);
-    y0 = splashFloor(seg->y0);
-    y1 = splashFloor(seg->y1);
-
-    // horizontal segment
-    if (y0 == y1) {
-      if (x0 > x1) {
-	t = x0; x0 = x1; x1 = t;
-      }
-      if ((clipRes = state->clip->testSpan(x0, x1, y0))
-	  != splashClipAllOutside) {
-	splash->drawSpan(x0, x1, y0, clipRes == splashClipAllInside);
-      }
-
-    // segment with |dx| > |dy|
-    } else if (splashAbs(seg->dxdy) > 1) {
-      dx = seg->x1 - seg->x0;
-      dy = seg->y1 - seg->y0;
-      dxdy = seg->dxdy;
-      if (y0 > y1) {
-	t = y0; y0 = y1; y1 = t;
-	t = x0; x0 = x1; x1 = t;
-	dx = -dx;
-	dy = -dy;
-      }
-      if ((clipRes = state->clip->testRect(x0 <= x1 ? x0 : x1, y0,
-					   x0 <= x1 ? x1 : x0, y1))
-	  != splashClipAllOutside) {
-	if (dx > 0) {
-	  x2 = x0;
-	  for (y = y0; y < y1; ++y) {
-	    x3 = splashFloor(seg->x0 + (y + 1 - seg->y0) * dxdy);
-	    splash->drawSpan(x2, x3 - 1, y, clipRes == splashClipAllInside);
-	    x2 = x3;
-	  }
-	  splash->drawSpan(x2, x1, y, clipRes == splashClipAllInside);
-	} else {
-	  x2 = x0;
-	  for (y = y0; y < y1; ++y) {
-	    x3 = splashFloor(seg->x0 + (y + 1 - seg->y0) * dxdy);
-	    splash->drawSpan(x3 + 1, x2, y, clipRes == splashClipAllInside);
-	    x2 = x3;
-	  }
-	  splash->drawSpan(x1, x2, y, clipRes == splashClipAllInside);
-	}
-      }
-
-    // segment with |dy| > |dx|
-    } else {
-      dxdy = seg->dxdy;
-      if (y0 > y1) {
-	t = y0; y0 = y1; y1 = t;
-      }
-      if ((clipRes = state->clip->testRect(x0 <= x1 ? x0 : x1, y0,
-					   x0 <= x1 ? x1 : x0, y1))
-	  != splashClipAllOutside) {
-	for (y = y0; y <= y1; ++y) {
-	  x = splashFloor(seg->x0 + (y - seg->y0) * dxdy);
-	  splash->drawPixel(x, y, clipRes == splashClipAllInside);
-	}
-      }
-    }
-  }
-}
-
diff --git a/filter/pdftoopvp/oprs/OPVPSplashXPath.h b/filter/pdftoopvp/oprs/OPVPSplashXPath.h
deleted file mode 100644
index 2a07782..0000000
--- a/filter/pdftoopvp/oprs/OPVPSplashXPath.h
+++ /dev/null
@@ -1,32 +0,0 @@
-#ifndef OPVPSPLASHXPATH_H
-#define OPVPSPLASHXPATH_H
-
-#include <config.h>
-#ifdef HAVE_CPP_POPPLER_VERSION_H
-#include "cpp/poppler-version.h"
-#endif
-#include "splash/SplashXPath.h"
-#include "OPVPSplashPath.h"
-#include "OPVPSplashState.h"
-
-class OPVPSplash;
-
-class OPVPSplashXPath : public SplashXPath {
-public:
-  OPVPSplashXPath(OPVPSplashPath *path, SplashCoord *matrix,
-                SplashCoord flatness, bool closeSubpaths) :
-	SplashXPath(path,matrix,flatness,closeSubpaths) {
-  }
-
-  // Copy an expanded path.
-  OPVPSplashXPath *copy() { return new OPVPSplashXPath(this); }
-
-  OPVPSplashXPath *makeDashedPath(OPVPSplashState *state);
-  void strokeNarrow(OPVPSplash *splash, OPVPSplashState *state);
-private:
-  OPVPSplashXPath() : SplashXPath(new SplashPath(), 0, 0, false) {};
-  OPVPSplashXPath(OPVPSplashXPath *xPath) : SplashXPath(xPath) {
-  }
-};
-
-#endif
diff --git a/filter/pdftoopvp/oprs/OPVPWrapper.cxx b/filter/pdftoopvp/oprs/OPVPWrapper.cxx
deleted file mode 100644
index 3453e0d..0000000
--- a/filter/pdftoopvp/oprs/OPVPWrapper.cxx
+++ /dev/null
@@ -1,910 +0,0 @@
-/*
-  OPVPWrapper.cc
-*/
-
-
-#include <config.h>
-#include <stdio.h>
-#include "OPRS.h"
-#include "OPVPWrapper.h"
-#include "OPVPWrapper_0_2.h"
-#include <string.h>
-#include <dlfcn.h>
-
-OPVPWrapper::OPVPWrapper(void *opvpHandleA, opvp_int_t *opvpErrorNoA,
-  opvp_api_procs_t *procsA, opvp_dc_t printerContextA)
-{
-    procs = procsA;
-    opvpHandle = opvpHandleA;
-    opvpErrorNo = opvpErrorNoA;
-    printerContext = printerContextA;
-    version[0] = 1;
-    version[1] = 0;
-    supportClosePrinter = (procs->opvpClosePrinter != 0);
-    supportStartJob = (procs->opvpStartJob != 0);
-    supportEndJob = (procs->opvpEndJob != 0);
-    supportAbortJob = (procs->opvpAbortJob != 0);
-    supportStartDoc = (procs->opvpStartDoc != 0);
-    supportEndDoc = (procs->opvpEndDoc != 0);
-    supportStartPage = (procs->opvpStartPage != 0);
-    supportEndPage = (procs->opvpEndPage != 0);
-    supportResetCTM = (procs->opvpResetCTM != 0);
-    supportSetCTM = (procs->opvpSetCTM != 0);
-    supportGetCTM = (procs->opvpGetCTM != 0);
-    supportInitGS = (procs->opvpInitGS != 0);
-    supportSaveGS = (procs->opvpSaveGS != 0);
-    supportRestoreGS = (procs->opvpRestoreGS != 0);
-    supportQueryColorSpace = (procs->opvpQueryColorSpace != 0);
-    supportSetColorSpace = (procs->opvpSetColorSpace != 0);
-    supportGetColorSpace = (procs->opvpGetColorSpace != 0);
-    supportSetFillMode = (procs->opvpSetFillMode != 0);
-    supportGetFillMode = (procs->opvpGetFillMode != 0);
-    supportSetAlphaConstant = (procs->opvpSetAlphaConstant != 0);
-    supportGetAlphaConstant = (procs->opvpGetAlphaConstant != 0);
-    supportSetLineWidth = (procs->opvpSetLineWidth != 0);
-    supportGetLineWidth = (procs->opvpGetLineWidth != 0);
-    supportSetLineDash = (procs->opvpSetLineDash != 0);
-    supportGetLineDash = (procs->opvpGetLineDash != 0);
-    supportSetLineDashOffset = (procs->opvpSetLineDashOffset != 0);
-    supportGetLineDashOffset = (procs->opvpGetLineDashOffset != 0);
-    supportSetLineStyle = (procs->opvpSetLineStyle != 0);
-    supportGetLineStyle = (procs->opvpGetLineStyle != 0);
-    supportSetLineCap = (procs->opvpSetLineCap != 0);
-    supportGetLineCap = (procs->opvpGetLineCap != 0);
-    supportSetLineJoin = (procs->opvpSetLineJoin != 0);
-    supportGetLineJoin = (procs->opvpGetLineJoin != 0);
-    supportSetMiterLimit = (procs->opvpSetMiterLimit != 0);
-    supportGetMiterLimit = (procs->opvpGetMiterLimit != 0);
-    supportSetPaintMode = (procs->opvpSetPaintMode != 0);
-    supportGetPaintMode = (procs->opvpGetPaintMode != 0);
-    supportSetStrokeColor = (procs->opvpSetStrokeColor != 0);
-    supportSetFillColor = (procs->opvpSetFillColor != 0);
-    supportSetBgColor = (procs->opvpSetBgColor != 0);
-    supportNewPath = (procs->opvpNewPath != 0);
-    supportEndPath = (procs->opvpEndPath != 0);
-    supportStrokePath = (procs->opvpStrokePath != 0);
-    supportFillPath = (procs->opvpFillPath != 0);
-    supportStrokeFillPath = (procs->opvpStrokeFillPath != 0);
-    supportSetClipPath = (procs->opvpSetClipPath != 0);
-    supportSetCurrentPoint = (procs->opvpSetCurrentPoint != 0);
-    supportLinePath = (procs->opvpLinePath != 0);
-    supportPolygonPath = (procs->opvpPolygonPath != 0);
-    supportRectanglePath = (procs->opvpRectanglePath != 0);
-    supportRoundRectanglePath = (procs->opvpRoundRectanglePath != 0);
-    supportBezierPath = (procs->opvpBezierPath != 0);
-    supportArcPath = (procs->opvpArcPath != 0);
-    supportDrawImage = (procs->opvpDrawImage != 0);
-    supportStartDrawImage = (procs->opvpStartDrawImage != 0);
-    supportTransferDrawImage = (procs->opvpTransferDrawImage != 0);
-    supportEndDrawImage = (procs->opvpEndDrawImage != 0);
-    supportStartScanline = (procs->opvpStartScanline != 0);
-    supportScanline = (procs->opvpScanline != 0);
-    supportEndScanline = (procs->opvpEndScanline != 0);
-    supportStartRaster = (procs->opvpStartRaster != 0);
-    supportTransferRasterData = (procs->opvpTransferRasterData != 0);
-    supportSkipRaster = (procs->opvpSkipRaster != 0);
-    supportEndRaster = (procs->opvpEndRaster != 0);
-    supportStartStream = (procs->opvpStartStream != 0);
-    supportTransferStreamData = (procs->opvpTransferStreamData != 0);
-    supportEndStream = (procs->opvpEndStream != 0);
-    supportQueryDeviceCapability = (procs->opvpQueryDeviceCapability != 0);
-    supportQueryDeviceInfo = (procs->opvpQueryDeviceInfo != 0);
-    supportResetClipPath = (procs->opvpResetClipPath != 0);
-}
-
-OPVPWrapper::~OPVPWrapper()
-{
-    unloadDriver(opvpHandle);
-    opvpHandle = 0;
-}
-
-opvp_result_t OPVPWrapper::ClosePrinter()
-{
-    if (!supportClosePrinter) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpClosePrinter(printerContext);
-}
-
-opvp_result_t OPVPWrapper::StartJob(const opvp_char_t *jobInfo)
-{
-    if (!supportStartJob) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpStartJob(printerContext,jobInfo);
-}
-
-opvp_result_t OPVPWrapper::EndJob()
-{
-    if (!supportEndJob) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpEndJob(printerContext);
-}
-
-opvp_result_t OPVPWrapper::AbortJob()
-{
-    if (!supportAbortJob) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpAbortJob(printerContext);
-}
-
-opvp_result_t OPVPWrapper::StartDoc(const opvp_char_t *docInfo)
-{
-    if (!supportStartDoc) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpStartDoc(printerContext,docInfo);
-}
-
-opvp_result_t OPVPWrapper::EndDoc()
-{
-    if (!supportEndDoc) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpEndDoc(printerContext);
-}
-
-opvp_result_t OPVPWrapper::StartPage(const opvp_char_t *pageInfo)
-{
-    if (!supportStartPage) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpStartPage(printerContext,pageInfo);
-}
-
-opvp_result_t OPVPWrapper::EndPage()
-{
-    if (!supportEndPage) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpEndPage(printerContext);
-}
-
-opvp_result_t OPVPWrapper::QueryDeviceCapability(opvp_flag_t queryflag,
-  opvp_int_t *buflen, opvp_byte_t *infoBuf)
-{
-    if (!supportQueryDeviceCapability) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpQueryDeviceCapability(printerContext,queryflag,
-      buflen,infoBuf);
-}
-
-opvp_result_t OPVPWrapper::QueryDeviceInfo(opvp_flag_t queryflag,
-  opvp_int_t *buflen, opvp_byte_t *infoBuf)
-{
-    if (!supportQueryDeviceInfo) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpQueryDeviceInfo(printerContext,queryflag,
-      buflen,infoBuf);
-}
-
-opvp_result_t OPVPWrapper::ResetCTM()
-{
-    if (!supportResetCTM) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpResetCTM(printerContext);
-}
-
-opvp_result_t OPVPWrapper::SetCTM(const opvp_ctm_t *pCTM)
-{
-    if (!supportSetCTM) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpSetCTM(printerContext,pCTM);
-}
-
-opvp_result_t OPVPWrapper::GetCTM(opvp_ctm_t *pCTM)
-{
-    if (!supportGetCTM) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpGetCTM(printerContext,pCTM);
-}
-
-opvp_result_t OPVPWrapper::InitGS()
-{
-    if (!supportInitGS) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpInitGS(printerContext);
-}
-
-opvp_result_t OPVPWrapper::SaveGS()
-{
-    if (!supportSaveGS) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpSaveGS(printerContext);
-}
-
-opvp_result_t OPVPWrapper::RestoreGS()
-{
-    if (!supportRestoreGS) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpRestoreGS(printerContext);
-}
-
-opvp_result_t OPVPWrapper::QueryColorSpace(opvp_int_t *pnum,
-  opvp_cspace_t *pcspace)
-{
-    if (!supportQueryColorSpace) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpQueryColorSpace(printerContext,pnum,pcspace);
-}
-
-opvp_result_t OPVPWrapper::SetColorSpace(opvp_cspace_t cspace)
-{
-    if (!supportSetColorSpace) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpSetColorSpace(printerContext,cspace);
-}
-
-opvp_result_t OPVPWrapper::GetColorSpace(opvp_cspace_t *pcspace)
-{
-    if (!supportGetColorSpace) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpGetColorSpace(printerContext,pcspace);
-}
-
-opvp_result_t OPVPWrapper::SetFillMode(opvp_fillmode_t fillmode)
-{
-    if (!supportSetFillMode) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpSetFillMode(printerContext,fillmode);
-}
-
-opvp_result_t OPVPWrapper::GetFillMode(opvp_fillmode_t *pfillmode)
-{
-    if (!supportGetFillMode) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpGetFillMode(printerContext,pfillmode);
-}
-
-opvp_result_t OPVPWrapper::SetAlphaConstant(opvp_float_t alpha)
-{
-    if (!supportSetAlphaConstant) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpSetAlphaConstant(printerContext,alpha);
-}
-
-opvp_result_t OPVPWrapper::GetAlphaConstant(opvp_float_t *palpha)
-{
-    if (!supportGetAlphaConstant) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpGetAlphaConstant(printerContext,palpha);
-}
-
-opvp_result_t OPVPWrapper::SetLineWidth(opvp_fix_t width)
-{
-    if (!supportSetLineWidth) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpSetLineWidth(printerContext,width);
-}
-
-opvp_result_t OPVPWrapper::GetLineWidth(opvp_fix_t *pwidth)
-{
-    if (!supportGetLineWidth) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpGetLineWidth(printerContext,pwidth);
-}
-
-opvp_result_t OPVPWrapper::SetLineDash(opvp_int_t num,
-  const opvp_fix_t *pdash)
-{
-    if (!supportSetLineDash) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpSetLineDash(printerContext,num,pdash);
-}
-
-opvp_result_t OPVPWrapper::GetLineDash(opvp_int_t *pnum, opvp_fix_t *pdash)
-{
-    if (!supportGetLineDash) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpGetLineDash(printerContext,pnum,pdash);
-}
-
-opvp_result_t OPVPWrapper::SetLineDashOffset(opvp_fix_t offset)
-{
-    if (!supportSetLineDashOffset) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpSetLineDashOffset(printerContext,offset);
-}
-
-opvp_result_t OPVPWrapper::GetLineDashOffset(opvp_fix_t *poffset)
-{
-    if (!supportGetLineDashOffset) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpGetLineDashOffset(printerContext,poffset);
-}
-
-opvp_result_t OPVPWrapper::SetLineStyle(opvp_linestyle_t linestyle)
-{
-    if (!supportSetLineStyle) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpSetLineStyle(printerContext,linestyle);
-}
-
-opvp_result_t OPVPWrapper::GetLineStyle(opvp_linestyle_t *plinestyle)
-{
-    if (!supportGetLineStyle) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpGetLineStyle(printerContext,plinestyle);
-}
-
-opvp_result_t OPVPWrapper::SetLineCap(opvp_linecap_t linecap)
-{
-    if (!supportSetLineCap) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpSetLineCap(printerContext,linecap);
-}
-
-opvp_result_t OPVPWrapper::GetLineCap(opvp_linecap_t *plinecap)
-{
-    if (!supportGetLineCap) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpGetLineCap(printerContext,plinecap);
-}
-
-opvp_result_t OPVPWrapper::SetLineJoin(opvp_linejoin_t linejoin)
-{
-    if (!supportSetLineJoin) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpSetLineJoin(printerContext,linejoin);
-}
-
-opvp_result_t OPVPWrapper::GetLineJoin(opvp_linejoin_t *plinejoin)
-{
-    if (!supportGetLineJoin) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpGetLineJoin(printerContext,plinejoin);
-}
-
-opvp_result_t OPVPWrapper::SetMiterLimit(opvp_fix_t miterlimit)
-{
-    if (!supportSetMiterLimit) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpSetMiterLimit(printerContext,miterlimit);
-}
-
-opvp_result_t OPVPWrapper::GetMiterLimit(opvp_fix_t *pmiterlimit)
-{
-    if (!supportGetMiterLimit) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpGetMiterLimit(printerContext,pmiterlimit);
-}
-
-opvp_result_t OPVPWrapper::SetPaintMode(opvp_paintmode_t paintmode)
-{
-    if (!supportSetPaintMode) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpSetPaintMode(printerContext,paintmode);
-}
-
-opvp_result_t OPVPWrapper::GetPaintMode(opvp_paintmode_t *ppaintmode)
-{
-    if (!supportGetPaintMode) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpGetPaintMode(printerContext,ppaintmode);
-}
-
-opvp_result_t OPVPWrapper::SetStrokeColor(const opvp_brush_t *brush)
-{
-    if (!supportSetStrokeColor) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpSetStrokeColor(printerContext,brush);
-}
-
-opvp_result_t OPVPWrapper::SetFillColor(const opvp_brush_t *brush)
-{
-    if (!supportSetFillColor) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpSetFillColor(printerContext,brush);
-}
-
-opvp_result_t OPVPWrapper::SetBgColor(const opvp_brush_t *brush)
-{
-    if (!supportSetBgColor) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpSetBgColor(printerContext,brush);
-}
-
-opvp_result_t OPVPWrapper::NewPath()
-{
-    if (!supportNewPath) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpNewPath(printerContext);
-}
-
-opvp_result_t OPVPWrapper::EndPath()
-{
-    if (!supportEndPath) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpEndPath(printerContext);
-}
-
-opvp_result_t OPVPWrapper::StrokePath()
-{
-    if (!supportStrokePath) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpStrokePath(printerContext);
-}
-
-opvp_result_t OPVPWrapper::FillPath()
-{
-    if (!supportFillPath) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpFillPath(printerContext);
-}
-
-opvp_result_t OPVPWrapper::StrokeFillPath()
-{
-    if (!supportStrokeFillPath) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpStrokeFillPath(printerContext);
-}
-
-opvp_result_t OPVPWrapper::SetClipPath(opvp_cliprule_t clipRule)
-{
-    if (!supportSetClipPath) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpSetClipPath(printerContext,clipRule);
-}
-
-opvp_result_t OPVPWrapper::SetCurrentPoint(opvp_fix_t x, opvp_fix_t y)
-{
-    if (!supportSetCurrentPoint) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpSetCurrentPoint(printerContext,x,y);
-}
-
-opvp_result_t OPVPWrapper::LinePath(opvp_pathmode_t flag,
-  opvp_int_t npoints, const opvp_point_t *points)
-{
-    if (!supportLinePath) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpLinePath(printerContext,flag,npoints,points);
-}
-
-opvp_result_t OPVPWrapper::PolygonPath(opvp_int_t npolygons,
-  const opvp_int_t *nvertexes, const opvp_point_t *points)
-{
-    if (!supportPolygonPath) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpPolygonPath(printerContext,npolygons,nvertexes,points);
-}
-
-opvp_result_t OPVPWrapper::RectanglePath(opvp_int_t nrectangles,
-  const opvp_rectangle_t *rectangles)
-{
-    if (!supportRectanglePath) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpRectanglePath(printerContext,nrectangles,rectangles);
-}
-
-opvp_result_t OPVPWrapper::RoundRectanglePath(opvp_int_t nrectangles,
-  const opvp_roundrectangle_t *rectangles)
-{
-    if (!supportRoundRectanglePath) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpRoundRectanglePath(printerContext,nrectangles,rectangles);
-}
-
-opvp_result_t OPVPWrapper::BezierPath(opvp_int_t npoints,
-  const opvp_point_t *points)
-{
-    if (!supportBezierPath) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpBezierPath(printerContext,npoints,points);
-}
-
-opvp_result_t OPVPWrapper::ArcPath(opvp_arcmode_t kind,
-  opvp_arcdir_t dir, opvp_fix_t bbx0,
-  opvp_fix_t bby0, opvp_fix_t bbx1, opvp_fix_t bby1, opvp_fix_t x0,
-  opvp_fix_t y0, opvp_fix_t x1, opvp_fix_t y1)
-{
-    if (!supportArcPath) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpArcPath(printerContext,kind,dir,bbx0,bby0,
-       bbx1,bby1,x0,y0,x1,y1);
-}
-
-opvp_result_t OPVPWrapper::DrawImage(
-  opvp_int_t sourceWidth, opvp_int_t sourceHeight, opvp_int_t sourcePitch,
-  opvp_imageformat_t imageFormat, opvp_int_t destinationWidth,
-  opvp_int_t destinationHeight, const void *imagedata)
-{
-    if (!supportDrawImage) {
-      int result;
-
-      if ((result = StartDrawImage(sourceWidth,sourceHeight,sourcePitch,
-        imageFormat,destinationWidth,destinationHeight)) < 0) {
-	return result;
-      }
-      if ((result = TransferDrawImage(sourcePitch*sourceHeight,
-        imagedata)) < 0) {
-	return result;
-      }
-      return EndDrawImage();
-    }
-    return procs->opvpDrawImage(printerContext,sourceWidth, sourceHeight,
-      sourcePitch, imageFormat, destinationWidth, destinationHeight,
-      imagedata);
-}
-
-opvp_result_t OPVPWrapper::StartDrawImage(
-  opvp_int_t sourceWidth, opvp_int_t sourceHeight, opvp_int_t sourcePitch,
-  opvp_imageformat_t imageFormat, opvp_int_t destinationWidth,
-  opvp_int_t destinationHeight)
-{
-    if (!supportStartDrawImage) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpStartDrawImage(printerContext,sourceWidth,
-      sourceHeight,sourcePitch,imageFormat,
-      destinationWidth,destinationHeight);
-}
-
-opvp_result_t OPVPWrapper::TransferDrawImage(opvp_int_t count,
-  const void *imagedata)
-{
-    if (!supportTransferDrawImage) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpTransferDrawImage(printerContext,count,imagedata);
-}
-
-opvp_result_t OPVPWrapper::EndDrawImage()
-{
-    if (!supportEndDrawImage) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpEndDrawImage(printerContext);
-}
-
-opvp_result_t OPVPWrapper::StartScanline(opvp_int_t yposition)
-{
-    if (!supportStartScanline) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpStartScanline(printerContext,yposition);
-}
-
-opvp_result_t OPVPWrapper::Scanline(opvp_int_t nscanpairs,
-  const opvp_int_t *scanpairs)
-{
-    if (!supportScanline) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpScanline(printerContext,nscanpairs,scanpairs);
-}
-
-opvp_result_t OPVPWrapper::EndScanline()
-{
-    if (!supportEndScanline) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpEndScanline(printerContext);
-}
-
-opvp_result_t OPVPWrapper::StartRaster(
-  opvp_int_t rasterWidth)
-{
-    if (!supportStartRaster) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpStartRaster(printerContext,rasterWidth);
-}
-
-opvp_result_t OPVPWrapper::TransferRasterData(opvp_int_t count,
-  const opvp_byte_t *data)
-{
-    if (!supportTransferRasterData) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpTransferRasterData(printerContext,count,
-      data);
-}
-
-opvp_result_t OPVPWrapper::SkipRaster(opvp_int_t count)
-{
-    if (!supportSkipRaster) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpSkipRaster(printerContext,count);
-}
-
-opvp_result_t OPVPWrapper::EndRaster()
-{
-    if (!supportEndRaster) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpEndRaster(printerContext);
-}
-
-opvp_result_t OPVPWrapper::StartStream()
-{
-    if (!supportStartStream) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpStartStream(printerContext);
-}
-
-opvp_result_t OPVPWrapper::TransferStreamData(opvp_int_t count,
-  const void *data)
-{
-    if (!supportTransferStreamData) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpTransferStreamData(printerContext,count,data);
-}
-
-opvp_result_t OPVPWrapper::EndStream()
-{
-    if (!supportEndStream) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpEndStream(printerContext);
-}
-
-opvp_result_t OPVPWrapper::ResetClipPath()
-{
-    if (!supportResetClipPath) {
-	*opvpErrorNo = OPVP_NOTSUPPORTED;
-	return -1;
-    }
-    return procs->opvpResetClipPath(printerContext);
-}
-
-char *OPVPWrapper::allocString(char **destin, unsigned int size)
-{
-    if (!destin) return 0;
-
-    if (*destin != 0) delete[] *destin;
-    if (size > 0) {
-	*destin = new char[size];
-    }
-
-    return *destin;
-}
-
-char **OPVPWrapper::genDynamicLibName(const char *name)
-{
-    static char	*buff[5] = {0,0,0,0,0};
-
-    allocString(&(buff[0]), strlen(name)+1);
-    strcpy(buff[0], name);
-    allocString(&(buff[1]), strlen(name)+3+1);
-    strcpy(buff[1], name);
-    strcat(buff[1], ".so");
-    allocString(&(buff[2]), strlen(name)+4+1);
-    strcpy(buff[2], name);
-    strcat(buff[2], ".dll");
-    allocString(&(buff[3]), strlen(name)+6+1);
-    strcpy(buff[3], "lib");
-    strcat(buff[3], name);
-    strcat(buff[3], ".so");
-    buff[4] = 0;
-
-    return buff;
-}
-
-OPVPWrapper *OPVPWrapper::loadDriver(const char *driverName,
-  int outputFD, const char *printerModel)
-{
-    char **list = 0;
-    int	 i;
-    void *h;
-    int nApiEntry;
-    int (*opvpOpenPrinter)(opvp_int_t outputFD,
-      const opvp_char_t * printerModel, const opvp_int_t version[2],
-      opvp_api_procs_t **apiEntry) = 0;
-    int (*opvpOpenPrinter_0_2)(int outputFD, char* printerModel,
-      int *nApiEntry, OPVP_api_procs **apiEntry) = 0;
-    opvp_api_procs_t *opvpProcs;
-    OPVP_api_procs *opvpProcs_0_2;
-    opvp_dc_t opvpContext;
-    int opvpContext_0_2 = 0;
-    opvp_int_t *opvpErrorNo = 0;
-    int *opvpErrorNo_0_2 = 0;
-    void *handle = 0;
-    OPVPWrapper *opvp = 0;
-
-    // remove directory part
-    const char *s = strrchr(driverName,'/');
-    if (s != NULL) {
-        driverName = s+1;
-    }
-
-    list = genDynamicLibName(driverName);
-
-    if (list) {
-	i = 0;
-	while (list[i]) {
-	    if ((h = dlopen(list[i],RTLD_NOW))) {
-		opvpOpenPrinter = (int (*)(opvp_int_t,
-		  const opvp_char_t *, const opvp_int_t[2],
-		  opvp_api_procs_t **))dlsym(h,"opvpOpenPrinter");
-		opvpErrorNo = (opvp_int_t *)dlsym(h,"opvpErrorNo");
-		if (opvpOpenPrinter && opvpErrorNo) {
-		    handle = h;
-		    break;
-		}
-		opvpOpenPrinter = 0;
-		opvpErrorNo = 0;
-		/* try version 0.2 driver */
-		opvpOpenPrinter_0_2 = (int (*)(int, char*, int *,
-		  OPVP_api_procs **))dlsym(h,"OpenPrinter");
-		opvpErrorNo_0_2 = (int *)dlsym(h,"errorno");
-		if (opvpOpenPrinter_0_2 && opvpErrorNo_0_2) {
-		    handle = h;
-		    break;
-		}
-		opvpOpenPrinter_0_2 = 0;
-		opvpErrorNo_0_2 = 0;
-	    }
-	    i++;
-	}
-	for (i = 0;list[i] != 0;i++) {
-	    delete[] (list[i]);
-	    list[i] = 0;
-	}
-    }
-    if (handle == 0) {
-      OPRS::error("Loading vector printer driver (%s) fail\n",driverName);
-      return 0;
-    }
-    if (opvpOpenPrinter != 0) {
-	opvp_int_t apiVersion[2];
-
-	/* require version 1.0 */
-	apiVersion[0] = 1;
-	apiVersion[1] = 0;
-	if ((opvpContext = (*opvpOpenPrinter)(outputFD,
-	     (const opvp_char_t *)printerModel,apiVersion,&opvpProcs)) < 0) {
-	    OPRS::error("OpenPrinter fail\n",driverName);
-	    unloadDriver(handle);
-	    return 0;
-	}
-	opvp = new OPVPWrapper(handle, opvpErrorNo, opvpProcs, opvpContext);
-    } else if (opvpOpenPrinter_0_2) {
-	if ((opvpContext_0_2 = (*opvpOpenPrinter_0_2)(outputFD,
-	     (char *)printerModel,&nApiEntry,&opvpProcs_0_2)) < 0) {
-	    OPRS::error("OpenPrinter fail\n",driverName);
-	    unloadDriver(handle);
-	    return 0;
-	}
-	opvp = (OPVPWrapper *)new OPVPWrapper_0_2(handle, opvpErrorNo_0_2,
-	  opvpProcs_0_2, opvpContext_0_2);
-    }
-    return opvp;
-}
-
-/*
- * unload vector-driver
- */
-int OPVPWrapper::unloadDriver(void *opvpHandleA)
-{
-    if (opvpHandleA != 0) {
-	dlclose(opvpHandleA);
-    }
-    return 0;
-}
-
-opvp_int_t OPVPWrapper::getErrorNo()
-{
-    return *opvpErrorNo;
-}
-
diff --git a/filter/pdftoopvp/oprs/OPVPWrapper.h b/filter/pdftoopvp/oprs/OPVPWrapper.h
deleted file mode 100644
index 1dfcba3..0000000
--- a/filter/pdftoopvp/oprs/OPVPWrapper.h
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
-  OPVPWrapper.h
-*/
-
-#ifndef OPVPWRAPPER_H
-#define OPVPWRAPPER_H
-
-#include "opvp_common.h"
-
-class OPVPWrapper {
-public:
-    static OPVPWrapper *loadDriver(const char *driverName, int outputFD,
-      const char *printerModel);
-    static int unloadDriver(void *opvpHandleA);
-private:
-    static char *allocString(char **destin, unsigned int size);
-    static char **genDynamicLibName(const char *name);
-public:
-    OPVPWrapper() {};
-    OPVPWrapper(void *opvpHandleA, opvp_int_t *opvpErrorNoA,
-      opvp_api_procs_t *procsA, opvp_dc_t printerContextA);
-    virtual ~OPVPWrapper();
-
-    virtual opvp_int_t getErrorNo();
-
-    void getVersion(opvp_int_t versionA[2])
-    {
-	versionA[0] = version[0];
-	versionA[1] = version[1];
-    }
-
-    virtual opvp_result_t ClosePrinter();
-    virtual opvp_result_t StartJob(const opvp_char_t *jobInfo);
-    virtual opvp_result_t EndJob();
-    virtual opvp_result_t AbortJob();
-    virtual opvp_result_t StartDoc(const opvp_char_t *docInfo);
-    virtual opvp_result_t EndDoc();
-    virtual opvp_result_t StartPage(const opvp_char_t *pageInfo);
-    virtual opvp_result_t EndPage();
-    virtual opvp_result_t QueryDeviceCapability(opvp_flag_t queryflag,
-      opvp_int_t *buflen, opvp_byte_t *infoBuf);
-    virtual opvp_result_t QueryDeviceInfo(opvp_flag_t queryflag,
-      opvp_int_t *buflen, opvp_byte_t *infoBuf);
-    virtual opvp_result_t ResetCTM();
-    virtual opvp_result_t SetCTM(const opvp_ctm_t *pCTM);
-    virtual opvp_result_t GetCTM(opvp_ctm_t *pCTM);
-    virtual opvp_result_t InitGS();
-    virtual opvp_result_t SaveGS();
-    virtual opvp_result_t RestoreGS();
-    virtual opvp_result_t QueryColorSpace(opvp_int_t *pnum,
-      opvp_cspace_t *pcspace);
-    virtual opvp_result_t SetColorSpace(opvp_cspace_t cspace);
-    virtual opvp_result_t GetColorSpace(opvp_cspace_t *pcspace);
-    virtual opvp_result_t SetFillMode(opvp_fillmode_t fillmode);
-    virtual opvp_result_t GetFillMode(opvp_fillmode_t *pfillmode);
-    virtual opvp_result_t SetAlphaConstant(opvp_float_t alpha);
-    virtual opvp_result_t GetAlphaConstant(opvp_float_t *palpha);
-    virtual opvp_result_t SetLineWidth(opvp_fix_t width);
-    virtual opvp_result_t GetLineWidth(opvp_fix_t *pwidth);
-    virtual opvp_result_t SetLineDash(opvp_int_t num, const opvp_fix_t *pdash);
-    virtual opvp_result_t GetLineDash(opvp_int_t *pnum, opvp_fix_t *pdash);
-    virtual opvp_result_t SetLineDashOffset(opvp_fix_t offset);
-    virtual opvp_result_t GetLineDashOffset(opvp_fix_t *poffset);
-    virtual opvp_result_t SetLineStyle(opvp_linestyle_t linestyle);
-    virtual opvp_result_t GetLineStyle(opvp_linestyle_t *plinestyle);
-    virtual opvp_result_t SetLineCap(opvp_linecap_t linecap);
-    virtual opvp_result_t GetLineCap(opvp_linecap_t *plinecap);
-    virtual opvp_result_t SetLineJoin(opvp_linejoin_t linejoin);
-    virtual opvp_result_t GetLineJoin(opvp_linejoin_t *plinejoin);
-    virtual opvp_result_t SetMiterLimit(opvp_fix_t miterlimit);
-    virtual opvp_result_t GetMiterLimit(opvp_fix_t *pmiterlimit);
-    virtual opvp_result_t SetPaintMode(opvp_paintmode_t paintmode);
-    virtual opvp_result_t GetPaintMode(opvp_paintmode_t *ppaintmode);
-    virtual opvp_result_t SetStrokeColor(const opvp_brush_t *brush);
-    virtual opvp_result_t SetFillColor(const opvp_brush_t *brush);
-    virtual opvp_result_t SetBgColor(const opvp_brush_t *brush);
-    virtual opvp_result_t NewPath();
-    virtual opvp_result_t EndPath();
-    virtual opvp_result_t StrokePath();
-    virtual opvp_result_t FillPath();
-    virtual opvp_result_t StrokeFillPath();
-    virtual opvp_result_t SetClipPath(opvp_cliprule_t clipRule);
-    virtual opvp_result_t SetCurrentPoint(opvp_fix_t x, opvp_fix_t y);
-    virtual opvp_result_t LinePath(opvp_pathmode_t flag,
-      opvp_int_t npoints, const opvp_point_t *points);
-    virtual opvp_result_t PolygonPath(opvp_int_t npolygons,
-      const opvp_int_t *nvertexes, const opvp_point_t *points);
-    virtual opvp_result_t RectanglePath(opvp_int_t nrectangles,
-      const opvp_rectangle_t *reclangles);
-    virtual opvp_result_t RoundRectanglePath(opvp_int_t nrectangles,
-      const opvp_roundrectangle_t *reclangles);
-    virtual opvp_result_t BezierPath(opvp_int_t npoints,
-      const opvp_point_t *points);
-    virtual opvp_result_t ArcPath(opvp_arcmode_t kind,
-      opvp_arcdir_t dir, opvp_fix_t bbx0, opvp_fix_t bby0,
-      opvp_fix_t bbx1, opvp_fix_t bby1, opvp_fix_t x0,
-      opvp_fix_t y0, opvp_fix_t x1, opvp_fix_t y1);
-    virtual opvp_result_t DrawImage(opvp_int_t sourceWidth,
-      opvp_int_t sourceHeight, opvp_int_t sourcePitch,
-      opvp_imageformat_t imageFormat,
-      opvp_int_t destinationWidth, opvp_int_t destinationHeight,
-      const void *imageData);
-    virtual opvp_result_t StartDrawImage(opvp_int_t sourceWidth,
-      opvp_int_t sourceHeight, opvp_int_t sourcePitch,
-      opvp_imageformat_t imageFormat,
-      opvp_int_t destinationWidth, opvp_int_t destinationHeight);
-    virtual opvp_result_t TransferDrawImage(opvp_int_t count,
-      const void *imageData);
-    virtual opvp_result_t EndDrawImage();
-    virtual opvp_result_t StartScanline(opvp_int_t yposition);
-    virtual opvp_result_t Scanline(opvp_int_t nscanpairs,
-      const opvp_int_t *scanpairs);
-    virtual opvp_result_t EndScanline();
-    virtual opvp_result_t StartRaster(opvp_int_t rasterWidth);
-    virtual opvp_result_t TransferRasterData(opvp_int_t count,
-      const opvp_byte_t *data);
-    virtual opvp_result_t SkipRaster(opvp_int_t count);
-    virtual opvp_result_t EndRaster();
-    virtual opvp_result_t StartStream();
-    virtual opvp_result_t TransferStreamData(opvp_int_t count,
-      const void *data);
-    virtual opvp_result_t EndStream();
-    virtual opvp_result_t ResetClipPath();
-
-    bool supportClosePrinter;
-    bool supportStartJob;
-    bool supportEndJob;
-    bool supportAbortJob;
-    bool supportStartDoc;
-    bool supportEndDoc;
-    bool supportStartPage;
-    bool supportEndPage;
-    bool supportResetCTM;
-    bool supportSetCTM;
-    bool supportGetCTM;
-    bool supportInitGS;
-    bool supportSaveGS;
-    bool supportRestoreGS;
-    bool supportQueryColorSpace;
-    bool supportSetColorSpace;
-    bool supportGetColorSpace;
-    bool supportSetFillMode;
-    bool supportGetFillMode;
-    bool supportSetAlphaConstant;
-    bool supportGetAlphaConstant;
-    bool supportSetLineWidth;
-    bool supportGetLineWidth;
-    bool supportSetLineDash;
-    bool supportGetLineDash;
-    bool supportSetLineDashOffset;
-    bool supportGetLineDashOffset;
-    bool supportSetLineStyle;
-    bool supportGetLineStyle;
-    bool supportSetLineCap;
-    bool supportGetLineCap;
-    bool supportSetLineJoin;
-    bool supportGetLineJoin;
-    bool supportSetMiterLimit;
-    bool supportGetMiterLimit;
-    bool supportSetPaintMode;
-    bool supportGetPaintMode;
-    bool supportSetStrokeColor;
-    bool supportSetFillColor;
-    bool supportSetBgColor;
-    bool supportNewPath;
-    bool supportEndPath;
-    bool supportStrokePath;
-    bool supportFillPath;
-    bool supportStrokeFillPath;
-    bool supportSetClipPath;
-    bool supportSetCurrentPoint;
-    bool supportLinePath;
-    bool supportPolygonPath;
-    bool supportRectanglePath;
-    bool supportRoundRectanglePath;
-    bool supportBezierPath;
-    bool supportArcPath;
-    bool supportDrawImage;
-    bool supportStartDrawImage;
-    bool supportTransferDrawImage;
-    bool supportEndDrawImage;
-    bool supportStartScanline;
-    bool supportScanline;
-    bool supportEndScanline;
-    bool supportStartRaster;
-    bool supportTransferRasterData;
-    bool supportSkipRaster;
-    bool supportEndRaster;
-    bool supportStartStream;
-    bool supportTransferStreamData;
-    bool supportEndStream;
-    bool supportQueryDeviceCapability;
-    bool supportQueryDeviceInfo;
-    bool supportResetClipPath;
-
-protected:
-    void *opvpHandle;
-    opvp_int_t version[2];
-private:
-    opvp_api_procs_t *procs;
-    opvp_int_t *opvpErrorNo;
-    opvp_dc_t printerContext;
-};
-
-#endif
diff --git a/filter/pdftoopvp/oprs/OPVPWrapper_0_2.cxx b/filter/pdftoopvp/oprs/OPVPWrapper_0_2.cxx
deleted file mode 100644
index 112580e..0000000
--- a/filter/pdftoopvp/oprs/OPVPWrapper_0_2.cxx
+++ /dev/null
@@ -1,1172 +0,0 @@
-/*
-  OPVPWrapper_0_2.cc
-*/
-
-
-#include <config.h>
-#include "OPVPWrapper_0_2.h"
-#include <string.h>
-
-/* color space mapping 0.2 to 1.0 */
-opvp_cspace_t OPVPWrapper_0_2::cspace_0_2_to_1_0[] = {
-    OPVP_CSPACE_BW,
-    OPVP_CSPACE_DEVICEGRAY,
-    OPVP_CSPACE_DEVICECMY,
-    OPVP_CSPACE_DEVICECMYK,
-    OPVP_CSPACE_DEVICERGB,
-    OPVP_CSPACE_STANDARDRGB,
-    OPVP_CSPACE_STANDARDRGB64
-};
-
-/* color space mapping 1.0 to 0.2 */
-OPVP_ColorSpace OPVPWrapper_0_2::cspace_1_0_to_0_2[] = {
-    OPVP_cspaceBW,
-    OPVP_cspaceDeviceGray,
-    OPVP_cspaceDeviceCMY,
-    OPVP_cspaceDeviceCMYK,
-    OPVP_cspaceDeviceRGB,
-    (OPVP_ColorSpace)0, /* 0.2 doesn't have OPVP_CSPACE_DEVICEKRGB */
-    OPVP_cspaceStandardRGB,
-    OPVP_cspaceStandardRGB64,
-};
-
-/* image format mapping 1.0 to 0.2 */
-OPVP_ImageFormat OPVPWrapper_0_2::iformat_1_0_to_0_2[] = {
-    OPVP_iformatRaw,
-    /* OPVP_IFORMAT_MASK use iformat raw in 0.2 */
-    OPVP_iformatRaw,
-    OPVP_iformatRLE,
-    OPVP_iformatJPEG,
-    OPVP_iformatPNG,
-};
-
-/* image colorDepth needed in 0.2 */
-int OPVPWrapper_0_2::colorDepth_0_2[] = {
-    1, /* OPVP_CSPACE_BW */
-    8, /* OPVP_CSPACE_DEVICEGRAY */
-    24, /* OPVP_CSPACE_DEVICECMY */
-    32, /* OPVP_CSPACE_DEVICECMYK */
-    24, /* OPVP_CSPACE_DEVICERGB */
-    32, /* OPVP_CSPACE_DEVICEKRGB */
-    24, /* OPVP_CSPACE_STANDARDRGB */
-    64, /* OPVP_CSPACE_STANDARDRGB64 */
-};
-
-OPVPWrapper_0_2::OPVPWrapper_0_2(void *opvpHandleA, int *opvpErrorNoA,
-  OPVP_api_procs *procsA, int printerContextA)
-{
-    procs_0_2 = procsA;
-    opvpHandle = opvpHandleA;
-    opvpErrorNo_0_2 = opvpErrorNoA;
-    printerContext_0_2 = printerContextA;
-    version[0] = 0;
-    version[1] = 2;
-    supportClosePrinter = (procs_0_2->ClosePrinter != 0);
-    supportStartJob = (procs_0_2->StartJob != 0);
-    supportEndJob = (procs_0_2->EndJob != 0);
-    supportAbortJob = false;
-    supportStartDoc = (procs_0_2->StartDoc != 0);
-    supportEndDoc = (procs_0_2->EndDoc != 0);
-    supportStartPage = (procs_0_2->StartPage != 0);
-    supportEndPage = (procs_0_2->EndPage != 0);
-    supportResetCTM = (procs_0_2->ResetCTM != 0);
-    supportSetCTM = (procs_0_2->SetCTM != 0);
-    supportGetCTM = (procs_0_2->GetCTM != 0);
-    supportInitGS = (procs_0_2->InitGS != 0);
-    supportSaveGS = (procs_0_2->SaveGS != 0);
-    supportRestoreGS = (procs_0_2->RestoreGS != 0);
-    supportQueryColorSpace = (procs_0_2->QueryColorSpace != 0);
-    supportSetColorSpace = (procs_0_2->SetColorSpace != 0);
-    supportGetColorSpace = (procs_0_2->GetColorSpace != 0);
-    supportSetFillMode = (procs_0_2->SetFillMode != 0);
-    supportGetFillMode = (procs_0_2->GetFillMode != 0);
-    supportSetAlphaConstant = (procs_0_2->SetAlphaConstant != 0);
-    supportGetAlphaConstant = (procs_0_2->GetAlphaConstant != 0);
-    supportSetLineWidth = (procs_0_2->SetLineWidth != 0);
-    supportGetLineWidth = (procs_0_2->GetLineWidth != 0);
-    supportSetLineDash = (procs_0_2->SetLineDash != 0);
-    supportGetLineDash = (procs_0_2->GetLineDash != 0);
-    supportSetLineDashOffset = (procs_0_2->SetLineDashOffset != 0);
-    supportGetLineDashOffset = (procs_0_2->GetLineDashOffset != 0);
-    supportSetLineStyle = (procs_0_2->SetLineStyle != 0);
-    supportGetLineStyle = (procs_0_2->GetLineStyle != 0);
-    supportSetLineCap = (procs_0_2->SetLineCap != 0);
-    supportGetLineCap = (procs_0_2->GetLineCap != 0);
-    supportSetLineJoin = (procs_0_2->SetLineJoin != 0);
-    supportGetLineJoin = (procs_0_2->GetLineJoin != 0);
-    supportSetMiterLimit = (procs_0_2->SetMiterLimit != 0);
-    supportGetMiterLimit = (procs_0_2->GetMiterLimit != 0);
-    supportSetPaintMode = (procs_0_2->SetPaintMode != 0);
-    supportGetPaintMode = (procs_0_2->GetPaintMode != 0);
-    supportSetStrokeColor = (procs_0_2->SetStrokeColor != 0);
-    supportSetFillColor = (procs_0_2->SetFillColor != 0);
-    supportSetBgColor = (procs_0_2->SetBgColor != 0);
-    supportNewPath = (procs_0_2->NewPath != 0);
-    supportEndPath = (procs_0_2->EndPath != 0);
-    supportStrokePath = (procs_0_2->StrokePath != 0);
-    supportFillPath = (procs_0_2->FillPath != 0);
-    supportStrokeFillPath = (procs_0_2->StrokeFillPath != 0);
-    supportSetClipPath = (procs_0_2->SetClipPath != 0);
-    supportSetCurrentPoint = (procs_0_2->SetCurrentPoint != 0);
-    supportLinePath = (procs_0_2->LinePath != 0);
-    supportPolygonPath = (procs_0_2->PolygonPath != 0);
-    supportRectanglePath = (procs_0_2->RectanglePath != 0);
-    supportRoundRectanglePath = (procs_0_2->RoundRectanglePath != 0);
-    supportBezierPath = (procs_0_2->BezierPath != 0);
-    supportArcPath = (procs_0_2->ArcPath != 0);
-    supportDrawImage = (procs_0_2->DrawImage != 0);
-    supportStartDrawImage = (procs_0_2->StartDrawImage != 0);
-    supportTransferDrawImage = (procs_0_2->TransferDrawImage != 0);
-    supportEndDrawImage = (procs_0_2->EndDrawImage != 0);
-    supportStartScanline = (procs_0_2->StartScanline != 0);
-    supportScanline = (procs_0_2->Scanline != 0);
-    supportEndScanline = (procs_0_2->EndScanline != 0);
-    supportStartRaster = (procs_0_2->StartRaster != 0);
-    supportTransferRasterData = (procs_0_2->TransferRasterData != 0);
-    supportSkipRaster = (procs_0_2->SkipRaster != 0);
-    supportEndRaster = (procs_0_2->EndRaster != 0);
-    supportStartStream = (procs_0_2->StartStream != 0);
-    supportTransferStreamData = (procs_0_2->TransferStreamData != 0);
-    supportEndStream = (procs_0_2->EndStream != 0);
-    supportQueryDeviceCapability = (procs_0_2->QueryDeviceCapability != 0);
-    supportQueryDeviceInfo = (procs_0_2->QueryDeviceInfo != 0);
-    supportResetClipPath = (procs_0_2->ResetClipPath != 0);
-    colorSpace = OPVP_CSPACE_STANDARDRGB;
-    if (supportGetColorSpace) {
-	if (GetColorSpace(&colorSpace) != OPVP_OK) {
-	    colorSpace = OPVP_CSPACE_STANDARDRGB;
-	}
-    }
-}
-
-OPVPWrapper_0_2::~OPVPWrapper_0_2()
-{
-}
-
-opvp_result_t OPVPWrapper_0_2::ClosePrinter()
-{
-    if (!supportClosePrinter) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->ClosePrinter(printerContext_0_2);
-}
-
-opvp_result_t OPVPWrapper_0_2::StartJob(
-  const opvp_char_t *jobInfo)
-{
-    if (!supportStartJob) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->StartJob(printerContext_0_2,
-      (char *)jobInfo);
-}
-
-opvp_result_t OPVPWrapper_0_2::EndJob()
-{
-    if (!supportEndJob) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->EndJob(printerContext_0_2);
-}
-
-opvp_result_t OPVPWrapper_0_2::AbortJob()
-{
-    *opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-    return -1;
-}
-
-opvp_result_t OPVPWrapper_0_2::StartDoc(
-  const opvp_char_t *docInfo)
-{
-    if (!supportStartDoc) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->StartDoc(printerContext_0_2,
-      (char *)docInfo);
-}
-
-opvp_result_t OPVPWrapper_0_2::EndDoc()
-{
-    if (!supportEndDoc) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->EndDoc(printerContext_0_2);
-}
-
-opvp_result_t OPVPWrapper_0_2::StartPage(
-  const opvp_char_t *pageInfo)
-{
-    int r;
-
-    if (!supportStartPage) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    if ((r = procs_0_2->StartPage(printerContext_0_2,
-           /* discard const */(char *)pageInfo)) != OPVP_OK) {
-	  /* error */
-	return (opvp_result_t)r;
-    }
-    /* initialize ROP */
-    if (procs_0_2->SetROP != 0) {
-	procs_0_2->SetROP(printerContext_0_2,
-	  OPVP_0_2_ROP_P);
-    }
-    return OPVP_OK;
-}
-
-opvp_result_t OPVPWrapper_0_2::EndPage()
-{
-    if (!supportEndPage) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->EndPage(printerContext_0_2);
-}
-
-opvp_result_t OPVPWrapper_0_2::QueryDeviceCapability(
-  opvp_flag_t queryflag, opvp_int_t *buflen, opvp_byte_t *infoBuf)
-{
-    if (!supportQueryDeviceCapability) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->
-      QueryDeviceCapability(printerContext_0_2,queryflag,*buflen,
-      (char *)infoBuf);
-}
-
-opvp_result_t OPVPWrapper_0_2::QueryDeviceInfo(
-  opvp_flag_t queryflag, opvp_int_t *buflen, opvp_byte_t *infoBuf)
-{
-    if (!supportQueryDeviceInfo) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    if (queryflag & OPVP_QF_MEDIACOPY) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    if (queryflag & OPVP_QF_PRINTREGION) {
-	queryflag &= ~OPVP_QF_PRINTREGION;
-	queryflag |= 0x0020000;
-    }
-    return (opvp_result_t)procs_0_2->QueryDeviceInfo(printerContext_0_2,
-      queryflag,*buflen,(char *)infoBuf);
-}
-
-opvp_result_t OPVPWrapper_0_2::ResetCTM()
-{
-    if (!supportResetCTM) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->ResetCTM(printerContext_0_2);
-}
-
-opvp_result_t OPVPWrapper_0_2::SetCTM(const opvp_ctm_t *pCTM)
-{
-    if (!supportSetCTM) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->SetCTM(printerContext_0_2,
-      (OPVP_CTM *)pCTM);
-}
-
-opvp_result_t OPVPWrapper_0_2::GetCTM(opvp_ctm_t *pCTM)
-{
-    if (!supportGetCTM) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->GetCTM(printerContext_0_2,
-      (OPVP_CTM *)pCTM);
-}
-
-opvp_result_t OPVPWrapper_0_2::InitGS()
-{
-    int r;
-
-    if (!supportInitGS) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    if ((r = procs_0_2->InitGS(printerContext_0_2)) != OPVP_OK) {
-	  /* error */
-	return (opvp_result_t)r;
-    }
-    /* initialize ROP */
-    if (procs_0_2->SetROP != 0) {
-	procs_0_2->SetROP(printerContext_0_2,
-	  OPVP_0_2_ROP_P);
-    }
-    return OPVP_OK;
-}
-
-opvp_result_t OPVPWrapper_0_2::SaveGS()
-{
-    if (!supportSaveGS) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->SaveGS(printerContext_0_2);
-}
-
-opvp_result_t OPVPWrapper_0_2::RestoreGS()
-{
-    if (!supportRestoreGS) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->RestoreGS(printerContext_0_2);
-}
-
-opvp_result_t OPVPWrapper_0_2::QueryColorSpace(
-  opvp_int_t *pnum, opvp_cspace_t *pcspace)
-{
-    int r;
-    int i;
-
-    if (!supportQueryColorSpace) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    if ((r = procs_0_2->QueryColorSpace(printerContext_0_2,
-	 (OPVP_ColorSpace *)pcspace,pnum)) != OPVP_OK) {
-	/* error */
-	return (opvp_result_t)r;
-    }
-    /* translate cspaces */
-    for (i = 0;i < *pnum;i++) {
-	if ((unsigned int)pcspace[i] 
-	     > sizeof(cspace_0_2_to_1_0)/sizeof(opvp_cspace_t)) {
-	    /* unknown color space */
-	    /* set DEVICERGB instead */
-	    pcspace[i] = OPVP_CSPACE_DEVICERGB;
-	} else {
-	    pcspace[i] = cspace_0_2_to_1_0[pcspace[i]];
-	}
-    }
-    return OPVP_OK;
-}
-
-opvp_result_t OPVPWrapper_0_2::SetColorSpace(
-  opvp_cspace_t cspace)
-{
-    int r;
-
-    if (!supportSetColorSpace) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    if (cspace == OPVP_CSPACE_DEVICEKRGB) {
-	/* 0.2 doesn't have OPVP_CSPACE_DEVICEKRGB */
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    if ((unsigned int)cspace
-	 > sizeof(cspace_1_0_to_0_2)/sizeof(OPVP_ColorSpace)) {
-	/* unknown color space */
-	*opvpErrorNo_0_2 = OPVP_PARAMERROR_0_2;
-	return -1;
-    }
-    r =  procs_0_2->SetColorSpace(printerContext_0_2,
-      cspace_1_0_to_0_2[cspace]);
-    if (r == OPVP_OK) {
-	colorSpace = cspace;
-    }
-    return (opvp_result_t)r;
-}
-
-opvp_result_t OPVPWrapper_0_2::GetColorSpace(
-  opvp_cspace_t *pcspace)
-{
-    int r;
-
-    if (!supportGetColorSpace) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    if ((r = procs_0_2->GetColorSpace(printerContext_0_2,
-      (OPVP_ColorSpace *)pcspace)) != OPVP_OK) {
-	/* error */
-	return (opvp_result_t)r;
-    }
-    if ((unsigned int)*pcspace
-	 > sizeof(cspace_0_2_to_1_0)/sizeof(opvp_cspace_t)) {
-	/* unknown color space */
-	/* set DEVICERGB instead */
-	*pcspace = OPVP_CSPACE_DEVICERGB;
-    } else {
-	*pcspace = cspace_0_2_to_1_0[*pcspace];
-    }
-    return (opvp_result_t)r;
-}
-
-opvp_result_t OPVPWrapper_0_2::SetFillMode(
-  opvp_fillmode_t fillmode)
-{
-    if (!supportSetFillMode) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    /* OPVP_FillMode is comaptible with opvp_fillmode_t */
-    return (opvp_result_t)procs_0_2->SetFillMode(printerContext_0_2,
-      (OPVP_FillMode)fillmode);
-}
-
-opvp_result_t OPVPWrapper_0_2::GetFillMode(
-  opvp_fillmode_t *pfillmode)
-{
-    if (!supportGetFillMode) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    /* OPVP_FillMode is comaptible with opvp_fillmode_t */
-    return (opvp_result_t)procs_0_2->GetFillMode(printerContext_0_2,
-      (OPVP_FillMode *)pfillmode);
-}
-
-opvp_result_t OPVPWrapper_0_2::SetAlphaConstant(
-  opvp_float_t alpha)
-{
-    if (!supportSetAlphaConstant) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->SetAlphaConstant(printerContext_0_2,alpha);
-}
-
-opvp_result_t OPVPWrapper_0_2::GetAlphaConstant(
-  opvp_float_t *palpha)
-{
-    if (!supportGetAlphaConstant) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->GetAlphaConstant(printerContext_0_2,palpha);
-}
-
-opvp_result_t OPVPWrapper_0_2::SetLineWidth(
-  opvp_fix_t width)
-{
-    if (!supportSetLineWidth) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->SetLineWidth(printerContext_0_2,width);
-}
-
-opvp_result_t OPVPWrapper_0_2::GetLineWidth(
-  opvp_fix_t *pwidth)
-{
-    if (!supportGetLineWidth) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->GetLineWidth(printerContext_0_2,pwidth);
-}
-
-opvp_result_t OPVPWrapper_0_2::SetLineDash(opvp_int_t num,
-  const opvp_fix_t *pdash)
-{
-    if (!supportSetLineDash) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->SetLineDash(printerContext_0_2,
-      /* remove const */ (OPVP_Fix *)pdash,num);
-}
-
-opvp_result_t OPVPWrapper_0_2::GetLineDash(
-  opvp_int_t *pnum, opvp_fix_t *pdash)
-{
-    if (!supportGetLineDash) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->GetLineDash(printerContext_0_2,
-      pdash,pnum);
-}
-
-opvp_result_t OPVPWrapper_0_2::SetLineDashOffset(
-  opvp_fix_t offset)
-{
-    if (!supportSetLineDashOffset) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->SetLineDashOffset(printerContext_0_2,offset);
-}
-
-opvp_result_t OPVPWrapper_0_2::GetLineDashOffset(
-  opvp_fix_t *poffset)
-{
-    if (!supportGetLineDashOffset) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->GetLineDashOffset(printerContext_0_2,poffset);
-}
-
-opvp_result_t OPVPWrapper_0_2::SetLineStyle(
-  opvp_linestyle_t linestyle)
-{
-    if (!supportSetLineStyle) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    /* OPVP_LineStyle is compatible with opvp_linestyle_t */
-    return (opvp_result_t)procs_0_2->SetLineStyle(printerContext_0_2,
-      (OPVP_LineStyle)linestyle);
-}
-
-opvp_result_t OPVPWrapper_0_2::GetLineStyle(
-  opvp_linestyle_t *plinestyle)
-{
-    if (!supportGetLineStyle) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    /* OPVP_LineStyle is compatible with opvp_linestyle_t */
-    return (opvp_result_t)procs_0_2->GetLineStyle(printerContext_0_2,
-      (OPVP_LineStyle *)plinestyle);
-}
-
-opvp_result_t OPVPWrapper_0_2::SetLineCap(
-  opvp_linecap_t linecap)
-{
-    if (!supportSetLineCap) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    /* OPVP_LineCap is compatible with opvp_cap_t */
-    return (opvp_result_t)procs_0_2->SetLineCap(printerContext_0_2,
-      (OPVP_LineCap)linecap);
-}
-
-opvp_result_t OPVPWrapper_0_2::GetLineCap(
-  opvp_linecap_t *plinecap)
-{
-    if (!supportGetLineCap) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    /* OPVP_LineCap is compatible with opvp_cap_t */
-    return (opvp_result_t)procs_0_2->GetLineCap(printerContext_0_2,
-      (OPVP_LineCap *)plinecap);
-}
-
-opvp_result_t OPVPWrapper_0_2::SetLineJoin(
-  opvp_linejoin_t linejoin)
-{
-    if (!supportSetLineJoin) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    /* OPVP_LineJoin is compatible with opvp_linejoin_t */
-    return (opvp_result_t)procs_0_2->SetLineJoin(printerContext_0_2,
-      (OPVP_LineJoin)linejoin);
-}
-
-opvp_result_t OPVPWrapper_0_2::GetLineJoin(
-  opvp_linejoin_t *plinejoin)
-{
-    if (!supportGetLineJoin) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    /* OPVP_LineJoin is compatible with opvp_linejoin_t */
-    return (opvp_result_t)procs_0_2->GetLineJoin(printerContext_0_2,
-      (OPVP_LineJoin *)plinejoin);
-}
-
-opvp_result_t OPVPWrapper_0_2::SetMiterLimit(
-  opvp_fix_t miterlimit)
-{
-    if (!supportSetMiterLimit) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    /* OPVP_Fix is compatible with opvp_fix_t */
-    return (opvp_result_t)procs_0_2->SetMiterLimit(printerContext_0_2,
-      (OPVP_Fix)miterlimit);
-}
-
-opvp_result_t OPVPWrapper_0_2::GetMiterLimit(
-  opvp_fix_t *pmiterlimit)
-{
-    if (!supportGetMiterLimit) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    /* OPVP_Fix is compatible with opvp_fix_t */
-    return (opvp_result_t)procs_0_2->GetMiterLimit(printerContext_0_2,
-      (OPVP_Fix *)pmiterlimit);
-}
-
-opvp_result_t OPVPWrapper_0_2::SetPaintMode(
-  opvp_paintmode_t paintmode)
-{
-    if (!supportSetPaintMode) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    /* OPVP_PaintMode is compatible with opvp_paintmode_t */
-    return (opvp_result_t)procs_0_2->SetPaintMode(printerContext_0_2,
-      (OPVP_PaintMode)paintmode);
-}
-
-opvp_result_t OPVPWrapper_0_2::GetPaintMode(
-  opvp_paintmode_t *ppaintmode)
-{
-    if (!supportGetPaintMode) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    /* OPVP_PaintMode is compatible with opvp_paintmode_t */
-    return (opvp_result_t)procs_0_2->GetPaintMode(printerContext_0_2,
-      (OPVP_PaintMode *)ppaintmode);
-}
-
-opvp_result_t OPVPWrapper_0_2::SetStrokeColor(
-  const opvp_brush_t *brush)
-{
-    OPVP_Brush brush_0_2;
-
-    if (!supportSetStrokeColor) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    if (brush == 0) {
-	*opvpErrorNo_0_2 = OPVP_PARAMERROR_0_2;
-	return -1;
-    }
-    if (brush->colorSpace == OPVP_CSPACE_DEVICEKRGB) {
-	/* 0.2 doesn't have OPVP_CSPACE_DEVICEKRGB */
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    if ((unsigned int)brush->colorSpace
-	 > sizeof(cspace_1_0_to_0_2)/sizeof(OPVP_ColorSpace)) {
-	/* unknown color space */
-	*opvpErrorNo_0_2 = OPVP_PARAMERROR_0_2;
-	return -1;
-    }
-    brush_0_2.colorSpace = cspace_1_0_to_0_2[brush->colorSpace];
-    brush_0_2.xorg = brush->xorg;
-    brush_0_2.yorg = brush->yorg;
-    brush_0_2.pbrush = (OPVP_BrushData *)brush->pbrush;
-    memcpy(brush_0_2.color,brush->color,sizeof(brush_0_2.color));
-    return (opvp_result_t)procs_0_2->SetStrokeColor(printerContext_0_2,
-      &brush_0_2);
-}
-
-opvp_result_t OPVPWrapper_0_2::SetFillColor(
-  const opvp_brush_t *brush)
-{
-    OPVP_Brush brush_0_2;
-
-    if (!supportSetFillColor) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    if (brush == 0) {
-	*opvpErrorNo_0_2 = OPVP_PARAMERROR_0_2;
-	return -1;
-    }
-    if (brush->colorSpace == OPVP_CSPACE_DEVICEKRGB) {
-	/* 0.2 doesn't have OPVP_CSPACE_DEVICEKRGB */
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    if ((unsigned int)brush->colorSpace
-	 > sizeof(cspace_1_0_to_0_2)/sizeof(OPVP_ColorSpace)) {
-	/* unknown color space */
-	*opvpErrorNo_0_2 = OPVP_PARAMERROR_0_2;
-	return -1;
-    }
-    brush_0_2.colorSpace = cspace_1_0_to_0_2[brush->colorSpace];
-    brush_0_2.xorg = brush->xorg;
-    brush_0_2.yorg = brush->yorg;
-    brush_0_2.pbrush = (OPVP_BrushData *)brush->pbrush;
-    memcpy(brush_0_2.color,brush->color,sizeof(brush_0_2.color));
-    return (opvp_result_t)procs_0_2->SetFillColor(printerContext_0_2,
-      &brush_0_2);
-}
-
-opvp_result_t OPVPWrapper_0_2::SetBgColor(
-  const opvp_brush_t *brush)
-{
-    OPVP_Brush brush_0_2;
-
-    if (!supportSetBgColor) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    if (brush == 0) {
-	*opvpErrorNo_0_2 = OPVP_PARAMERROR_0_2;
-	return -1;
-    }
-    if (brush->colorSpace == OPVP_CSPACE_DEVICEKRGB) {
-	/* 0.2 doesn't have OPVP_CSPACE_DEVICEKRGB */
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    if ((unsigned int)brush->colorSpace
-	 > sizeof(cspace_1_0_to_0_2)/sizeof(OPVP_ColorSpace)) {
-	/* unknown color space */
-	*opvpErrorNo_0_2 = OPVP_PARAMERROR_0_2;
-	return -1;
-    }
-    brush_0_2.colorSpace = cspace_1_0_to_0_2[brush->colorSpace];
-    brush_0_2.xorg = brush->xorg;
-    brush_0_2.yorg = brush->yorg;
-    brush_0_2.pbrush = (OPVP_BrushData *)brush->pbrush;
-    memcpy(brush_0_2.color,brush->color,sizeof(brush_0_2.color));
-    return (opvp_result_t)procs_0_2->SetBgColor(printerContext_0_2,
-      &brush_0_2);
-}
-
-opvp_result_t OPVPWrapper_0_2::NewPath()
-{
-    if (!supportNewPath) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->NewPath(printerContext_0_2);
-}
-
-opvp_result_t OPVPWrapper_0_2::EndPath()
-{
-    if (!supportEndPath) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->EndPath(printerContext_0_2);
-}
-
-opvp_result_t OPVPWrapper_0_2::StrokePath()
-{
-    if (!supportStrokePath) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->StrokePath(printerContext_0_2);
-}
-
-opvp_result_t OPVPWrapper_0_2::FillPath()
-{
-    if (!supportFillPath) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->FillPath(printerContext_0_2);
-}
-
-opvp_result_t OPVPWrapper_0_2::StrokeFillPath()
-{
-    if (!supportStrokeFillPath) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->StrokeFillPath(printerContext_0_2);
-}
-
-opvp_result_t OPVPWrapper_0_2::SetClipPath(
-  opvp_cliprule_t clipRule)
-{
-    if (!supportSetClipPath) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    /* OPVP_ClipRule is compatible with opvp_cliprule_t */
-    return (opvp_result_t)procs_0_2->SetClipPath(printerContext_0_2,
-      (OPVP_ClipRule)clipRule);
-}
-
-opvp_result_t OPVPWrapper_0_2::SetCurrentPoint(
-  opvp_fix_t x, opvp_fix_t y)
-{
-    if (!supportSetCurrentPoint) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->SetCurrentPoint(printerContext_0_2,x,y);
-}
-
-opvp_result_t OPVPWrapper_0_2::LinePath(
-  opvp_pathmode_t flag, opvp_int_t npoints, const opvp_point_t *points)
-{
-    if (!supportLinePath) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    /* OPVP_Point is compatible with opvp_point_t */
-    return (opvp_result_t)procs_0_2->LinePath(printerContext_0_2,flag,npoints,
-      (OPVP_Point *)points);
-}
-
-opvp_result_t OPVPWrapper_0_2::PolygonPath(
-  opvp_int_t npolygons, const opvp_int_t *nvertexes,
-  const opvp_point_t *points)
-{
-    if (!supportPolygonPath) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    /* OPVP_Point is compatible with opvp_point_t */
-    return (opvp_result_t)procs_0_2->PolygonPath(printerContext_0_2,
-      (int)npolygons,(int *)nvertexes,(OPVP_Point *)points);
-}
-
-opvp_result_t OPVPWrapper_0_2::RectanglePath(
-  opvp_int_t nrectangles, const opvp_rectangle_t *rectangles)
-{
-    if (!supportRectanglePath) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    /* OPVP_Rectangle is compatible with opvp_rectangle_t */
-    return (opvp_result_t)procs_0_2->RectanglePath(printerContext_0_2,
-      (int)nrectangles,(OPVP_Rectangle *)rectangles);
-}
-
-opvp_result_t OPVPWrapper_0_2::RoundRectanglePath(
-  opvp_int_t nrectangles, const opvp_roundrectangle_t *rectangles)
-{
-    if (!supportRoundRectanglePath) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    /* OPVP_RoundRectangle is compatible with opvp_roundrectangle_t */
-    return (opvp_result_t)procs_0_2->RoundRectanglePath(printerContext_0_2,
-      (int)nrectangles,(OPVP_RoundRectangle *)rectangles);
-}
-
-opvp_result_t OPVPWrapper_0_2::BezierPath(opvp_int_t npoints,
-    const opvp_point_t *points)
-{
-    if (!supportBezierPath) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    /* OPVP_Point is compatible with opvp_point_t */
-    return (opvp_result_t)procs_0_2->BezierPath(printerContext_0_2,(int)npoints,
-      (OPVP_Point *)points);
-}
-
-opvp_result_t OPVPWrapper_0_2::ArcPath(opvp_arcmode_t kind, opvp_arcdir_t dir,
-  opvp_fix_t bbx0, opvp_fix_t bby0, opvp_fix_t bbx1,
-  opvp_fix_t bby1, opvp_fix_t x0, opvp_fix_t y0, opvp_fix_t x1, opvp_fix_t y1)
-{
-    if (!supportArcPath) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    /* opvp_arcmode_t is compatible with int */
-    /* opvp_arcdir_t is compatible with int */
-    return (opvp_result_t)procs_0_2->ArcPath(printerContext_0_2,
-      (int)kind,(int)dir,bbx0,bby0,
-       bbx1,bby1,x0,y0,x1,y1);
-}
-
-opvp_result_t OPVPWrapper_0_2::DrawImage(opvp_int_t sourceWidth,
-    opvp_int_t sourceHeight, opvp_int_t sourcePitch,
-    opvp_imageformat_t imageFormat, opvp_int_t destinationWidth,
-    opvp_int_t destinationHeight, const void *imagedata)
-{
-    int r;
-    OPVP_Rectangle rect;
-    OPVP_ImageFormat iformat_0_2;
-    OPVP_PaintMode paintmode_0_2 = OPVP_paintModeTransparent;
-    int depth;
-
-    if (!supportDrawImage) {
-      int result;
-
-      if ((result = StartDrawImage(sourceWidth,
-	sourceHeight,sourcePitch,imageFormat,destinationWidth,
-	destinationHeight)) < 0) {
-	return result;
-      }
-      if ((result = TransferDrawImage(sourcePitch*sourceHeight,
-        imagedata)) < 0) {
-	return result;
-      }
-      return EndDrawImage();
-    }
-
-    if (imageFormat == OPVP_IFORMAT_MASK) {
-	if (procs_0_2->GetPaintMode != 0) {
-	    procs_0_2->GetPaintMode(printerContext_0_2,
-	      &paintmode_0_2);
-	}
-	if (paintmode_0_2 != OPVP_paintModeTransparent) {
-	    if (procs_0_2->SetROP != 0) {
-		procs_0_2->SetROP(printerContext_0_2,
-		    OPVP_0_2_ROP_S);
-	    }
-	}
-	else {
-	    if (procs_0_2->SetROP != 0) {
-		procs_0_2->SetROP(printerContext_0_2,
-		    OPVP_0_2_ROP_OR);
-	    }
-	}
-	depth = 1;
-    } else {
-	if (procs_0_2->SetROP != 0) {
-	    procs_0_2->SetROP(printerContext_0_2,OPVP_0_2_ROP_S);
-	}
-	depth = colorDepth_0_2[colorSpace];
-    }
-
-    OPVP_I2FIX(0,rect.p0.x);
-    OPVP_I2FIX(0,rect.p0.y);
-    OPVP_I2FIX(destinationWidth,rect.p1.x);
-    OPVP_I2FIX(destinationHeight,rect.p1.y);
-    if ((unsigned int)imageFormat 
-      > sizeof(iformat_1_0_to_0_2)/sizeof(OPVP_ImageFormat)) {
-	/* illegal image format */
-	*opvpErrorNo_0_2 = OPVP_PARAMERROR_0_2;
-	return -1;
-    }
-    iformat_0_2 = iformat_1_0_to_0_2[imageFormat];
-    r = procs_0_2->DrawImage(printerContext_0_2,sourceWidth,sourceHeight,
-	    depth,iformat_0_2,rect,
-	    sourcePitch*sourceHeight,
-	    /* remove const */ (void *)imagedata);
-
-    if (procs_0_2->SetROP != 0) {
-        procs_0_2->SetROP(printerContext_0_2,OPVP_0_2_ROP_P);
-    }
-
-    return (opvp_result_t)r;
-}
-
-opvp_result_t OPVPWrapper_0_2::StartDrawImage(opvp_int_t sourceWidth,
-    opvp_int_t sourceHeight, opvp_int_t sourcePitch,
-    opvp_imageformat_t imageFormat, opvp_int_t destinationWidth,
-    opvp_int_t destinationHeight)
-{
-    int r;
-    OPVP_Rectangle rect;
-    OPVP_ImageFormat iformat_0_2;
-    OPVP_PaintMode paintmode_0_2 = OPVP_paintModeTransparent;
-    int depth;
-
-    if (!supportStartDrawImage) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    if (imageFormat == OPVP_IFORMAT_MASK) {
-	if (procs_0_2->GetPaintMode != 0) {
-	    procs_0_2->GetPaintMode(printerContext_0_2,
-	      &paintmode_0_2);
-	}
-	if (paintmode_0_2 != OPVP_paintModeTransparent) {
-	    if (procs_0_2->SetROP != 0) {
-		procs_0_2->SetROP(printerContext_0_2,OPVP_0_2_ROP_S);
-	    }
-	}
-	else {
-	    if (procs_0_2->SetROP != 0) {
-		procs_0_2->SetROP(printerContext_0_2,OPVP_0_2_ROP_OR);
-	    }
-	}
-	depth = 1;
-    } else {
-	if (procs_0_2->SetROP != 0) {
-	    procs_0_2->SetROP(printerContext_0_2,OPVP_0_2_ROP_S);
-	}
-	depth = colorDepth_0_2[colorSpace];
-    }
-
-    OPVP_I2FIX(0,rect.p0.x);
-    OPVP_I2FIX(0,rect.p0.y);
-    OPVP_I2FIX(destinationWidth,rect.p1.x);
-    OPVP_I2FIX(destinationHeight,rect.p1.y);
-    if ((unsigned int)imageFormat
-      > sizeof(iformat_1_0_to_0_2)/sizeof(OPVP_ImageFormat)) {
-	/* illegal image format */
-	*opvpErrorNo_0_2 = OPVP_PARAMERROR_0_2;
-	return -1;
-    }
-    iformat_0_2 = iformat_1_0_to_0_2[imageFormat];
-    r = procs_0_2->StartDrawImage(printerContext_0_2,
-	    sourceWidth,sourceHeight,
-	    depth,iformat_0_2,rect);
-
-    return (opvp_result_t)r;
-}
-
-opvp_result_t OPVPWrapper_0_2::TransferDrawImage(opvp_int_t count,
-    const void *imagedata)
-{
-    if (!supportTransferDrawImage) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->TransferDrawImage(printerContext_0_2,
-      count,(void *)imagedata);
-}
-
-opvp_result_t OPVPWrapper_0_2::EndDrawImage()
-{
-    int r;
-
-    if (!supportEndDrawImage) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    r = procs_0_2->EndDrawImage(printerContext_0_2);
-
-    /* make sure rop is pattern copy */
-    if (procs_0_2->SetROP != 0) {
-	procs_0_2->SetROP(printerContext_0_2,OPVP_0_2_ROP_P);
-    }
-
-    return (opvp_result_t)r;
-}
-
-opvp_result_t OPVPWrapper_0_2::StartScanline(opvp_int_t yposition)
-{
-    if (!supportStartScanline) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->StartScanline(printerContext_0_2,yposition);
-}
-
-opvp_result_t OPVPWrapper_0_2::Scanline(opvp_int_t nscanpairs,
-  const opvp_int_t *scanpairs)
-{
-    if (!supportScanline) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->Scanline(printerContext_0_2,
-      (int)nscanpairs,(int *)scanpairs);
-}
-
-opvp_result_t OPVPWrapper_0_2::EndScanline()
-{
-    if (!supportEndScanline) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->EndScanline(printerContext_0_2);
-}
-
-opvp_result_t OPVPWrapper_0_2::StartRaster(opvp_int_t rasterWidth)
-{
-    if (!supportStartRaster) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->StartRaster(printerContext_0_2,rasterWidth);
-}
-
-opvp_result_t OPVPWrapper_0_2::TransferRasterData(opvp_int_t count,
-    const opvp_byte_t *data)
-{
-    if (!supportTransferRasterData) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->TransferRasterData(printerContext_0_2,
-      (int)count, (unsigned char *)data);
-}
-
-opvp_result_t OPVPWrapper_0_2::SkipRaster(opvp_int_t count)
-{
-    if (!supportSkipRaster) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->SkipRaster(printerContext_0_2,count);
-}
-
-opvp_result_t OPVPWrapper_0_2::EndRaster()
-{
-    if (!supportEndRaster) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->EndRaster(printerContext_0_2);
-}
-
-opvp_result_t OPVPWrapper_0_2::StartStream()
-{
-    if (!supportStartStream) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->StartStream(printerContext_0_2);
-}
-
-opvp_result_t OPVPWrapper_0_2::TransferStreamData(opvp_int_t count,
-  const void *data)
-{
-    if (!supportTransferStreamData) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->TransferStreamData(printerContext_0_2,
-      count,(void *)data);
-}
-
-opvp_result_t OPVPWrapper_0_2::EndStream()
-{
-    if (!supportEndStream) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->EndStream(printerContext_0_2);
-}
-
-opvp_result_t OPVPWrapper_0_2::ResetClipPath()
-{
-    if (!supportResetClipPath) {
-	*opvpErrorNo_0_2 = OPVP_NOTSUPPORTED_0_2;
-	return -1;
-    }
-    return (opvp_result_t)procs_0_2->ResetClipPath(printerContext_0_2);
-}
-
-/* translate error code */
-opvp_int_t OPVPWrapper_0_2::getErrorNo()
-{
-    switch(*opvpErrorNo_0_2) {
-    case OPVP_FATALERROR_0_2:
-	return OPVP_FATALERROR; 
-	break;
-    case OPVP_BADREQUEST_0_2:
-	return OPVP_BADREQUEST; 
-	break;
-    case OPVP_BADCONTEXT_0_2:
-	return OPVP_BADCONTEXT; 
-	break;
-    case OPVP_NOTSUPPORTED_0_2:
-	return OPVP_NOTSUPPORTED; 
-	break;
-    case OPVP_JOBCANCELED_0_2:
-	return OPVP_JOBCANCELED; 
-	break;
-    case OPVP_PARAMERROR_0_2:
-	return OPVP_PARAMERROR; 
-	break;
-    default:
-	break;
-    }
-    /* unknown error no */
-    /* return FATALERROR instead */
-    return OPVP_FATALERROR;
-}
diff --git a/filter/pdftoopvp/oprs/OPVPWrapper_0_2.h b/filter/pdftoopvp/oprs/OPVPWrapper_0_2.h
deleted file mode 100644
index f670a45..0000000
--- a/filter/pdftoopvp/oprs/OPVPWrapper_0_2.h
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
-  OPVPWrapper_0_2.h
-*/
-
-#ifndef OPVPWRAPPER_0_2_H
-#define OPVPWRAPPER_0_2_H
-
-#include "OPVPWrapper.h"
-
-/* ROP */
-#define OPVP_0_2_ROP_S  0xCC
-#define OPVP_0_2_ROP_P  0xF0
-#define OPVP_0_2_ROP_OR 0xB8
-
-class OPVPWrapper_0_2: public OPVPWrapper {
-private:
-    static opvp_cspace_t cspace_0_2_to_1_0[];
-    static OPVP_ColorSpace cspace_1_0_to_0_2[];
-    static OPVP_ImageFormat iformat_1_0_to_0_2[];
-    static int colorDepth_0_2[];
-public:
-    OPVPWrapper_0_2(void *opvpHandleA, int *opvpErrorNoA,
-      OPVP_api_procs *procsA, int printerContextA);
-    virtual ~OPVPWrapper_0_2();
-    virtual opvp_int_t getErrorNo(); 
-
-    virtual opvp_result_t ClosePrinter();
-    virtual opvp_result_t StartJob(const opvp_char_t *jobInfo);
-    virtual opvp_result_t EndJob();
-    virtual opvp_result_t AbortJob();
-    virtual opvp_result_t StartDoc(const opvp_char_t *docInfo);
-    virtual opvp_result_t EndDoc();
-    virtual opvp_result_t StartPage(const opvp_char_t *pageInfo);
-    virtual opvp_result_t EndPage();
-    virtual opvp_result_t QueryDeviceCapability(opvp_flag_t queryflag,
-      opvp_int_t *buflen, opvp_byte_t *infoBuf);
-    virtual opvp_result_t QueryDeviceInfo(opvp_flag_t queryflag,
-      opvp_int_t *buflen, opvp_byte_t *infoBuf);
-    virtual opvp_result_t ResetCTM();
-    virtual opvp_result_t SetCTM(const opvp_ctm_t *pCTM);
-    virtual opvp_result_t GetCTM(opvp_ctm_t *pCTM);
-    virtual opvp_result_t InitGS();
-    virtual opvp_result_t SaveGS();
-    virtual opvp_result_t RestoreGS();
-    virtual opvp_result_t QueryColorSpace(opvp_int_t *pnum,
-      opvp_cspace_t *pcspace);
-    virtual opvp_result_t SetColorSpace(opvp_cspace_t cspace);
-    virtual opvp_result_t GetColorSpace(opvp_cspace_t *pcspace);
-    virtual opvp_result_t SetFillMode(opvp_fillmode_t fillmode);
-    virtual opvp_result_t GetFillMode(opvp_fillmode_t *pfillmode);
-    virtual opvp_result_t SetAlphaConstant(opvp_float_t alpha);
-    virtual opvp_result_t GetAlphaConstant(opvp_float_t *palpha);
-    virtual opvp_result_t SetLineWidth(opvp_fix_t width);
-    virtual opvp_result_t GetLineWidth(opvp_fix_t *pwidth);
-    virtual opvp_result_t SetLineDash(opvp_int_t num, const opvp_fix_t *pdash);
-    virtual opvp_result_t GetLineDash(opvp_int_t *pnum, opvp_fix_t *pdash);
-    virtual opvp_result_t SetLineDashOffset(opvp_fix_t offset);
-    virtual opvp_result_t GetLineDashOffset(opvp_fix_t *poffset);
-    virtual opvp_result_t SetLineStyle(opvp_linestyle_t linestyle);
-    virtual opvp_result_t GetLineStyle(opvp_linestyle_t *plinestyle);
-    virtual opvp_result_t SetLineCap(opvp_linecap_t linecap);
-    virtual opvp_result_t GetLineCap(opvp_linecap_t *plinecap);
-    virtual opvp_result_t SetLineJoin(opvp_linejoin_t linejoin);
-    virtual opvp_result_t GetLineJoin(opvp_linejoin_t *plinejoin);
-    virtual opvp_result_t SetMiterLimit(opvp_fix_t miterlimit);
-    virtual opvp_result_t GetMiterLimit(opvp_fix_t *pmiterlimit);
-    virtual opvp_result_t SetPaintMode(opvp_paintmode_t paintmode);
-    virtual opvp_result_t GetPaintMode(opvp_paintmode_t *ppaintmode);
-    virtual opvp_result_t SetStrokeColor(const opvp_brush_t *brush);
-    virtual opvp_result_t SetFillColor(const opvp_brush_t *brush);
-    virtual opvp_result_t SetBgColor(const opvp_brush_t *brush);
-    virtual opvp_result_t NewPath();
-    virtual opvp_result_t EndPath();
-    virtual opvp_result_t StrokePath();
-    virtual opvp_result_t FillPath();
-    virtual opvp_result_t StrokeFillPath();
-    virtual opvp_result_t SetClipPath(opvp_cliprule_t clipRule);
-    virtual opvp_result_t SetCurrentPoint(opvp_fix_t x, opvp_fix_t y);
-    virtual opvp_result_t LinePath(opvp_pathmode_t flag,
-      opvp_int_t npoints, const opvp_point_t *points);
-    virtual opvp_result_t PolygonPath(opvp_int_t npolygons,
-      const opvp_int_t *nvertexes, const opvp_point_t *points);
-    virtual opvp_result_t RectanglePath(opvp_int_t nrectangles,
-      const opvp_rectangle_t *reclangles);
-    virtual opvp_result_t RoundRectanglePath(opvp_int_t nrectangles,
-      const opvp_roundrectangle_t *reclangles);
-    virtual opvp_result_t BezierPath(opvp_int_t npoints,
-      const opvp_point_t *points);
-    virtual opvp_result_t ArcPath(opvp_arcmode_t kind,
-      opvp_arcdir_t dir, opvp_fix_t bbx0, opvp_fix_t bby0,
-      opvp_fix_t bbx1, opvp_fix_t bby1, opvp_fix_t x0,
-      opvp_fix_t y0, opvp_fix_t x1, opvp_fix_t y1);
-    virtual opvp_result_t DrawImage(opvp_int_t sourceWidth,
-      opvp_int_t sourceHeight, opvp_int_t sourcePitch,
-      opvp_imageformat_t imageFormat,
-      opvp_int_t destinationWidth, opvp_int_t destinationHeight,
-      const void *imageData);
-    virtual opvp_result_t StartDrawImage(opvp_int_t sourceWidth,
-      opvp_int_t sourceHeight, opvp_int_t sourcePitch,
-      opvp_imageformat_t imageFormat,
-      opvp_int_t destinationWidth, opvp_int_t destinationHeight);
-    virtual opvp_result_t TransferDrawImage(opvp_int_t count,
-      const void *imageData);
-    virtual opvp_result_t EndDrawImage();
-    virtual opvp_result_t StartScanline(opvp_int_t yposition);
-    virtual opvp_result_t Scanline(opvp_int_t nscanpairs,
-      const opvp_int_t *scanpairs);
-    virtual opvp_result_t EndScanline();
-    virtual opvp_result_t StartRaster(opvp_int_t rasterWidth);
-    virtual opvp_result_t TransferRasterData(opvp_int_t count,
-      const opvp_byte_t *data);
-    virtual opvp_result_t SkipRaster(opvp_int_t count);
-    virtual opvp_result_t EndRaster();
-    virtual opvp_result_t StartStream();
-    virtual opvp_result_t TransferStreamData(opvp_int_t count,
-      const void *data);
-    virtual opvp_result_t EndStream();
-    virtual opvp_result_t ResetClipPath();
-
-private:
-    OPVP_api_procs *procs_0_2;
-    int *opvpErrorNo_0_2;
-    int printerContext_0_2;
-    opvp_cspace_t colorSpace;
-};
-
-#endif
diff --git a/filter/pdftoopvp/opvp/opvp.h b/filter/pdftoopvp/opvp/opvp.h
deleted file mode 100644
index 41ade3a..0000000
--- a/filter/pdftoopvp/opvp/opvp.h
+++ /dev/null
@@ -1,292 +0,0 @@
-/*
- * OpenPrinting Vector Printer Driver API Definitions [opvp.h]
- *
- * Copyright (c) 2006 Free Standards Group
- * Copyright (c) 2006 Fuji Xerox Printing Systems Co., Ltd.
- * Copyright (c) 2006 Canon Inc.
- * Copyright (c) 2003-2006 AXE Inc.
- *
- * All Rights Reserverd.
- *
- * Permission to use, copy, modify, distribute, and sell this software
- * and its documentation for any purpose is hereby granted without
- * fee, provided that the above copyright notice appear in all copies
- * and that both that copyright notice and this permission notice
- * appear in supporting documentation.
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT.  IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
- * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
- /*
-  2007 Modified  for OPVP 1.0 by BBR Inc.
- */
-
-#ifndef _OPVP_H_
-#define _OPVP_H_
-
-/* Return Values and Error Codes */
-#define OPVP_OK			0	/* -1 for errors */
-#define OPVP_FATALERROR		-1	/* error: cannot be recovered */
-#define OPVP_BADREQUEST		-2	/* error: called where it should
-					          not be called */
-#define OPVP_BADCONTEXT		-3	/* error: invalid printer context */
-#define OPVP_NOTSUPPORTED	-4	/* error: combination of
-						  parameters are set
-					          which cannot be handled
-						  by driver or printer */
-#define OPVP_JOBCANCELED	-5	/* error: job has been canceled
-					          by some cause */
-#define OPVP_PARAMERROR		-6	/* error: invalid parameter */
-#define OPVP_VERSIONERROR	-7	/* error: invalid API version */
-
-/* Basic Types */
-typedef int opvp_dc_t;			/* driver/device context */
-typedef int opvp_result_t;		/* return value */
-typedef unsigned char opvp_byte_t;	/* BYTE */
-typedef unsigned char opvp_char_t;	/* character (string) */
-typedef int opvp_int_t;			/* integer */
-typedef int opvp_fix_t;			/* fixed integer */
-typedef float opvp_float_t;		/* float */
-typedef unsigned int opvp_flag_t;	/* flags */
-typedef unsigned int opvp_rop_t;		/* raster operation */
-
-/* for opvp_fix_t */
-#define OPVP_FIX_FRACT_WIDTH    8
-#define OPVP_FIX_FRACT_DENOM    (1<<OPVP_FIX_FRACT_WIDTH)
-#define OPVP_FIX_FLOOR_WIDTH    (sizeof(int)*8-OPVP_FIX_FRACT_WIDTH)
-
-/* convert macro */
-#define	OPVP_I2FIX(i,fix)	(fix=(i)<<OPVP_FIX_FRACT_WIDTH)
-#define	OPVP_F2FIX(f,fix)	(fix=((int)floor(f)<<OPVP_FIX_FRACT_WIDTH)\
-				    |((int)((f-floor(f))*OPVP_FIX_FRACT_DENOM)\
-				      &(OPVP_FIX_FRACT_DENOM-1)))
-
-/* graphic elements */
-typedef struct _opvp_point {
-	opvp_fix_t x, y;
-} opvp_point_t;
-
-typedef struct _opvp_rectangle {
-	opvp_point_t p0;			/* start point */
-	opvp_point_t p1;			/* diagonal point */
-} opvp_rectangle_t;
-
-typedef struct _opvp_roundrectangle {
-	opvp_point_t p0;			/* start point */
-	opvp_point_t p1;			/* diagonal point */
-	opvp_fix_t xellipse, yellipse;
-} opvp_roundrectangle_t;
-
-/* Image Formats */
-typedef enum _opvp_imageformat {
-	OPVP_IFORMAT_RAW		= 0, 
-	OPVP_IFORMAT_MASK		= 1, 
-	OPVP_IFORMAT_RLE		= 2,
-	OPVP_IFORMAT_JPEG		= 3,
-	OPVP_IFORMAT_PNG		= 4
-} opvp_imageformat_t;
-
-/* Color Presentation */
-typedef enum _opvp_colormapping {
-	OPVP_CMAP_DIRECT		= 0,
-	OPVP_CMAP_INDEXED		= 1
-} opvp_colormapping_t;
-
-typedef enum _opvp_cspace {
-	OPVP_CSPACE_BW			= 0,
-	OPVP_CSPACE_DEVICEGRAY		= 1,
-	OPVP_CSPACE_DEVICECMY		= 2,
-	OPVP_CSPACE_DEVICECMYK		= 3,
-	OPVP_CSPACE_DEVICERGB		= 4,
-	OPVP_CSPACE_DEVICEKRGB		= 5,
-	OPVP_CSPACE_STANDARDRGB		= 6,
-	OPVP_CSPACE_STANDARDRGB64	= 7
-} opvp_cspace_t;
-
-/* Fill, Paint, Clip */
-typedef enum _opvp_fillmode {
-	OPVP_FILLMODE_EVENODD		= 0,
-	OPVP_FILLMODE_WINDING		= 1
-} opvp_fillmode_t;
-
-typedef enum _opvp_paintmode {
-	OPVP_PAINTMODE_OPAQUE		= 0,
-	OPVP_PAINTMODE_TRANSPARENT	= 1
-} opvp_paintmode_t;
-
-typedef enum _opvp_cliprule {
-	OPVP_CLIPRULE_EVENODD		= 0,
-	OPVP_CLIPRULE_WINDING		= 1
-} opvp_cliprule_t;
-
-/* Line */
-typedef enum _opvp_linestyle {
-	OPVP_LINESTYLE_SOLID		= 0,
-	OPVP_LINESTYLE_DASH		= 1
-} opvp_linestyle_t;
-
-typedef enum _opvp_linecap {
-	OPVP_LINECAP_BUTT		= 0,
-	OPVP_LINECAP_ROUND		= 1,
-	OPVP_LINECAP_SQUARE		= 2
-} opvp_linecap_t;
-
-typedef enum _opvp_linejoin {
-	OPVP_LINEJOIN_MITER		= 0,
-	OPVP_LINEJOIN_ROUND		= 1,
-	OPVP_LINEJOIN_BEVEL		= 2
-} opvp_linejoin_t;
-
-/* Brush */
-typedef enum _opvp_bdtype {
-	OPVP_BDTYPE_NORMAL		= 0
-} opvp_bdtype_t;
-
-typedef struct _opvp_brushdata {
-	opvp_bdtype_t type;
-	opvp_int_t width, height, pitch;
-	opvp_byte_t data[1];
-    
-} opvp_brushdata_t;
-
-typedef struct _opvp_brush {
-	opvp_cspace_t colorSpace;
-	opvp_int_t color[4];		/* aRGB quadruplet */
-	opvp_int_t xorg, yorg;		/* brush origin */
-					/* ignored for opvpSetBgColor */
-	opvp_brushdata_t *pbrush;	/* pointer to brush data */
-					/* solid brush used, if NULL */
-} opvp_brush_t;
-
-/* Misc. Flags */
-typedef enum _opvp_arcmode {
-	OPVP_ARC			= 0,
-	OPVP_CHORD			= 1,
-	OPVP_PIE			= 2
-} opvp_arcmode_t;
-
-typedef enum _opvp_arcdir {
-	OPVP_CLOCKWISE			= 0,
-	OPVP_COUNTERCLOCKWISE		= 1
-} opvp_arcdir_t;
-
-typedef enum _opvp_pathmode {
-	OPVP_PATHCLOSE			= 0,
-	OPVP_PATHOPEN			= 1
-} opvp_pathmode_t;
-
-/* CTM */
-typedef struct _opvp_ctm {
-	opvp_float_t a, b, c, d, e, f;
-} opvp_ctm_t;
-
-/* Device Information and Capabilites */
-typedef enum _opvp_queryinfoflags {
-  OPVP_QF_DEVICERESOLUTION	= 0x00000001,
-  OPVP_QF_MEDIASIZE		= 0x00000002,
-  OPVP_QF_PAGEROTATION		= 0x00000004,
-  OPVP_QF_MEDIANUP		= 0x00000008,
-  OPVP_QF_MEDIADUPLEX		= 0x00000010,
-  OPVP_QF_MEDIASOURCE		= 0x00000020,
-  OPVP_QF_MEDIADESTINATION	= 0x00000040,
-  OPVP_QF_MEDIATYPE		= 0x00000080,
-  OPVP_QF_MEDIACOPY		= 0x00000100, /* Maximum copy number
-  					         supported */
-  OPVP_QF_PRINTREGION		= 0x00010000  /* only for opvpQueryDeviceInfo */
-} opvp_queryinfoflags_t;
-
-
-/* API Procedure Entries */
-typedef	struct _opvp_api_procs {
-	opvp_dc_t     (*opvpOpenPrinter)(opvp_int_t,const opvp_char_t*,const opvp_int_t[2],struct _opvp_api_procs**);
-	opvp_result_t (*opvpClosePrinter)(opvp_dc_t);
-	opvp_result_t (*opvpStartJob)(opvp_dc_t,const opvp_char_t*);
-	opvp_result_t (*opvpEndJob)(opvp_dc_t);
-	opvp_result_t (*opvpAbortJob)(opvp_dc_t);
-	opvp_result_t (*opvpStartDoc)(opvp_dc_t,const opvp_char_t*);
-	opvp_result_t (*opvpEndDoc)(opvp_dc_t);
-	opvp_result_t (*opvpStartPage)(opvp_dc_t,const opvp_char_t*);
-	opvp_result_t (*opvpEndPage)(opvp_dc_t);
-	opvp_result_t (*opvpQueryDeviceCapability)(opvp_dc_t,opvp_flag_t,opvp_int_t*,opvp_byte_t*);
-	opvp_result_t (*opvpQueryDeviceInfo)(opvp_dc_t,opvp_flag_t,opvp_int_t*,opvp_char_t*);
-	opvp_result_t (*opvpResetCTM)(opvp_dc_t);
-	opvp_result_t (*opvpSetCTM)(opvp_dc_t,const opvp_ctm_t*);
-	opvp_result_t (*opvpGetCTM)(opvp_dc_t,opvp_ctm_t*);
-	opvp_result_t (*opvpInitGS)(opvp_dc_t);
-	opvp_result_t (*opvpSaveGS)(opvp_dc_t);
-	opvp_result_t (*opvpRestoreGS)(opvp_dc_t);
-	opvp_result_t (*opvpQueryColorSpace)(opvp_dc_t,opvp_int_t*,opvp_cspace_t*);
-	opvp_result_t (*opvpSetColorSpace)(opvp_dc_t,opvp_cspace_t);
-	opvp_result_t (*opvpGetColorSpace)(opvp_dc_t,opvp_cspace_t*);
-	opvp_result_t (*opvpSetFillMode)(opvp_dc_t,opvp_fillmode_t);
-	opvp_result_t (*opvpGetFillMode)(opvp_dc_t,opvp_fillmode_t*);
-	opvp_result_t (*opvpSetAlphaConstant)(opvp_dc_t,opvp_float_t);
-	opvp_result_t (*opvpGetAlphaConstant)(opvp_dc_t,opvp_float_t*);
-	opvp_result_t (*opvpSetLineWidth)(opvp_dc_t,opvp_fix_t);
-	opvp_result_t (*opvpGetLineWidth)(opvp_dc_t,opvp_fix_t*);
-	opvp_result_t (*opvpSetLineDash)(opvp_dc_t,opvp_int_t,const opvp_fix_t*);
-	opvp_result_t (*opvpGetLineDash)(opvp_dc_t,opvp_int_t*,opvp_fix_t*);
-	opvp_result_t (*opvpSetLineDashOffset)(opvp_dc_t,opvp_fix_t);
-	opvp_result_t (*opvpGetLineDashOffset)(opvp_dc_t,opvp_fix_t*);
-	opvp_result_t (*opvpSetLineStyle)(opvp_dc_t,opvp_linestyle_t);
-	opvp_result_t (*opvpGetLineStyle)(opvp_dc_t,opvp_linestyle_t*);
-	opvp_result_t (*opvpSetLineCap)(opvp_dc_t,opvp_linecap_t);
-	opvp_result_t (*opvpGetLineCap)(opvp_dc_t,opvp_linecap_t*);
-	opvp_result_t (*opvpSetLineJoin)(opvp_dc_t,opvp_linejoin_t);
-	opvp_result_t (*opvpGetLineJoin)(opvp_dc_t,opvp_linejoin_t*);
-	opvp_result_t (*opvpSetMiterLimit)(opvp_dc_t,opvp_fix_t);
-	opvp_result_t (*opvpGetMiterLimit)(opvp_dc_t,opvp_fix_t*);
-	opvp_result_t (*opvpSetPaintMode)(opvp_dc_t,opvp_paintmode_t);
-	opvp_result_t (*opvpGetPaintMode)(opvp_dc_t,opvp_paintmode_t*);
-	opvp_result_t (*opvpSetStrokeColor)(opvp_dc_t,const opvp_brush_t*);
-	opvp_result_t (*opvpSetFillColor)(opvp_dc_t,const opvp_brush_t*);
-	opvp_result_t (*opvpSetBgColor)(opvp_dc_t,const opvp_brush_t*);
-	opvp_result_t (*opvpNewPath)(opvp_dc_t);
-	opvp_result_t (*opvpEndPath)(opvp_dc_t);
-	opvp_result_t (*opvpStrokePath)(opvp_dc_t);
-	opvp_result_t (*opvpFillPath)(opvp_dc_t);
-	opvp_result_t (*opvpStrokeFillPath)(opvp_dc_t);
-	opvp_result_t (*opvpSetClipPath)(opvp_dc_t,opvp_cliprule_t);
-	opvp_result_t (*opvpResetClipPath)(opvp_dc_t);
-	opvp_result_t (*opvpSetCurrentPoint)(opvp_dc_t,opvp_fix_t,opvp_fix_t);
-	opvp_result_t (*opvpLinePath)(opvp_dc_t,opvp_pathmode_t,opvp_int_t,const opvp_point_t*);
-	opvp_result_t (*opvpPolygonPath)(opvp_dc_t,opvp_int_t,const opvp_int_t*,const opvp_point_t*);
-	opvp_result_t (*opvpRectanglePath)(opvp_dc_t,opvp_int_t,const opvp_rectangle_t*);
-	opvp_result_t (*opvpRoundRectanglePath)(opvp_dc_t,opvp_int_t,const opvp_roundrectangle_t*);
-	opvp_result_t (*opvpBezierPath)(opvp_dc_t,opvp_int_t,const opvp_point_t*);
-	opvp_result_t (*opvpArcPath)(opvp_dc_t,opvp_arcmode_t,opvp_arcdir_t,opvp_fix_t,opvp_fix_t,opvp_fix_t,opvp_fix_t,opvp_fix_t,opvp_fix_t,opvp_fix_t,opvp_fix_t);
-	opvp_result_t (*opvpDrawImage)(opvp_dc_t,opvp_int_t,opvp_int_t,opvp_int_t,opvp_imageformat_t,opvp_int_t, opvp_int_t ,const void*);
-	opvp_result_t (*opvpStartDrawImage)(opvp_dc_t,opvp_int_t,opvp_int_t,opvp_int_t,opvp_imageformat_t,opvp_int_t, opvp_int_t);
-	opvp_result_t (*opvpTransferDrawImage)(opvp_dc_t,opvp_int_t,const void*);
-	opvp_result_t (*opvpEndDrawImage)(opvp_dc_t);
-	opvp_result_t (*opvpStartScanline)(opvp_dc_t,opvp_int_t);
-	opvp_result_t (*opvpScanline)(opvp_dc_t,opvp_int_t,const opvp_int_t*);
-	opvp_result_t (*opvpEndScanline)(opvp_dc_t);
-	opvp_result_t (*opvpStartRaster)(opvp_dc_t,opvp_int_t);
-	opvp_result_t (*opvpTransferRasterData)(opvp_dc_t,opvp_int_t,const opvp_byte_t*);
-	opvp_result_t (*opvpSkipRaster)(opvp_dc_t,opvp_int_t);
-	opvp_result_t (*opvpEndRaster)(opvp_dc_t);
-	opvp_result_t (*opvpStartStream)(opvp_dc_t);
-	opvp_result_t (*opvpTransferStreamData)(opvp_dc_t,opvp_int_t,const void*);
-	opvp_result_t (*opvpEndStream)(opvp_dc_t);
-} opvp_api_procs_t;
-
-/* Function prototype */
-opvp_dc_t opvpOpenPrinter(
-	opvp_int_t outputFD,
-	const opvp_char_t *printerModel,
-	const opvp_int_t apiVersion[2],
-	opvp_api_procs_t **apiProcs);
-
-/* error no */
-extern opvp_int_t	opvpErrorNo;
-
-#endif /* _OPVP_H_ */
diff --git a/filter/pdftoopvp/opvp/opvp_0_2_0.h b/filter/pdftoopvp/opvp/opvp_0_2_0.h
deleted file mode 100644
index 2b2c4aa..0000000
--- a/filter/pdftoopvp/opvp/opvp_0_2_0.h
+++ /dev/null
@@ -1,298 +0,0 @@
-/*
-
-Copyright (c) 2003-2004, AXE, Inc.  All rights reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-*/
-/* opvp_common.h  ver.1.00 rel.1.0  26 Nov 2004 */
-/* OpenPrinting Vector Printer Driver Glue Code */
-
-#ifndef	_FSGPD_0_2_0_H
-#define	_FSGPD_0_2_0_H
-
-#define _PDAPI_VERSION_MAJOR_	0
-#define _PDAPI_VERSION_MINOR_	2
-
-/* Return Values */
-#define	OPVP_OK			0	/* error is -1 */
-
-/* Error Codes */
-#define	OPVP_FATALERROR		-101	/* unrecoverable error occurred within the */
-									/* library */
-#define	OPVP_BADREQUEST		-102	/* invalid function parameters */
-#define	OPVP_BADCONTEXT		-103	/* bad parameter precontext */
-#define	OPVP_NOTSUPPORTED	-104	/* printer or driver request not supported */
-#define	OPVP_JOBCANCELED	-105	/* job cancelled */
-#define	OPVP_PARAMERROR		-106	/* illegal parameter combination */
-
-/* Info params */
-#define	OPVP_INFO_PREFIX	"updf:"
-
-/* Fix */
-#define	OPVP_FIX_FRACT_WIDTH	8
-#define	OPVP_FIX_FRACT_DENOM	(1<<OPVP_FIX_FRACT_WIDTH)
-#define	OPVP_FIX_FLOOR_WIDTH	(sizeof(int)*8-OPVP_FIX_FRACT_WIDTH)
-#if 0
-typedef	struct {
-	unsigned int	fract	: OPVP_FIX_FRACT_WIDTH;
-	signed int	floor	: OPVP_FIX_FLOOR_WIDTH;
-} OPVP_Fix;
-#define	OPVP_i2Fix(i,fix)	(fix.fract=0,fix.floor=i)
-#define	OPVP_Fix2f(fix,f)	(f=(double)fix.floor\
-				  +(double)(fix.fract)/OPVP_FIX_FRACT_DENOM)
-#define	OPVP_f2Fix(f,fix)	(fix.fract=(f-floor(f))*OPVP_FIX_FRACT_DENOM,\
-				 fix.floor=floor(f))
-#else
-typedef	int	OPVP_Fix;
-#define	OPVP_i2Fix(i,fix)	(fix=(i)<<8)
-#define	OPVP_f2Fix(f,fix)	(fix=((int)floor(f)<<8)\
-				   |((int)(((f)-floor(f))*OPVP_FIX_FRACT_DENOM)\
-				      &0x000000ff))
-#endif
-
-/* Basic Types */
-typedef	struct	_OPVP_Point {
-	OPVP_Fix	x;
-	OPVP_Fix	y;
-} OPVP_Point;
-
-typedef	struct	_OPVP_Rectangle {
-	OPVP_Point	p0;		/* start point */
-	OPVP_Point	p1;		/* end point */
-} OPVP_Rectangle;
-
-typedef	struct	_OPVP_RoundRectangle {
-	OPVP_Point	p0;		/* start point */
-	OPVP_Point	p1;		/* end point */
-	OPVP_Fix	xellipse;
-	OPVP_Fix	yellipse;
-} OPVP_RoundRectangle;
-
-/* Image Formats */
-typedef	enum	_OPVP_ImageFormat {
-	OPVP_iformatRaw			= 0,
-	OPVP_iformatRLE			= 1,
-	OPVP_iformatJPEG		= 2,
-	OPVP_iformatPNG			= 3
-} OPVP_ImageFormat;
-
-/* Color Presentation */
-typedef	enum	_OPVP_ColorMapping {
-	OPVP_cmapDirect			= 0,
-	OPVP_cmapIndexed		= 1
-} OPVP_ColorMapping;
-
-typedef	enum	_OPVP_ColorSpace {
-	OPVP_cspaceBW			= 0,
-	OPVP_cspaceDeviceGray		= 1,
-	OPVP_cspaceDeviceCMY		= 2,
-	OPVP_cspaceDeviceCMYK		= 3,
-	OPVP_cspaceDeviceRGB		= 4,
-	OPVP_cspaceStandardRGB		= 5,
-	OPVP_cspaceStandardRGB64	= 6
-} OPVP_ColorSpace;
-
-/* Raster Operation modes */
-typedef	enum	_OPVP_ROP {
-	OPVP_ropPset			= 0,
-	OPVP_ropPreset			= 1,
-	OPVP_ropOr			= 2,
-	OPVP_ropAnd			= 3,
-	OPVP_ropXor			= 4
-} OPVP_ROP;
-
-/* Fill, Paint, Clip */
-typedef	enum	_OPVP_FillMode {
-	OPVP_fillModeEvenOdd		= 0,
-	OPVP_fillModeWinding		= 1
-} OPVP_FillMode;
-
-typedef	enum	_OPVP_PaintMode {
-	OPVP_paintModeOpaque		= 0,
-	OPVP_paintModeTransparent	= 1
-} OPVP_PaintMode;
-
-typedef	enum	_OPVP_ClipRule {
-	OPVP_clipRuleEvenOdd		= 0,
-	OPVP_clipRuleWinding		= 1
-} OPVP_ClipRule;
-
-/* Line */
-typedef	enum	_OPVP_LineStyle {
-	OPVP_lineStyleSolid		= 0,
-	OPVP_lineStyleDash		= 1
-} OPVP_LineStyle;
-
-typedef	enum	_OPVP_LineCap {
-	OPVP_lineCapButt		= 0,
-	OPVP_lineCapRound		= 1,
-	OPVP_lineCapSquare		= 2
-} OPVP_LineCap;
-
-typedef	enum	_OPVP_LineJoin {
-	OPVP_lineJoinMiter		= 0,
-	OPVP_lineJoinRound		= 1,
-	OPVP_lineJoinBevel		= 2
-} OPVP_LineJoin;
-
-/* Brush */
-typedef	enum	_OPVP_BrushDataType {
-	OPVP_bdtypeNormal		= 0
-} OPVP_BrushDataType;
-
-typedef	struct	_OPVP_BrushData {
-	OPVP_BrushDataType	type;
-	int		width;
-	int		height;
-	int		pitch;
-#if (_PDAPI_VERSION_MAJOR_ == 0 && _PDAPI_VERSION_MINOR_ < 2)
-	void		*data;		/* pointer to actual data */
-#else
-	char		data[1];
-#endif
-} OPVP_BrushData;
-
-typedef	struct	_OPVP_Brush {
-	OPVP_ColorSpace	colorSpace;
-	int		color[4];	/* aRGB quadruplet */
-#if (_PDAPI_VERSION_MAJOR_ == 0 && _PDAPI_VERSION_MINOR_ < 2)
-	OPVP_BrushData	*pbrush;	/* pointer to brush data */
-					/* solid brush used, if null */
-	int		xorg;		/* brush origin */
-	int		yorg;		/* ignored for SetBgColor */
-#else
-	int		xorg;		/* brush origin */
-	int		yorg;		/* ignored for SetBgColor */
-	OPVP_BrushData	*pbrush;	/* pointer to brush data */
-					/* solid brush used, if null */
-#endif
-} OPVP_Brush;
-
-/* Misc. Flags */
-#define	OPVP_Arc		0	/* circular arc */
-#define	OPVP_Chord		1	/* arch */
-#define	OPVP_Pie		2	/* pie section */
-#define	OPVP_Clockwise		0	/* clockwise */
-#define	OPVP_Counterclockwise	1	/* counter-clockwise */
-#define	OPVP_PathClose		0	/* Close path when using LinePath */
-#define	OPVP_PathOpen		1	/* Do not close path when using LinePath */
-
-/* CTM */
-typedef	struct	_OPVP_CTM {
-	float		a;
-	float		b;
-	float		c;
-	float		d;
-	float		e;
-	float		f;
-} OPVP_CTM;
-
-/* Vector Driver API Proc. Entries */
-typedef	struct	_OPVP_api_procs {
-	int	(*OpenPrinter)(int,char *,int *,struct _OPVP_api_procs **);
-	int	(*ClosePrinter)(int);
-	int	(*StartJob)(int,char *);
-	int	(*EndJob)(int);
-	int	(*StartDoc)(int,char *);
-	int	(*EndDoc)(int);
-	int	(*StartPage)(int,char *);
-	int	(*EndPage)(int);
-#if (_PDAPI_VERSION_MAJOR_ > 0 || _PDAPI_VERSION_MINOR_ >= 2)
-	int	(*QueryDeviceCapability)(int,int,int,char *);
-	int	(*QueryDeviceInfo)(int,int,int,char *);
-#endif
-	int	(*ResetCTM)(int);
-	int	(*SetCTM)(int,OPVP_CTM *);
-	int	(*GetCTM)(int,OPVP_CTM *);
-	int	(*InitGS)(int);
-	int	(*SaveGS)(int);
-	int	(*RestoreGS)(int);
-	int	(*QueryColorSpace)(int,OPVP_ColorSpace *,int *);
-	int	(*SetColorSpace)(int,OPVP_ColorSpace);
-	int	(*GetColorSpace)(int,OPVP_ColorSpace *);
-	int	(*QueryROP)(int,int *,int *);
-	int	(*SetROP)(int,int);
-	int	(*GetROP)(int,int *);
-	int	(*SetFillMode)(int,OPVP_FillMode);
-	int	(*GetFillMode)(int,OPVP_FillMode *);
-	int	(*SetAlphaConstant)(int,float);
-	int	(*GetAlphaConstant)(int,float *);
-	int	(*SetLineWidth)(int,OPVP_Fix);
-	int	(*GetLineWidth)(int,OPVP_Fix *);
-	int	(*SetLineDash)(int,OPVP_Fix *,int);
-	int	(*GetLineDash)(int,OPVP_Fix *,int *);
-	int	(*SetLineDashOffset)(int,OPVP_Fix);
-	int	(*GetLineDashOffset)(int,OPVP_Fix *);
-	int	(*SetLineStyle)(int,OPVP_LineStyle);
-	int	(*GetLineStyle)(int,OPVP_LineStyle *);
-	int	(*SetLineCap)(int,OPVP_LineCap);
-	int	(*GetLineCap)(int,OPVP_LineCap *);
-	int	(*SetLineJoin)(int,OPVP_LineJoin);
-	int	(*GetLineJoin)(int,OPVP_LineJoin *);
-	int	(*SetMiterLimit)(int,OPVP_Fix);
-	int	(*GetMiterLimit)(int,OPVP_Fix *);
-	int	(*SetPaintMode)(int,OPVP_PaintMode);
-	int	(*GetPaintMode)(int,OPVP_PaintMode *);
-	int	(*SetStrokeColor)(int,OPVP_Brush *);
-	int	(*SetFillColor)(int,OPVP_Brush *);
-	int	(*SetBgColor)(int,OPVP_Brush *);
-	int	(*NewPath)(int);
-	int	(*EndPath)(int);
-	int	(*StrokePath)(int);
-	int	(*FillPath)(int);
-	int	(*StrokeFillPath)(int);
-	int	(*SetClipPath)(int,OPVP_ClipRule);
-#if (_PDAPI_VERSION_MAJOR_ > 0 || _PDAPI_VERSION_MINOR_ >= 2)
-	int	(*ResetClipPath)(int);
-#endif
-	int	(*SetCurrentPoint)(int,OPVP_Fix,OPVP_Fix);
-	int	(*LinePath)(int,int,int,OPVP_Point *);
-	int	(*PolygonPath)(int,int,int *,OPVP_Point *);
-	int	(*RectanglePath)(int,int,OPVP_Rectangle *);
-	int	(*RoundRectanglePath)(int,int,OPVP_RoundRectangle *);
-#if (_PDAPI_VERSION_MAJOR_ == 0 && _PDAPI_VERSION_MINOR_ < 2)
-	int	(*BezierPath)(int,int *,OPVP_Point *);
-#else
-	int	(*BezierPath)(int,int,OPVP_Point *);
-#endif
-	int	(*ArcPath)(int,int,int,OPVP_Fix,OPVP_Fix,OPVP_Fix,OPVP_Fix,
-		           OPVP_Fix,OPVP_Fix,OPVP_Fix,OPVP_Fix);
-	int	(*DrawBitmapText)(int,int,int,int,void *);
-	int	(*DrawImage)(int,int,int,int,
-		             OPVP_ImageFormat,OPVP_Rectangle,int,void *);
-	int	(*StartDrawImage)(int,int,int,int,
-		                  OPVP_ImageFormat,OPVP_Rectangle);
-	int	(*TransferDrawImage)(int,int,void *);
-	int	(*EndDrawImage)(int);
-	int	(*StartScanline)(int,int);
-	int	(*Scanline)(int,int,int *);
-	int	(*EndScanline)(int);
-	int	(*StartRaster)(int,int);
-	int	(*TransferRasterData)(int,int,unsigned char *);
-	int	(*SkipRaster)(int,int);
-	int	(*EndRaster)(int);
-	int	(*StartStream)(int);
-	int	(*TransferStreamData)(int,int,void *);
-	int	(*EndStream)(int);
-} OPVP_api_procs;
-
-#endif	/* _OPVP_COMMON_H_ */
-
diff --git a/filter/pdftoopvp/opvp/opvp_common.h b/filter/pdftoopvp/opvp/opvp_common.h
deleted file mode 100644
index 5d65b32..0000000
--- a/filter/pdftoopvp/opvp/opvp_common.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
-
-Copyright (c) 2003-2004, AXE, Inc.  All rights reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-*/
-/* OpenPrinting Vector Printer Driver Glue Code */
-
-#ifndef	_OPVP_COMMON_H_
-#define	_OPVP_COMMON_H_
-
-#include "opvp_0_2_0.h"
-#undef _PDAPI_VERSION_MAJOR_
-#undef _PDAPI_VERSION_MINOR_
-/* undefine conflicted macros */
-#undef OPVP_INFO_PREFIX
-#undef OPVP_OK
-#undef OPVP_FATALERROR
-#undef OPVP_BADREQUEST
-#undef OPVP_BADCONTEXT
-#undef OPVP_NOTSUPPORTED
-#undef OPVP_JOBCANCELED
-#undef OPVP_PARAMERROR
-/* define 0_2 error no as different macros */
-#define OPVP_FATALERROR_0_2	-101
-#define OPVP_BADREQUEST_0_2	-102
-#define OPVP_BADCONTEXT_0_2	-103
-#define OPVP_NOTSUPPORTED_0_2	-104
-#define OPVP_JOBCANCELED_0_2	-105
-#define OPVP_PARAMERROR_0_2	-106
-
-#include "opvp.h"
-#define OPVP_INFO_PREFIX ""
-
-#endif	/* _OPVP_COMMON_H_ */
-
diff --git a/filter/pdftoopvp/pdftoopvp.cxx b/filter/pdftoopvp/pdftoopvp.cxx
deleted file mode 100644
index dfff692..0000000
--- a/filter/pdftoopvp/pdftoopvp.cxx
+++ /dev/null
@@ -1,798 +0,0 @@
-//========================================================================
-//
-// pdftoopvp.cc
-//
-// Copyright 2005 AXE,Inc.
-//
-// 2007,2008,2009 Modified by BBR Inc.
-//========================================================================
-
-#include <config.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <ctype.h>
-#include <math.h>
-#ifdef HAVE_CPP_POPPLER_VERSION_H
-#include "cpp/poppler-version.h"
-#endif
-#include "goo/GooString.h"
-#define GSTRING_H // for old GooString.h
-#include "goo/gmem.h"
-#include "GlobalParams.h"
-#include "Object.h"
-#include "PDFDoc.h"
-#include "splash/SplashBitmap.h"
-#include "OPRS.h"
-#include "OPVPOutputDev.h"
-#include "Gfx.h"
-#include <cups/cups.h>
-#include <cups/ppd.h>
-#include "OPVPError.h"
-
-#define MMPERINCH (25.4)
-
-static int resolution = 300;
-static int hResolution = 0;
-static int vResolution = 0;
-static bool mono = false;
-static bool reverse = false;
-static bool gray = false;
-static char enableFreeTypeStr[16] = "";
-static bool quiet = false;
-static char outputOrderStr[256] = "";
-static bool oldLipsDriver = false;
-static bool HPDriver = false;
-static bool NECDriver = false;
-static bool clipPathNotSaved = false;
-static bool noShearImage = false;
-static bool noLineStyle = false;
-static bool noImageMask = false;
-static bool noClipPath = false;
-static bool ignoreMiterLimit = false;
-static bool noMiterLimit = false;
-static char printerDriver[1024] = "";
-static char printerModel[1024] = "";
-static char jobInfo[4096] = "";
-static char docInfo[1024] = "";
-static char pageInfo[1024] = "";
-static bool noBitmapChar = false;
-static char bitmapCharThreshold[20] = "2000";
-static char maxClipPathLength[20] = "2000";
-static char maxFillPathLength[20] = "4000";
-static int pageWidth = -1;
-static int pageHeight = -1;
-
-static int outOnePage(PDFDoc *doc, OPVPOutputDev *opvpOut, int pg)
-{
-  char buf[1024];
-  char *p;
-  double pw = doc->getPageMediaWidth(pg);
-  double ph = doc->getPageMediaHeight(pg);
-  int paperWidth;
-  int paperHeight;
-
-  if (pw != pageWidth || ph != pageHeight) {
-    if (pageInfo[0] != '\0') {
-      snprintf(buf,sizeof(buf),"%s;MediaSize=%dx%dmm",pageInfo,
-       (int)(pw*MMPERINCH/72),
-       (int)(ph*MMPERINCH/72));
-    } else {
-      snprintf(buf,sizeof(buf),"MediaSize=%dx%dmm",
-       (int)(pw*MMPERINCH/72),
-       (int)(ph*MMPERINCH/72));
-    }
-    p = buf;
-  } else {
-    pw = pageWidth;
-    ph = pageHeight;
-    p = pageInfo;
-  }
-
-  paperWidth = (int)(pw*hResolution/72+0.5);
-  paperHeight = (int)(ph*vResolution/72+0.5);
-  if (opvpOut->OPVPStartPage(p,paperWidth,paperHeight) < 0) {
-      opvpError(-1,"Start Page failed");
-      return 2;
-  }
-  opvpOut->setScale(1.0,1.0,0,0,0,0,paperHeight);
-  doc->displayPage(opvpOut, pg, resolution, resolution,
-    0, true, true, false);
-  if (opvpOut->outSlice() < 0) {
-    opvpError(-1,"OutSlice failed");
-    return 2;
-  }
-  if (opvpOut->OPVPEndPage() < 0) {
-      opvpError(-1,"End Page failed");
-      return 2;
-  }
-  return 0;
-}
-
-#define MAX_OPVP_OPTIONS 20
-
-#if POPPLER_VERSION_MAJOR > 0 || POPPLER_VERSION_MINOR >= 23
-void CDECL myErrorFun(void *data, ErrorCategory category,
-#if POPPLER_VERSION_MAJOR > 0 || POPPLER_VERSION_MINOR >= 70
-    Goffset pos, const char *msg)
-#else
-    Goffset pos, char *msg)
-#endif /* MAJOR > 0 || MINOR >= 70 */
-#else
-void CDECL myErrorFun(void *data, ErrorCategory category,
-    int pos, char *msg)
-#endif
-{
-  if (pos >= 0) {
-#if POPPLER_VERSION_MAJOR > 0 || POPPLER_VERSION_MINOR >= 23
-    fprintf(stderr, "ERROR (%lld): ", pos);
-#else
-    fprintf(stderr, "ERROR (%d): ", pos);
-#endif
-  } else {
-    fprintf(stderr, "ERROR: ");
-  }
-  fprintf(stderr, "%s\n",msg);
-  fflush(stderr);
-}
-
-static bool getColorProfilePath(ppd_file_t *ppd, GooString *path)
-{
-    // get color profile path
-    const char *colorModel;
-    const char *cupsICCQualifier2;
-    const char *cupsICCQualifier2Choice;
-    const char *cupsICCQualifier3;
-    const char *cupsICCQualifier3Choice;
-    ppd_attr_t *attr;
-    ppd_choice_t *choice;
-    const char *datadir;
-
-    if ((attr = ppdFindAttr(ppd,"ColorModel",NULL)) != NULL) {
-	colorModel = attr->value;
-    } else {
-	colorModel = NULL;
-    }
-    if ((attr = ppdFindAttr(ppd,"cupsICCQualifier2",NULL)) != NULL) {
-	cupsICCQualifier2 = attr->value;
-    } else {
-	cupsICCQualifier2 = "MediaType";
-    }
-    if ((choice = ppdFindMarkedChoice(ppd,cupsICCQualifier2)) != NULL) {
-	cupsICCQualifier2Choice = choice->choice;
-    } else {
-	cupsICCQualifier2Choice = NULL;
-    }
-    if ((attr = ppdFindAttr(ppd,"cupsICCQualifier3",NULL)) != NULL) {
-	cupsICCQualifier3 = attr->value;
-    } else {
-	cupsICCQualifier3 = "Resolution";
-    }
-    if ((choice = ppdFindMarkedChoice(ppd,cupsICCQualifier3)) != NULL) {
-	cupsICCQualifier3Choice = choice->choice;
-    } else {
-	cupsICCQualifier3Choice = NULL;
-    }
-
-    for (attr = ppdFindAttr(ppd,"cupsICCProfile",NULL);attr != NULL;
-       attr = ppdFindNextAttr(ppd,"cupsICCProfile",NULL)) {
-	// check color model
-	char buf[PPD_MAX_NAME];
-	char *p, *r;
-
-	strncpy(buf,attr->spec,sizeof(buf));
-	if ((p = strchr(buf,'.')) != NULL) {
-	    *p = '\0';
-	}
-	if (colorModel != NULL && buf[0] != '\0'
-	    && strcasecmp(buf,colorModel) != 0) continue;
-	if (p == NULL) {
-	    break;
-	} else {
-	    p++;
-	    if ((r = strchr(p,'.')) != 0) {
-		*r = '\0';
-	    }
-	}
-	if (cupsICCQualifier2Choice != NULL && p[0] != '\0'
-	    && strcasecmp(p,cupsICCQualifier2Choice) != 0) continue;
-	if (r == NULL) {
-	    break;
-	} else {
-	    r++;
-	    if ((p = strchr(r,'.')) != 0) {
-		*p = '\0';
-	    }
-	}
-	if (cupsICCQualifier3Choice == NULL || r[0] == '\0'
-	    || strcasecmp(r,cupsICCQualifier3Choice) == 0) break;
-    }
-    if (attr != NULL) {
-	// matched
-	path->clear();
-	if (attr->value[0] != '/') {
-	    if ((datadir = getenv("CUPS_DATADIR")) == NULL)
-		datadir = CUPS_DATADIR;
-	    path->append(datadir);
-	    path->append("/profiles/");
-	}
-	path->append(attr->value);
-	return true;
-    }
-    return false;
-}
-
-int main(int argc, char *argv[]) {
-/* mtrace(); */
-  int exitCode;
-{
-  PDFDoc *doc;
-  SplashColor paperColor;
-  OPVPOutputDev *opvpOut;
-  bool ok = true;
-  int pg;
-  const char *optionKeys[MAX_OPVP_OPTIONS];
-  const char *optionVals[MAX_OPVP_OPTIONS];
-  int nOptions = 0;
-  int numPages;
-  int i;
-  GooString fileName;
-  GooString colorProfilePath("opvp.icc");
-
-  exitCode = 99;
-  setErrorCallback(::myErrorFun,NULL);
-
-  // parse args
-  int num_options;
-  cups_option_t *options;
-  const char *val;
-  char *ppdFileName;
-  ppd_file_t *ppd = 0;
-  ppd_attr_t *attr;
-  GooString jobInfoStr;
-  GooString docInfoStr;
-  GooString pageInfoStr;
-  bool colorProfile = false;
-
-
-  if (argc < 6 || argc > 7) {
-    opvpError(-1,"ERROR: %s job-id user title copies options [file]",
-      argv[0]);
-    return (1);
-  }
-
-  if ((ppdFileName = getenv("PPD")) != 0) {
-    if ((ppd = ppdOpenFile(ppdFileName)) != 0) {
-      /* get attributes from PPD File */
-      if ((attr = ppdFindAttr(ppd,"opvpJobInfo",0)) != 0) {
-	jobInfoStr.append(attr->value);
-      }
-      if ((attr = ppdFindAttr(ppd,"opvpDocInfo",0)) != 0) {
-	docInfoStr.append(attr->value);
-      }
-      if ((attr = ppdFindAttr(ppd,"opvpPageInfo",0)) != 0) {
-	pageInfoStr.append(attr->value);
-      }
-      if ((attr = ppdFindAttr(ppd,"pdftoopvpOldLipsDriver",0)) != 0) {
-	if (strcasecmp(attr->value,"true") == 0) {
-	  oldLipsDriver = true;
-	} else {
-	  oldLipsDriver = false;
-	}
-      }
-      if ((attr = ppdFindAttr(ppd,"pdftoopvpHPDriver",0)) != 0) {
-	if (strcasecmp(attr->value,"true") == 0) {
-	  HPDriver = true;
-	} else {
-	  HPDriver = false;
-	}
-      }
-      if ((attr = ppdFindAttr(ppd,"pdftoopvpNECDriver",0)) != 0) {
-	if (strcasecmp(attr->value,"true") == 0) {
-	  NECDriver = true;
-	} else {
-	  NECDriver = false;
-	}
-      }
-      if ((attr = ppdFindAttr(ppd,"pdftoopvpClipPathNotSaved",0)) != 0) {
-	if (strcasecmp(attr->value,"true") == 0) {
-	  clipPathNotSaved = true;
-	} else {
-	  clipPathNotSaved = false;
-	}
-      }
-      if ((attr = ppdFindAttr(ppd,"pdftoopvpShearImage",0)) != 0) {
-	if (strcasecmp(attr->value,"true") == 0) {
-	  noShearImage = false;
-	} else {
-	  noShearImage = true;
-	}
-      }
-      if ((attr = ppdFindAttr(ppd,"pdftoopvpLineStyle",0)) != 0) {
-	if (strcasecmp(attr->value,"true") == 0) {
-	  noLineStyle = false;
-	} else {
-	  noLineStyle = true;
-	}
-      }
-      if ((attr = ppdFindAttr(ppd,"pdftoopvpImageMask",0)) != 0) {
-	if (strcasecmp(attr->value,"true") == 0) {
-	  noImageMask = false;
-	} else {
-	  noImageMask = true;
-	}
-      }
-      if ((attr = ppdFindAttr(ppd,"pdftoopvpClipPath",0)) != 0) {
-	if (strcasecmp(attr->value,"true") == 0) {
-	  noClipPath = false;
-	} else {
-	  noClipPath = true;
-	}
-      }
-      if ((attr = ppdFindAttr(ppd,"pdftoopvpMiterLimit",0)) != 0) {
-	if (strcasecmp(attr->value,"true") == 0) {
-	  noMiterLimit = false;
-	} else {
-	  noMiterLimit = true;
-	}
-      }
-      if ((attr = ppdFindAttr(ppd,"pdftoopvpIgnoreMiterLimit",0)) != 0) {
-	if (strcasecmp(attr->value,"true") == 0) {
-	  ignoreMiterLimit = true;
-	} else {
-	  ignoreMiterLimit = false;
-	}
-      }
-      if ((attr = ppdFindAttr(ppd,"pdftoopvpBitmapCharThreshold",0)) != 0) {
-	strncpy(bitmapCharThreshold,attr->value,
-	  sizeof(bitmapCharThreshold)-1);
-      }
-      if ((attr = ppdFindAttr(ppd,"pdftoopvpMaxClipPathLength",0)) != 0) {
-	strncpy(maxClipPathLength,attr->value,
-	  sizeof(maxClipPathLength)-1);
-      }
-      if ((attr = ppdFindAttr(ppd,"pdftoopvpMaxFillPathLength",0)) != 0) {
-	strncpy(maxFillPathLength,attr->value,
-	  sizeof(maxFillPathLength)-1);
-      }
-      if ((attr = ppdFindAttr(ppd,"pdftoopvpBitmapChar",0)) != 0) {
-	if (strcasecmp(attr->value,"true") == 0) {
-	  noBitmapChar = false;
-	} else {
-	  noBitmapChar = true;
-	}
-      }
-      if ((attr = ppdFindAttr(ppd,"opvpDriver",0)) != 0) {
-          strncpy(printerDriver,attr->value,sizeof(printerDriver)-1);
-	  printerDriver[sizeof(printerDriver)-1] = '\0';
-      }
-      if ((attr = ppdFindAttr(ppd,"opvpModel",0)) != 0) {
-          strncpy(printerModel,attr->value,sizeof(printerModel)-1);
-	  printerModel[sizeof(printerModel)-1] = '\0';
-      }
-      ppdMarkDefaults(ppd);
-    }
-  }
-  /* get attributes and options from command line option */
-  num_options = cupsParseOptions(argv[5],0,&options);
-  cupsMarkOptions(ppd,num_options,options);
-
-  for (i = 0;i < num_options;i++) {
-    if (strcasecmp(options[i].name,"Resolution") == 0) {
-      resolution = atoi(options[i].value);
-    } else if (strcasecmp(options[i].name,"pdftoopvpOldLipsDriver") == 0) {
-      oldLipsDriver = true;
-    } else if (strcasecmp(options[i].name,"pdftoopvpHPDriver") == 0) {
-      HPDriver = true;
-    } else if (strcasecmp(options[i].name,"pdftoopvpNECDriver") == 0) {
-      NECDriver = true;
-    } else if (strcasecmp(options[i].name,"pdftoopvpClipPathNotSaved") == 0) {
-      clipPathNotSaved = true;
-    } else if (strcasecmp(options[i].name,"pdftoopvpShearImage") == 0) {
-      if (strcasecmp(options[i].value,"false") == 0) {
-	noShearImage = true;
-      }
-    } else if (strcasecmp(options[i].name,"pdftoopvpLineStyle") == 0) {
-      if (strcasecmp(options[i].value,"false") == 0) {
-	noLineStyle = true;
-      }
-    } else if (strcasecmp(options[i].name,"pdftoopvpImageMask") == 0) {
-      if (strcasecmp(options[i].value,"false") == 0) {
-	noImageMask = true;
-      }
-    } else if (strcasecmp(options[i].name,"pdftoopvpClipPath") == 0) {
-      if (strcasecmp(options[i].value,"false") == 0) {
-	noClipPath = true;
-      }
-    } else if (strcasecmp(options[i].name,"pdftoopvpMiterLimit") == 0) {
-      if (strcasecmp(options[i].value,"false") == 0) {
-	noMiterLimit = true;
-      }
-    } else if (strcasecmp(options[i].name,"pdftoopvpIgnoreMiterLimit") == 0) {
-      if (strcasecmp(options[i].value,"true") == 0) {
-	ignoreMiterLimit = true;
-      }
-    }
-     else if (strcasecmp(options[i].name,"pdftoopvpBitmapChar") == 0) {
-      if (strcasecmp(options[i].value,"false") == 0) {
-	noBitmapChar = true;
-      }
-    } else if (strcasecmp(options[i].name,"pdftoopvpBitmapCharThreshold") == 0) {
-      strncpy(bitmapCharThreshold,options[i].value,
-        sizeof(bitmapCharThreshold)-1);
-    } else if (strcasecmp(options[i].name,"pdftoopvpMaxClipPathLength") == 0) {
-      strncpy(maxClipPathLength,options[i].value,
-        sizeof(maxClipPathLength)-1);
-    } else if (strcasecmp(options[i].name,"pdftoopvpMaxFillPathLength") == 0) {
-      strncpy(maxFillPathLength,options[i].value,
-        sizeof(maxFillPathLength)-1);
-    } else if (strcasecmp(options[i].name,"opvpDriver") == 0) {
-      strncpy(printerDriver,options[i].value,sizeof(printerDriver)-1);
-      printerDriver[sizeof(printerDriver)-1] = '\0';
-    } else if (strcasecmp(options[i].name,"opvpModel") == 0) {
-      strncpy(printerModel,options[i].value,sizeof(printerModel)-1);
-      printerModel[sizeof(printerModel)-1] = '\0';
-    } else if (strcasecmp(options[i].name,"opvpJobInfo") == 0) {
-      /* do nothing here */;
-    } else if (strcasecmp(options[i].name,"opvpDocInfo") == 0) {
-      /* do nothing here */;
-    } else if (strcasecmp(options[i].name,"opvpPageInfo") == 0) {
-      /* do nothing here */;
-    }
-  }
-  if (ppd != 0) {
-    int section;
-    ppd_choice_t **choices;
-    ppd_size_t *pagesize;
-
-    if ((pagesize = ppdPageSize(ppd,0)) != 0) {
-      pageWidth = (int)pagesize->width;
-      pageHeight = (int)pagesize->length;
-    }
-    for (section = (int)PPD_ORDER_ANY;
-      section <= (int)PPD_ORDER_PROLOG;section++) {
-      int n;
-
-      n = ppdCollect(ppd,(ppd_section_t)section,&choices);
-      for (i = 0;i < n;i++) {
-
-	if (strcasecmp(((ppd_option_t *)(choices[i]->option))->keyword,
-	   "Resolution") == 0) {
-	  resolution = atoi(choices[i]->choice);
-	}
-      }
-      if (choices != 0) free(choices);
-    }
-
-#if POPPLER_VERSION_MAJOR == 0 && POPPLER_VERSION_MINOR <= 71
-    strncpy(jobInfo,jobInfoStr.getCString(),sizeof(jobInfo)-1);
-    jobInfo[sizeof(jobInfo)-1] = '\0';
-    strncpy(docInfo,docInfoStr.getCString(),sizeof(docInfo)-1);
-    docInfo[sizeof(docInfo)-1] = '\0';
-    strncpy(pageInfo,pageInfoStr.getCString(),sizeof(pageInfo)-1);
-    pageInfo[sizeof(pageInfo)-1] = '\0';
-#else
-    strncpy(jobInfo,jobInfoStr.c_str(),sizeof(jobInfo)-1);
-    jobInfo[sizeof(jobInfo)-1] = '\0';
-    strncpy(docInfo,docInfoStr.c_str(),sizeof(docInfo)-1);
-    docInfo[sizeof(docInfo)-1] = '\0';
-    strncpy(pageInfo,pageInfoStr.c_str(),sizeof(pageInfo)-1);
-    pageInfo[sizeof(pageInfo)-1] = '\0';
-#endif
-
-    colorProfile = getColorProfilePath(ppd,&colorProfilePath);
-
-    ppdClose(ppd);
-  }
-  if ((val = cupsGetOption("opvpJobInfo",num_options, options)) != 0) {
-    /* override ppd value */
-    strncpy(jobInfo,val,sizeof(jobInfo)-1);
-    jobInfo[sizeof(jobInfo)-1] = '\0';
-  }
-  if ((val = cupsGetOption("opvpDocInfo",num_options, options)) != 0) {
-    /* override ppd value */
-    strncpy(docInfo,val,sizeof(docInfo)-1);
-    docInfo[sizeof(docInfo)-1] = '\0';
-  }
-  if ((val = cupsGetOption("opvpPageInfo",num_options, options)) != 0) {
-    /* override ppd value */
-    strncpy(pageInfo,val,sizeof(pageInfo)-1);
-    pageInfo[sizeof(pageInfo)-1] = '\0';
-  }
-
-  cupsFreeOptions(num_options,options);
-#if 0
-  /* for debug parameters */
-  fprintf(stderr,"WARNING:resolution=%d\n",resolution);
-  fprintf(stderr,"WARNING:sliceHeight=%d\n",sliceHeight);
-  fprintf(stderr,"WARNING:oldLipsDriver=%d\n",oldLipsDriver);
-  fprintf(stderr,"WARNING:HPDriver=%d\n",HPDriver);
-  fprintf(stderr,"WARNING:NECDriver=%d\n",NECDriver);
-  fprintf(stderr,"WARNING:clipPathNotSaved=%d\n",clipPathNotSaved);
-  fprintf(stderr,"WARNING:noShearImage=%d\n",noShearImage);
-  fprintf(stderr,"WARNING:noLineStyle=%d\n",noLineStyle);
-  fprintf(stderr,"WARNING:noClipPath=%d\n",noClipPath);
-  fprintf(stderr,"WARNING:noMiterLimit=%d\n",noMiterLimit);
-  fprintf(stderr,"WARNING:printerDriver=%s\n",printerDriver);
-  fprintf(stderr,"WARNING:printerModel=%s\n",printerModel);
-  fprintf(stderr,"WARNING:jobInfo=%s\n",jobInfo);
-  fprintf(stderr,"WARNING:docInfo=%s\n",docInfo);
-  fprintf(stderr,"WARNING:pageInfo=%s\n",pageInfo);
-  fprintf(stderr,"WARNING:noBitmapChar=%d\n",noBitmapChar);
-  fprintf(stderr,"WARNING:bitmapCharThreshold=%s\n",bitmapCharThreshold);
-  fprintf(stderr,"WARNING:maxClipPathLength=%s\n",maxClipPathLength);
-  fprintf(stderr,"WARNING:maxFillPathLength=%s\n",maxFillPathLength);
-exit(0);
-#endif
-
-  if (oldLipsDriver) {
-    optionKeys[nOptions] = "OPVP_OLDLIPSDRIVER";
-    optionVals[nOptions] = "1";
-    nOptions++;
-    clipPathNotSaved = true;
-    noShearImage = true;
-  }
-  if (HPDriver) {
-    noClipPath = true;
-    noLineStyle = true;
-    noShearImage = true;
-  }
-  if (NECDriver) {
-    noMiterLimit = true;
-    strcpy(maxClipPathLength,"6");
-    noShearImage = true;
-  }
-  if (clipPathNotSaved) {
-    optionKeys[nOptions] = "OPVP_CLIPPATHNOTSAVED";
-    optionVals[nOptions] = "1";
-    nOptions++;
-  }
-  if (noShearImage) {
-    optionKeys[nOptions] = "OPVP_NOSHEARIMAGE";
-    optionVals[nOptions] = "1";
-    nOptions++;
-  }
-  if (noLineStyle) {
-    optionKeys[nOptions] = "OPVP_NOLINESTYLE";
-    optionVals[nOptions] = "1";
-    nOptions++;
-  }
-  if (noImageMask) {
-    optionKeys[nOptions] = "OPVP_NOIMAGEMASK";
-    optionVals[nOptions] = "1";
-    nOptions++;
-  }
-  if (noClipPath) {
-    optionKeys[nOptions] = "OPVP_NOCLIPPATH";
-    optionVals[nOptions] = "1";
-    nOptions++;
-  }
-  if (noMiterLimit) {
-    optionKeys[nOptions] = "OPVP_NOMITERLIMIT";
-    optionVals[nOptions] = "1";
-    nOptions++;
-  }
-  if (noBitmapChar) {
-    optionKeys[nOptions] = "OPVP_NOBITMAPCHAR";
-    optionVals[nOptions] = "1";
-    nOptions++;
-  }
-  if (ignoreMiterLimit) {
-    optionKeys[nOptions] = "OPVP_IGNOREMITERLIMIT";
-    optionVals[nOptions] = "1";
-    nOptions++;
-  }
-  optionKeys[nOptions] = "OPVP_BITMAPCHARTHRESHOLD";
-  optionVals[nOptions] = bitmapCharThreshold;
-  nOptions++;
-  optionKeys[nOptions] = "OPVP_MAXCLIPPATHLENGTH";
-  optionVals[nOptions] = maxClipPathLength;
-  nOptions++;
-  optionKeys[nOptions] = "OPVP_MAXFILLPATHLENGTH";
-  optionVals[nOptions] = maxFillPathLength;
-  nOptions++;
-  if (hResolution == 0) hResolution = resolution;
-  if (hResolution == 0) hResolution = resolution;
-  if (vResolution == 0) vResolution = resolution;
-  if (strcasecmp(outputOrderStr,"reverse") == 0) {
-    reverse = true;
-  }
-
-  if (argc > 6) {
-    fileName.append(argv[6]);
-  } else {
-    fileName.append("-");
-  }
-
-  // read config file
-  globalParams = new GlobalParams();
-  if (enableFreeTypeStr[0]) {
-    if (!globalParams->setEnableFreeType(enableFreeTypeStr)) {
-      opvpError(-1,"Bad '-freetype' value on command line");
-      ok = false;
-    }
-  }
-#if POPPLER_VERSION_MAJOR == 0 && POPPLER_VERSION_MINOR <= 30
-  globalParams->setAntialias("no");
-#endif
-  if (quiet) {
-    globalParams->setErrQuiet(quiet);
-  }
-  if (!ok) {
-    exitCode = 2;
-    goto err0;
-  }
-
-  if (fileName.cmp("-") == 0) {
-    /* stdin */
-    char *s;
-    GooString name;
-    int fd;
-    char buf[4096];
-    int n;
-
-    /* create a tmp file */
-    if ((s = getenv("TMPDIR")) != 0) {
-      name.append(s);
-    } else {
-      name.append("/tmp");
-    }
-    name.append("/XXXXXX");
-#if POPPLER_VERSION_MAJOR == 0 && POPPLER_VERSION_MINOR <= 71
-    fd = mkstemp(name.getCString());
-#else
-    std::string t = name.toStr();
-    fd = mkstemp(&t[0]);
-    name = GooString(std::move(t));
-#endif
-    if (fd < 0) {
-      opvpError(-1,"Can't create temporary file");
-      exitCode = 2;
-      goto err0;
-    }
-
-    /* check JCL */
-    while (fgets(buf,sizeof(buf)-1,stdin) != NULL
-        && strncmp(buf,"%PDF",4) != 0) {
-      if (strncmp(buf,"pdftoopvp jobInfo:",18) == 0) {
-	/* JCL jobInfo exists, override jobInfo */
-	strncpy(jobInfo,buf+18,sizeof(jobInfo)-1);
-	for (i = sizeof(jobInfo)-2;i >= 0
-	  && (jobInfo[i] == 0 || jobInfo[i] == '\n' || jobInfo[i] == ';')
-	  ;i--);
-	jobInfo[i+1] = 0;
-      }
-    }
-    if (strncmp(buf,"%PDF",4) != 0) {
-      opvpError(-1,"Can't find PDF header");
-      exitCode = 2;
-      goto err0;
-    }
-    /* copy PDF header */
-    n = strlen(buf);
-    if (write(fd,buf,n) != n) {
-      opvpError(-1,"Can't copy stdin to temporary file");
-      close(fd);
-      exitCode = 2;
-      goto err0;
-    }
-    /* copy rest stdin to the tmp file */
-    while ((n = fread(buf,1,sizeof(buf),stdin)) > 0) {
-      if (write(fd,buf,n) != n) {
-	opvpError(-1,"Can't copy stdin to temporary file");
-	close(fd);
-	exitCode = 2;
-	goto err0;
-      }
-    }
-    close(fd);
-    doc = new PDFDoc(&name);
-    /* remove name */
-#if POPPLER_VERSION_MAJOR == 0 && POPPLER_VERSION_MINOR <= 71
-    unlink(name.getCString());
-#else
-    unlink(name.c_str());
-#endif
-  } else {
-    /* no jcl check */
-    doc = new PDFDoc(fileName.copy());
-  }
-  if (!doc->isOk()) {
-    opvpError(-1," Parsing PDF failed: error code %d",
-      doc->getErrorCode());
-    exitCode = 2;
-    goto err05;
-  }
-
-  if (doc->isEncrypted() && !doc->okToPrint()) {
-    opvpError(-1,"Print Permission Denied");
-    exitCode = 2;
-    goto err05;
-  }
-
-  /* paperColor is white */
-  paperColor[0] = 255;
-  paperColor[1] = 255;
-  paperColor[2] = 255;
-#ifdef USE_CMS
-  /* set color profile file name */
-  GfxColorSpace::setDisplayProfileName(&colorProfilePath);
-#endif
-  opvpOut = new OPVPOutputDev();
-  if (opvpOut->init(mono ? splashModeMono1 :
-				    gray ? splashModeMono8 :
-				             splashModeRGB8,
-				  colorProfile,
-				  false, paperColor,
-                                 printerDriver,1,printerModel,
-				 nOptions,optionKeys,optionVals) < 0) {
-      opvpError(-1,"OPVPOutputDev Initialize fail");
-      exitCode = 2;
-      goto err1;
-  }
-
-  opvpOut->startDoc(doc->getXRef());
-
-#if 0
-fprintf(stderr,"JobInfo=%s\n",jobInfo);
-#endif
-  if (opvpOut->OPVPStartJob(jobInfo) < 0) {
-      opvpError(-1,"Start job failed");
-      exitCode = 2;
-      goto err1;
-  }
-  if (opvpOut->OPVPStartDoc(docInfo) < 0) {
-      opvpError(-1,"Start Document failed");
-      exitCode = 2;
-      goto err2;
-  }
-  numPages = doc->getNumPages();
-  for (pg = 1; pg <= numPages; ++pg) {
-    if ((exitCode = outOnePage(doc,opvpOut,pg)) != 0) break;
-  }
-  if (opvpOut->OPVPEndDoc() < 0) {
-      opvpError(-1,"End Document failed");
-      exitCode = 2;
-  }
-err2:
-  if (opvpOut->OPVPEndJob() < 0) {
-      opvpError(-1,"End job failed");
-      exitCode = 2;
-  }
-
-  // clean up
- err1:
-  delete opvpOut;
- err05:
-  delete doc;
- err0:
-  delete globalParams;
-
-#if POPPLER_VERSION_MAJOR == 0 && POPPLER_VERSION_MINOR < 69
-  // check for memory leaks
-  Object::memCheck(stderr);
-  gMemReport(stderr);
-#endif
-
-}
-/* muntrace(); */
-  return exitCode;
-}
-
-/* for memory debug */
-/* For compatibility with g++ >= 4.7 compilers _GLIBCXX_THROW
- *  should be used as a guard, otherwise use traditional definition */
-#ifndef _GLIBCXX_THROW
-#define _GLIBCXX_THROW throw
-#endif
-
-void * operator new(size_t size) _GLIBCXX_THROW (std::bad_alloc)
-{
-    void *p = malloc(size);
-    return p;
-}
-
-void operator delete(void *p) throw ()
-{
-    free(p);
-}
diff --git a/filter/pdftopdf/pdftopdf.cc b/filter/pdftopdf/pdftopdf.cc
index 3b9bb30..8b76240 100644
--- a/filter/pdftopdf/pdftopdf.cc
+++ b/filter/pdftopdf/pdftopdf.cc
@@ -857,7 +857,6 @@ void calculate(ppd_file_t *ppd,ProcessingParameters &param) // {{{
 // }}}
 
 // reads from stdin into temporary file. returns FILE *  or NULL on error
-// TODO? to extra file (also used in pdftoijs, e.g.)
 FILE *copy_stdin_to_temp() // {{{
 {
   char buf[BUFSIZ];
diff --git a/filter/pdftoraster.cxx b/filter/pdftoraster.cxx
index ee8b6ce..c8725c4 100644
--- a/filter/pdftoraster.cxx
+++ b/filter/pdftoraster.cxx
@@ -37,27 +37,22 @@ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include <stdio.h>
 #include <stdlib.h>
 #ifdef HAVE_CPP_POPPLER_VERSION_H
-#include "cpp/poppler-version.h"
+#include <poppler/cpp/poppler-version.h>
 #endif
-#include "goo/GooString.h"
-#include "goo/gmem.h"
-#include "Object.h"
-#include "Stream.h"
-#include "PDFDoc.h"
-#include "SplashOutputDev.h"
-#include "GfxState.h"
 #include <cups/ppd.h>
 #include <stdarg.h>
-#include "PDFError.h"
-#include "GlobalParams.h"
 #include <cups/raster.h>
 #include <cupsfilters/image.h>
 #include <cupsfilters/raster.h>
 #include <cupsfilters/colormanager.h>
-#include <splash/SplashTypes.h>
-#include <splash/SplashBitmap.h>
 #include <strings.h>
 #include <math.h>
+#include <poppler/cpp/poppler-document.h>
+#include <poppler/cpp/poppler-page.h>
+#include <poppler/cpp/poppler-global.h>
+#include <poppler/cpp/poppler-image.h>
+#include <poppler/cpp/poppler-page-renderer.h>
+#include <poppler/cpp/poppler-rectangle.h>
 #ifdef USE_LCMS1
 #include <lcms.h>
 #define cmsColorSpaceSignature icColorSpaceSignature
@@ -166,7 +161,7 @@ namespace {
     {15,143,47,175,7,135,39,167,13,141,45,173,5,133,37,165},
     {207,79,239,111,199,71,231,103,205,77,237,109,197,69,229,101},
     {63,191,31,159,55,183,23,151,61,189,29,157,53,181,21,149},
-    {255,127,223,95,247,119,215,87,253,125,221,93,245,117,213,85} 
+    {255,127,223,95,247,119,215,87,253,125,221,93,245,117,213,85}
   };
   unsigned int dither2[8][8] = {
     {0,32,8,40,2,34,10,42},
@@ -176,13 +171,13 @@ namespace {
     {3,35,11,43,1,33,9,41},
     {51,19,59,27,49,17,57,25},
     {15,47,7,39,13,45,5,37},
-    {63,31,55,23,61,29,53,21} 
+    {63,31,55,23,61,29,53,21}
   };
   unsigned int dither4[4][4] = {
     {0,8,2,10},
     {12,4,14,6},
     {3,11,1,9},
-    {15,7,13,5} 
+    {15,7,13,5}
   };
 
   /* for color profiles */
@@ -224,7 +219,7 @@ cmsCIExyYTRIPLE adobergb_matrix()
     cmsCIExyYTRIPLE m;
 
     double * matrix = cmMatrixAdobeRgb();
-    
+
     m.Red.x = matrix[0];
     m.Red.y = matrix[1];
     m.Red.Y = matrix[2];
@@ -251,7 +246,7 @@ cmsHPROFILE adobergb_profile()
 #else
     cmsToneCurve * Gamma = cmsBuildGamma(NULL, 2.2);
     cmsToneCurve * Gamma3[3];
-#endif    
+#endif
     Gamma3[0] = Gamma3[1] = Gamma3[2] = Gamma;
 
     // Build AdobeRGB profile
@@ -272,7 +267,7 @@ cmsHPROFILE sgray_profile()
     cmsToneCurve Gamma = cmsBuildGamma(256, 2.2);
 #else
     cmsToneCurve * Gamma = cmsBuildGamma(NULL, 2.2);
-#endif 
+#endif
     // Build sGray profile
     wp = sgray_wp();
     sgray = cmsCreateGrayProfile(&wp, Gamma);
@@ -280,30 +275,6 @@ cmsHPROFILE sgray_profile()
     return sgray;
 }
 
-#if POPPLER_VERSION_MAJOR > 0 || POPPLER_VERSION_MINOR >= 23
-void CDECL myErrorFun(void *data, ErrorCategory category,
-#if POPPLER_VERSION_MAJOR > 0 || POPPLER_VERSION_MINOR >= 70
-    Goffset pos, const char *msg)
-#else
-    Goffset pos, char *msg)
-#endif /* MAJOR > 0 || MINOR >= 70 */
-#else
-void CDECL myErrorFun(void *data, ErrorCategory category,
-    int pos, char *msg)
-#endif
-{
-  if (pos >= 0) {
-#if POPPLER_VERSION_MAJOR > 0 || POPPLER_VERSION_MINOR >= 23
-    fprintf(stderr, "ERROR (%lld): ", pos);
-#else
-    fprintf(stderr, "ERROR (%d): ", pos);
-#endif
-  } else {
-    fprintf(stderr, "ERROR: ");
-  }
-  fprintf(stderr, "%s\n",msg);
-  fflush(stderr);
-}
 
 #ifdef USE_LCMS1
 static int lcmsErrorHandler(int ErrorCode, const char *ErrorText)
@@ -320,93 +291,6 @@ static void lcmsErrorHandler(cmsContext contextId, cmsUInt32Number ErrorCode,
 #endif
 
 
-#if 0
-static bool getColorProfilePath(ppd_file_t *ppd, GooString *path)
-{
-    // get color profile path
-    const char *colorModel;
-    const char *cupsICCQualifier2;
-    const char *cupsICCQualifier2Choice;
-    const char *cupsICCQualifier3;
-    const char *cupsICCQualifier3Choice;
-    ppd_attr_t *attr;
-    ppd_choice_t *choice;
-
-    if ((choice = ppdFindMarkedChoice(ppd,"ColorModel")) != NULL) {
-	colorModel = choice->choice;
-    } else {
-	colorModel = NULL;
-    }
-    if ((attr = ppdFindAttr(ppd,"cupsICCQualifier2",NULL)) != NULL) {
-	cupsICCQualifier2 = attr->value;
-    } else {
-	cupsICCQualifier2 = "MediaType";
-    }
-    if ((choice = ppdFindMarkedChoice(ppd,cupsICCQualifier2)) != NULL) {
-	cupsICCQualifier2Choice = choice->choice;
-    } else {
-	cupsICCQualifier2Choice = NULL;
-    }
-    if ((attr = ppdFindAttr(ppd,"cupsICCQualifier3",NULL)) != NULL) {
-	cupsICCQualifier3 = attr->value;
-    } else {
-	cupsICCQualifier3 = "Resolution";
-    }
-    if ((choice = ppdFindMarkedChoice(ppd,cupsICCQualifier3)) != NULL) {
-	cupsICCQualifier3Choice = choice->choice;
-    } else {
-	cupsICCQualifier3Choice = NULL;
-    }
-
-    for (attr = ppdFindAttr(ppd,"cupsICCProfile",NULL);attr != NULL;
-       attr = ppdFindNextAttr(ppd,"cupsICCProfile",NULL)) {
-	// check color model
-	char buf[PPD_MAX_NAME];
-	char *p, *r;
-	char *datadir;
-
-	strncpy(buf,attr->spec,sizeof(buf));
-	if ((p = strchr(buf,'.')) != NULL) {
-	    *p = '\0';
-	}
-	if (colorModel != NULL && buf[0] != '\0'
-	    && strcasecmp(buf,colorModel) != 0) continue;
-	if (p == NULL) {
-	    break;
-	} else {
-	    p++;
-	    if ((r = strchr(p,'.')) != 0) {
-		*r = '\0';
-	    }
-	}
-	if (cupsICCQualifier2Choice != NULL && p[0] != '\0'
-	    && strcasecmp(p,cupsICCQualifier2Choice) != 0) continue;
-	if (r == NULL) {
-	    break;
-	} else {
-	    r++;
-	    if ((p = strchr(r,'.')) != 0) {
-		*p = '\0';
-	    }
-	}
-	if (cupsICCQualifier3Choice == NULL || r[0] == '\0'
-	    || strcasecmp(r,cupsICCQualifier3Choice) == 0) break;
-    }
-    if (attr != NULL) {
-	// matched
-	path->clear();
-	if (attr->value[0] != '/') {
-	    if ((datadir = getenv("CUPS_DATADIR")) == NULL)
-		datadir = CUPS_DATADIR;
-	    path->append(datadir);
-	    path->append("/profiles/");
-	}
-	path->append(attr->value);
-	return true;
-    }
-    return false;
-}
-#endif
 
 static void  handleRqeuiresPageRegion() {
   ppd_choice_t *mf;
@@ -448,14 +332,13 @@ static void parseOpts(int argc, char **argv)
 {
   int num_options = 0;
   cups_option_t *options = 0;
-  GooString profilePath;
   char *profile = 0;
   const char *t = NULL;
   ppd_attr_t *attr;
 
   if (argc < 6 || argc > 7) {
-    pdfError(-1,const_cast<char *>("%s job-id user title copies options [file]"),
-      argv[0]);
+    fprintf(stderr, "ERROR: Usage: %s job-id user title copies options [file]\n",
+	    argv[0]);
     exit(1);
   }
 
@@ -464,7 +347,7 @@ static void parseOpts(int argc, char **argv)
   if (t && strcasestr(t, "pwg"))
     pwgraster = 1;
 #endif /* HAVE_CUPS_1_7 */
-    
+
   ppd = ppdOpenFile(getenv("PPD"));
   if (ppd == NULL)
     fprintf(stderr, "DEBUG: PPD file is not specified.\n");
@@ -542,10 +425,10 @@ static void parseOpts(int argc, char **argv)
 
     if (cm_calibrate == CM_CALIBRATION_ENABLED)
       cm_disabled = 1;
-    else 
+    else
       cm_disabled = cmIsPrinterCmDisabled(getenv("PRINTER"));
-       
-    if (!cm_disabled) 
+
+    if (!cm_disabled)
       cmGetPrinterIccProfile(getenv("PRINTER"), &profile, ppd);
 
     if (profile != NULL) {
@@ -573,7 +456,7 @@ static void parseOpts(int argc, char **argv)
       if (strcasestr(t, "pwg"))
 	pwgraster = 1;
       else
-	pwgraster = 0; 
+	pwgraster = 0;
     }
     cupsRasterParseIPPOptions(&header,num_options,options,pwgraster,1);
 #else
@@ -1399,7 +1282,7 @@ static unsigned int getCMSColorSpaceType(cmsColorSpaceSignature cs)
 /* select convertLine function */
 static void selectConvertFunc(cups_raster_t *raster)
 {
-  if ((colorProfile == NULL || popplerColorProfile == colorProfile) 
+  if ((colorProfile == NULL || popplerColorProfile == colorProfile)
       && (header.cupsColorOrder == CUPS_ORDER_CHUNKED
        || header.cupsNumColors == 1)) {
     if (selectSpecialCase()) return;
@@ -1477,7 +1360,7 @@ static void selectConvertFunc(cups_raster_t *raster)
             COLORSPACE_SH(dcst) |
             CHANNELS_SH(header.cupsNumColors) | BYTES_SH(bytes),
             renderingIntent,0)) == 0) {
-      pdfError(-1,const_cast<char *>("Can't create color transform"));
+      fprintf(stderr, "ERROR: Can't create color transform");
       exit(1);
     }
   } else {
@@ -1548,7 +1431,7 @@ static void selectConvertFunc(cups_raster_t *raster)
       convertCSpace = W8toK8;
       break;
     default:
-      pdfError(-1,const_cast<char *>("Specified ColorSpace is not supported"));
+      fprintf(stderr, "ERROR: Specified ColorSpace is not supported\n" );
       exit(1);
       break;
     }
@@ -1623,13 +1506,105 @@ static void selectConvertFunc(cups_raster_t *raster)
   }
 }
 
-static void writePageImage(cups_raster_t *raster, SplashBitmap *bitmap,
+static unsigned char *onebitpixel(unsigned char *src, unsigned char *dst, unsigned int width, unsigned int height){
+  unsigned char *temp;
+  temp=dst;
+  int cnt=0;
+  for(unsigned int i=0;i<height;i++){
+    for(unsigned int j=0;j<width;j+=8){
+      unsigned char tem=0;
+      for(int k=0;k<8;k++){
+        cnt++;
+          tem <<=1;
+          unsigned int var=*src;
+          if(var > dither1[i & 0xf][(j+k) & 0xf]){
+            tem |= 0x1;
+          }
+          src +=1;
+      }
+      *dst=tem;
+      dst+=1;
+    }
+  }
+  return temp;
+}
+
+
+static unsigned char *removeAlpha(unsigned char *src, unsigned char *dst, unsigned int width, unsigned int height){
+  unsigned char *temp;
+  temp=dst;
+  for(unsigned int i=0;i<height;i++){
+    for(unsigned int j=0;j<width;j++){
+      dst[0]=src[2];
+      dst[1]=src[1];
+      dst[2]=src[0];
+      src+=4;
+      dst+=3;
+    }
+  }
+  return temp;
+}
+
+static void writePageImage(cups_raster_t *raster, poppler::document *doc,
   int pageNo)
 {
   ConvertLineFunc convertLine;
   unsigned char *lineBuf = NULL;
   unsigned char *dp;
-  unsigned int rowsize = bitmap->getRowSize();
+  unsigned int rowsize;
+
+  poppler::page *current_page =doc->create_page(pageNo-1);
+  poppler::page_renderer pr;
+  pr.set_render_hint(poppler::page_renderer::antialiasing, true);
+  pr.set_render_hint(poppler::page_renderer::text_antialiasing, true);
+
+  unsigned char *colordata,*newdata,*graydata,*onebitdata;
+  unsigned int pixel_count;
+  poppler::image im;
+  //render the page according to the colourspace and generate the requried data
+  switch (header.cupsColorSpace) {
+   case CUPS_CSPACE_W://gray
+   case CUPS_CSPACE_K://black
+   case CUPS_CSPACE_SW://sgray
+    if(header.cupsBitsPerColor==1){ //special case for 1-bit colorspaces
+      im = pr.render_page(current_page,header.HWResolution[0],header.HWResolution[1],bitmapoffset[0],bitmapoffset[1],bytesPerLine*8,header.cupsHeight);
+    newdata = (unsigned char *)malloc(sizeof(char)*3*im.width()*im.height());
+    newdata = removeAlpha((unsigned char *)im.const_data(),newdata,im.width(),im.height());
+    graydata=(unsigned char *)malloc(sizeof(char)*im.width()*im.height());
+    cupsImageRGBToWhite(newdata,graydata,im.width()*im.height());
+    onebitdata=(unsigned char *)malloc(sizeof(char)*bytesPerLine*im.height());
+    onebitpixel(graydata,onebitdata,im.width(),im.height());
+    colordata=onebitdata;
+    rowsize=bytesPerLine;
+    }
+    else{
+      im = pr.render_page(current_page,header.HWResolution[0],header.HWResolution[1],bitmapoffset[0],bitmapoffset[1],header.cupsWidth,header.cupsHeight);
+      newdata = (unsigned char *)malloc(sizeof(char)*3*im.width()*im.height());
+      newdata = removeAlpha((unsigned char *)im.const_data(),newdata,im.width(),im.height());
+      pixel_count=im.width()*im.height();
+      graydata=(unsigned char *)malloc(sizeof(char)*im.width()*im.height());
+      cupsImageRGBToWhite(newdata,graydata,pixel_count);
+      colordata=graydata;
+      rowsize=header.cupsWidth;
+    }
+
+    break;
+   case CUPS_CSPACE_RGB:
+   case CUPS_CSPACE_ADOBERGB:
+   case CUPS_CSPACE_CMYK:
+   case CUPS_CSPACE_SRGB:
+   case CUPS_CSPACE_CMY:
+   case CUPS_CSPACE_RGBW:
+   default:
+   im = pr.render_page(current_page,header.HWResolution[0],header.HWResolution[1],bitmapoffset[0],bitmapoffset[1],header.cupsWidth,header.cupsHeight);
+   newdata = (unsigned char *)malloc(sizeof(char)*3*im.width()*im.height());
+   newdata = removeAlpha((unsigned char *)im.const_data(),newdata,im.width(),im.height());
+   pixel_count=im.width()*im.height();
+   rowsize=header.cupsWidth*3;
+   colordata=newdata;
+     break;
+  }
+
 
   if (allocLineBuf) lineBuf = new unsigned char [bytesPerLine];
   if ((pageNo & 1) == 0) {
@@ -1639,13 +1614,11 @@ static void writePageImage(cups_raster_t *raster, SplashBitmap *bitmap,
   }
   if (header.Duplex && (pageNo & 1) == 0 && swap_image_y) {
     for (unsigned int plane = 0;plane < nplanes;plane++) {
-      unsigned char *bp = (unsigned char *)(bitmap->getDataPtr());
+      unsigned char *bp = colordata + (header.cupsHeight - 1) * rowsize;
 
-      bp += rowsize * (bitmapoffset[1] + header.cupsHeight - 1) +
-        popplerBitsPerPixel * bitmapoffset[0] / 8;
       for (unsigned int h = header.cupsHeight;h > 0;h--) {
         for (unsigned int band = 0;band < nbands;band++) {
-          dp = convertLine(bp,lineBuf,h,plane+band,header.cupsWidth,
+          dp = convertLine(bp,lineBuf,h - 1,plane+band,header.cupsWidth,
                  bytesPerLine);
           cupsRasterWritePixels(raster,dp,bytesPerLine);
         }
@@ -1654,10 +1627,8 @@ static void writePageImage(cups_raster_t *raster, SplashBitmap *bitmap,
     }
   } else {
     for (unsigned int plane = 0;plane < nplanes;plane++) {
-      unsigned char *bp = (unsigned char *)(bitmap->getDataPtr());
+      unsigned char *bp = colordata;
 
-      bp += rowsize * bitmapoffset[1] + 
-        popplerBitsPerPixel * bitmapoffset[0] / 8;
       for (unsigned int h = 0;h < header.cupsHeight;h++) {
         for (unsigned int band = 0;band < nbands;band++) {
           dp = convertLine(bp,lineBuf,h,plane+band,header.cupsWidth,
@@ -1671,29 +1642,39 @@ static void writePageImage(cups_raster_t *raster, SplashBitmap *bitmap,
   if (allocLineBuf) delete[] lineBuf;
 }
 
-static void outPage(PDFDoc *doc, Catalog *catalog, int pageNo,
-  SplashOutputDev *out, cups_raster_t *raster)
+static void outPage(poppler::document *doc, int pageNo,
+  cups_raster_t *raster)
 {
-  SplashBitmap *bitmap;
-  Page *page = catalog->getPage(pageNo);
-  PDFRectangle mediaBox = *page->getMediaBox();
-  int rotate = page->getRotate();
+  int rotate = 0;
   double paperdimensions[2], /* Physical size of the paper */
     margins[4];	/* Physical margins of print */
   ppd_size_t *size;		/* Page size */
   double l, swap;
+  int imageable_area_fit = 0;
   int i;
-  bool landscape = 0;
 
+  poppler::page *current_page =doc->create_page(pageNo-1);
+  poppler::page_box_enum box = poppler::page_box_enum::media_box;
+  poppler::rectf mediaBox = current_page->page_rect(box);
+  poppler::page::orientation_enum orient = current_page->orientation();
+  switch (orient) {
+    case poppler::page::landscape: rotate=90;
+     break;
+    case poppler::page::upside_down: rotate=180;
+     break;
+    case poppler::page::seascape: rotate=270;
+     break;
+     default:rotate=0;
+  }
   fprintf(stderr, "DEBUG: mediaBox = [ %f %f %f %f ]; rotate = %d\n",
-	  mediaBox.x1, mediaBox.y1, mediaBox.x2, mediaBox.y2, rotate);
-  l = mediaBox.x2 - mediaBox.x1;
+	  mediaBox.left(), mediaBox.top(), mediaBox.right(), mediaBox.bottom(), rotate);
+  l = mediaBox.width();
   if (l < 0) l = -l;
   if (rotate == 90 || rotate == 270)
     header.PageSize[1] = (unsigned)l;
   else
     header.PageSize[0] = (unsigned)l;
-  l = mediaBox.y2 - mediaBox.y1;
+  l = mediaBox.height();
   if (l < 0) l = -l;
   if (rotate == 90 || rotate == 270)
     header.PageSize[0] = (unsigned)l;
@@ -1703,22 +1684,37 @@ static void outPage(PDFDoc *doc, Catalog *catalog, int pageNo,
   memset(paperdimensions, 0, sizeof(paperdimensions));
   memset(margins, 0, sizeof(margins));
   if (ppd) {
+    imageable_area_fit = 0;
     for (i = ppd->num_sizes, size = ppd->sizes;
 	 i > 0;
 	 i --, size ++) {
       /* Skip page sizes which conflict with settings of the other options */
       /* TODO XXX */
       /* Find size of document's page under the PPD page sizes */
-      if (fabs(header.PageSize[1] - size->length) < 5.0 &&
-	  fabs(header.PageSize[0] - size->width) < 5.0)
+      if (fabs(header.PageSize[1] - size->length) / size->length < 0.01 &&
+	  fabs(header.PageSize[0] - size->width) / size->width < 0.01)
 	break;
     }
+    if (i == 0) {
+      /* Input page size does not fit any of the PPD's sizes, try to fit
+	 the input page size into the imageable areas of the PPD's sizes */
+      for (i = ppd->num_sizes, size = ppd->sizes;
+	   i > 0;
+	   i --, size ++)
+	if (fabs(header.PageSize[1] - size->top + size->bottom) /
+	    size->length < 0.01 &&
+	    fabs(header.PageSize[0] - size->right + size->left) /
+	    size->width < 0.01) {
+	  fprintf(stderr, "DEBUG: Imageable area fit\n");
+	  imageable_area_fit = 1;
+	  break;
+	}
+    }
     if (i > 0) {
       /*
        * Standard size...
        */
       fprintf(stderr, "DEBUG: size = %s\n", size->name);
-      landscape = 0;
       paperdimensions[0] = size->width;
       paperdimensions[1] = size->length;
       if (pwgraster == 0) {
@@ -1734,19 +1730,33 @@ static void outPage(PDFDoc *doc, Catalog *catalog, int pageNo,
        * landscape orientation...
        */
 
+      imageable_area_fit = 0;
       for (i = ppd->num_sizes, size = ppd->sizes;
 	   i > 0;
 	   i --, size ++)
-	if (fabs(header.PageSize[0] - size->length) < 5.0 &&
-	    fabs(header.PageSize[1] - size->width) < 5.0)
+	if (fabs(header.PageSize[0] - size->length) / size->length < 0.01 &&
+	    fabs(header.PageSize[1] - size->width) / size->width < 0.01)
 	  break;
-
+      if (i == 0) {
+	/* Input page size does not fit any of the PPD's sizes, try to fit
+	   the input page size into the imageable areas of the PPD's sizes */
+	for (i = ppd->num_sizes, size = ppd->sizes;
+	     i > 0;
+	     i --, size ++)
+	  if (fabs(header.PageSize[0] - size->top + size->bottom) /
+	      size->length < 0.01 &&
+	      fabs(header.PageSize[1] - size->right + size->left) /
+	      size->width < 0.01) {
+	    fprintf(stderr, "DEBUG: Imageable area fit\n");
+	    imageable_area_fit = 1;
+	    break;
+	  }
+      }
       if (i > 0) {
 	/*
 	 * Standard size in landscape orientation...
 	 */
 	fprintf(stderr, "DEBUG: landscape size = %s\n", size->name);
-	landscape = 1;
 	paperdimensions[0] = size->width;
 	paperdimensions[1] = size->length;
 	if (pwgraster == 0) {
@@ -1761,14 +1771,15 @@ static void outPage(PDFDoc *doc, Catalog *catalog, int pageNo,
 	 * Custom size...
 	 */
 	fprintf(stderr, "DEBUG: size = Custom\n");
-	landscape = 0;
 	paperdimensions[1] = size->length;
 	for (i = 0; i < 2; i ++)
 	  paperdimensions[i] = header.PageSize[i];
 	if (pwgraster == 0)
 	  for (i = 0; i < 4; i ++)
 	    margins[i] = ppd->custom_margins[i];
-	header.cupsPageSizeName[0] = '\0';
+	snprintf(header.cupsPageSizeName, 64,
+		 "Custom.%dx%d",
+		 header.PageSize[0], header.PageSize[1]);
       }
     }
   } else {
@@ -1802,12 +1813,14 @@ static void outPage(PDFDoc *doc, Catalog *catalog, int pageNo,
     }
   }
 
-  doc->displayPage(out,pageNo,header.HWResolution[0],
-		   header.HWResolution[1],(landscape == 0 ? 0 : 90),
-		   true,true,true);
-  bitmap = out->getBitmap();
-  bitmapoffset[0] = margins[0] / 72.0 * header.HWResolution[0];
-  bitmapoffset[1] = margins[3] / 72.0 * header.HWResolution[1];
+
+  if (imageable_area_fit == 0) {
+    bitmapoffset[0] = margins[0] / 72.0 * header.HWResolution[0];
+    bitmapoffset[1] = margins[3] / 72.0 * header.HWResolution[1];
+  } else {
+    bitmapoffset[0] = 0;
+    bitmapoffset[1] = 0;
+  }
 
   /* write page header */
   if (pwgraster == 0) {
@@ -1849,12 +1862,12 @@ static void outPage(PDFDoc *doc, Catalog *catalog, int pageNo,
     header.cupsBytesPerLine *= header.cupsNumColors;
   }
   if (!cupsRasterWriteHeader2(raster,&header)) {
-      pdfError(-1,const_cast<char *>("Can't write page %d header"),pageNo);
+      fprintf(stderr, "ERROR: Can't write page %d header\n",pageNo );
       exit(1);
   }
 
   /* write page image */
-  writePageImage(raster,bitmap,pageNo);
+  writePageImage(raster,doc,pageNo);
 }
 
 static void setPopplerColorProfile()
@@ -1936,29 +1949,19 @@ static void setPopplerColorProfile()
     popplerColorProfile = NULL;
     break;
   default:
-    pdfError(-1,const_cast<char *>("Specified ColorSpace is not supported"));
+    fprintf(stderr, "ERROR: Specified ColorSpace is not supported\n" );
     exit(1);
     break;
   }
-  if (popplerColorProfile != NULL) {
-    GfxColorSpace::setDisplayProfile(popplerColorProfile);
-  }
 }
 
 int main(int argc, char *argv[]) {
-  PDFDoc *doc;
-  SplashOutputDev *out;
-  SplashColor paperColor;
+  poppler::document *doc;
   int i;
-  int npages;
+  int npages=0;
   cups_raster_t *raster;
-  enum SplashColorMode cmode;
-  int rowpad;
-  Catalog *catalog;
 
-  setErrorCallback(::myErrorFun,NULL);
   cmsSetLogErrorHandler(lcmsErrorHandler);
-  globalParams = new GlobalParams();
   parseOpts(argc, argv);
 
   if (argc == 6) {
@@ -1970,43 +1973,37 @@ int main(int argc, char *argv[]) {
 
     fd = cupsTempFd(name,sizeof(name));
     if (fd < 0) {
-      pdfError(-1,const_cast<char *>("Can't create temporary file"));
+      fprintf(stderr, "ERROR: Can't create temporary file\n");
       exit(1);
     }
 
     /* copy stdin to the tmp file */
     while ((n = read(0,buf,BUFSIZ)) > 0) {
       if (write(fd,buf,n) != n) {
-        pdfError(-1,const_cast<char *>("Can't copy stdin to temporary file"));
+        fprintf(stderr, "ERROR: Can't copy stdin to temporary file\n" );
         close(fd);
 	exit(1);
       }
     }
     close(fd);
-    doc = new PDFDoc(new GooString(name));
+    doc=poppler::document::load_from_file(name,"","");
     /* remove name */
     unlink(name);
   } else {
-    GooString *fileName = new GooString(argv[6]);
     /* argc == 7 filenmae is specified */
     FILE *fp;
 
     if ((fp = fopen(argv[6],"rb")) == 0) {
-        pdfError(-1,const_cast<char *>("Can't open input file %s"),argv[6]);
+        fprintf(stderr, "ERROR: Can't open input file %s\n",argv[6]);
 	exit(1);
     }
     parsePDFTOPDFComment(fp);
     fclose(fp);
-    doc = new PDFDoc(fileName,NULL,NULL);
+    doc=poppler::document::load_from_file(argv[6],"","");
   }
 
-  if (!doc->isOk()) {
-    exitCode = 1;
-    goto err1;
-  }
-
-  catalog = doc->getCatalog();
-  npages = doc->getNumPages();
+  if(doc != NULL)
+    npages = doc->pages();
 
   /* fix NumCopies, Collate ccording to PDFTOPDFComments */
   header.NumCopies = deviceCopies;
@@ -2020,7 +2017,7 @@ int main(int argc, char *argv[]) {
      && header.cupsBitsPerColor != 4
      && header.cupsBitsPerColor != 8
      && header.cupsBitsPerColor != 16) {
-    pdfError(-1,const_cast<char *>("Specified color format is not supported"));
+    fprintf(stderr, "ERROR: Specified color format is not supported\n");
     exit(1);
   }
   if (header.cupsColorOrder == CUPS_ORDER_PLANAR) {
@@ -2055,7 +2052,7 @@ int main(int argc, char *argv[]) {
     if (header.cupsColorOrder != CUPS_ORDER_CHUNKED
        || (header.cupsBitsPerColor != 8
           && header.cupsBitsPerColor != 16)) {
-      pdfError(-1,const_cast<char *>("Specified color format is not supported"));
+      fprintf(stderr, "ERROR: Specified color format is not supported\n");
       exit(1);
     }
   case CUPS_CSPACE_RGB:
@@ -2071,12 +2068,6 @@ int main(int argc, char *argv[]) {
   case CUPS_CSPACE_RGBW:
   case CUPS_CSPACE_GMCK:
   case CUPS_CSPACE_GMCS:
-    cmode = splashModeRGB8;
-    rowpad = 4;
-    /* set paper color white */
-    paperColor[0] = 255;
-    paperColor[1] = 255;
-    paperColor[2] = 255;
     popplerBitsPerPixel = 24;
     popplerNumColors = 3;
     break;
@@ -2086,21 +2077,17 @@ int main(int argc, char *argv[]) {
   case CUPS_CSPACE_WHITE:
   case CUPS_CSPACE_GOLD:
   case CUPS_CSPACE_SILVER:
-    if (header.cupsBitsPerColor == 1 
+    if (header.cupsBitsPerColor == 1
        && header.cupsBitsPerPixel == 1) {
-      cmode = splashModeMono1;
       popplerBitsPerPixel = 1;
     } else {
-      cmode = splashModeMono8;
       popplerBitsPerPixel = 8;
     }
     /* set paper color white */
-    paperColor[0] = 255;
-    rowpad = 1;
     popplerNumColors = 1;
     break;
   default:
-    pdfError(-1,const_cast<char *>("Specified ColorSpace is not supported"));
+    fprintf(stderr, "ERROR: Specified ColorSpace is not supported\n");
     exit(1);
     break;
   }
@@ -2109,27 +2096,21 @@ int main(int argc, char *argv[]) {
     setPopplerColorProfile();
   }
 
-  out = new SplashOutputDev(cmode,rowpad/* row padding */,
-    false,paperColor,true
-#if POPPLER_VERSION_MAJOR == 0 && POPPLER_VERSION_MINOR <= 30
-    ,false
-#endif
-    );
-  out->startDoc(doc);
-
   if ((raster = cupsRasterOpen(1, pwgraster ? CUPS_RASTER_WRITE_PWG :
 			       CUPS_RASTER_WRITE)) == 0) {
-        pdfError(-1,const_cast<char *>("Can't open raster stream"));
+        fprintf(stderr, "ERROR: Can't open raster stream\n");
 	exit(1);
   }
   selectConvertFunc(raster);
-  for (i = 1;i <= npages;i++) {
-    outPage(doc,catalog,i,out,raster);
-  }
+  if(doc != NULL){
+    for (i = 1;i <= npages;i++) {
+      outPage(doc,i,raster);
+    }
+  } else
+    fprintf(stderr, "DEBUG: Input is empty, outputting empty file.\n");
+
   cupsRasterClose(raster);
 
-  delete out;
-err1:
   delete doc;
   if (ppd != NULL) {
     ppdClose(ppd);
@@ -2144,12 +2125,6 @@ err1:
     cmsDeleteTransform(colorTransform);
   }
 
-#if POPPLER_VERSION_MAJOR == 0 && POPPLER_VERSION_MINOR < 69
-  // Check for memory leaks
-  Object::memCheck(stderr);
-  gMemReport(stderr);
-#endif
-
   return exitCode;
 }
 
@@ -2162,20 +2137,20 @@ err1:
 
 void * operator new(size_t size) _GLIBCXX_THROW (std::bad_alloc)
 {
-  return gmalloc(size);
+  return malloc(size);
 }
 
 void operator delete(void *p) throw ()
 {
-  gfree(p);
+  free(p);
 }
 
 void * operator new[](size_t size) _GLIBCXX_THROW (std::bad_alloc)
 {
-  return gmalloc(size);
+  return malloc(size);
 }
 
 void operator delete[](void *p) throw ()
 {
-  gfree(p);
+  free(p);
 }
diff --git a/ppd/HP-PhotoSmart_Pro_B8300-hpijs-pdftoijs.ppd b/ppd/HP-PhotoSmart_Pro_B8300-hpijs-pdftoijs.ppd
deleted file mode 100644
index 798181b..0000000
--- a/ppd/HP-PhotoSmart_Pro_B8300-hpijs-pdftoijs.ppd
+++ /dev/null
@@ -1,342 +0,0 @@
-*PPD-Adobe: "4.3"
-*%
-*FormatVersion:	"4.3"
-*FileVersion:	"1.1"
-*LanguageVersion: English 
-*LanguageEncoding: ISOLatin1
-*PCFileName:	"HPIJS.PPD"
-*Manufacturer:	"HP"
-*Product:	"(PhotoSmart Pro B8300)"
-*cupsVersion:	1.0
-*cupsManualCopies: True
-*cupsModelNumber:  2
-*cupsFilter:	"application/vnd.cups-pdf 0 pdftoijs"
-*ModelName:     "HP PhotoSmart Pro B8300"
-*ShortNickName: "HP PhotoSmart Pro B8300 hpijs"
-*NickName:      "HP PhotoSmart Pro B8300 CUPS/pdftoijs/hpijs"
-*PSVersion:	"(3010.000) 800"
-*LanguageLevel:	"3"
-*ColorDevice:	True
-*DefaultColorSpace: RGB
-*FileSystem:	False
-*Throughput:	"1"
-*LandscapeOrientation: Plus90
-*TTRasterizer:	Type42
-*1284DeviceID: "DRV:Dhpijs,R1,M1,F1,Sv,TI,X1200,Y1200,C1,t90,l90,g100,p100,s70;"
-
-*driverName hpijs/hpijs - HP's IJS driver for most of their non-PostScript printers: ""
-*driverType I/IJS: ""
-*driverUrl: "http://hplipopensource.com/"
-*driverObsolete: False
-*driverSupplier: "Hewlett-Packard"
-*driverManufacturerSupplied: True
-*driverLicense: "BSD"
-*driverFreeSoftware: True
-*driverSupportContactVoluntary: "https://launchpad.net/hplip HPLIP support and bug tracking system"
-*driverMaxResolution: 1200 1200
-*driverColor: True
-*driverTextSupport: 90
-*driverLineartSupport: 90
-*driverGraphicsSupport: 100
-*driverPhotoSupport: 100
-*driverRenderingSpeed: 70
-
-*DefaultResolution: 1200dpi
-
-
-
-*HWMargins: 18 36 18 9
-*VariablePaperSize: True
-*MaxMediaWidth: 100000
-*MaxMediaHeight: 100000
-*NonUIOrderDependency: 105 AnySetup *CustomPageSize
-*CustomPageSize True: ""
-*ParamCustomPageSize Width: 1 points 36 100000
-*ParamCustomPageSize Height: 2 points 36 100000
-*ParamCustomPageSize Orientation: 3 int 0 0
-*ParamCustomPageSize WidthOffset: 4 points 0 0
-*ParamCustomPageSize HeightOffset: 5 points 0 0
-
-*ijsServer: "hpijs"
-*ijsManufacturer: "HP"
-*ijsModel: "deskjet 5600"
-*ijsColorSpace: "rgb"
-
-*OpenGroup: General/General
-
-*OpenUI *Quality/Resolution, Quality, Ink Type, Media Type: PickOne
-*OrderDependency: 100 AnySetup *Quality
-*DefaultQuality: 600ColorCMYK
-
-*Quality 300ColorCMYK/300 dpi, Color, Black + Color Cartr.: ""
-*ijsParams Quality=300ColorCMYK: "Quality:Quality=0,Quality:ColorMode=2,Quality:MediaType=0,Quality:PenSet=2"
-*ijsResolution Quality=300ColorCMYK: "300 300"
-
-*Quality 300ColorCMYKFullBleed/300 dpi, Color, Full Bleed, Black + Color Cartr.: ""
-*ijsParams Quality=300ColorCMYKFullbleed: "Quality:Quality=0,Quality:ColorMode=2,Quality:MediaType=0,Quality:PenSet=2,Quality:FullBleed=1"
-*ijsResolution Quality=300ColorCMYKFullbleed: "300 300"
-
-*Quality 300DraftColorCMYK/300 dpi, Draft, Color, Black + Color Cartr.: ""
-*ijsParams Quality=300DraftColorCMYK: "Quality:Quality=1,Quality:ColorMode=2,Quality:MediaType=0,Quality:PenSet=2"
-*ijsResolution Quality=300DraftColorCMYK: "300 300"
-
-*Quality 300DraftGrayscaleCMYK/300 dpi, Draft, Grayscale, Black + Color Cartr.: ""
-*ijsParams Quality=300DraftGrayscaleCMYK: "Quality:Quality=1,Quality:ColorMode=0,Quality:MediaType=0,Quality:PenSet=2"
-*ijsResolution Quality=300DraftGrayscaleCMYK: "300 300"
-
-*Quality 300FastDraftColorCMYK/300 dpi, FastDraft, Color, Black + Color Cartr.: ""
-*ijsParams Quality=300FastDraftColorCMYK: "Quality:Quality=4,Quality:ColorMode=2,Quality:MediaType=0,Quality:PenSet=2"
-*ijsResolution 300FastDraftColorCMYK: "300 300"
-
-*Quality 300FastDraftGrayscaleCMYK/300 dpi, FastDraft, Grayscale, Black + Color Cartr.: ""
-*ijsParams Quality=300FastDraftGrayscaleCMYK: "Quality:Quality=4,Quality:ColorMode=0,Quality:MediaType=0,Quality:PenSet=2"
-*ijsResolution Quality=300FastDraftGrayscaleCMYK: "300 300"
-
-*Quality 300GrayscaleCMYK/300 dpi, Grayscale, Black + Color Cartr.: ""
-*ijsParams Quality=300GrayscaleCMYK: "Quality:Quality=0,Quality:ColorMode=0,Quality:MediaType=0,Quality:PenSet=2"
-*ijsResolution Quality=300GrayscaleCMYK: "300 300"
-
-*Quality 600ColorCMYK/600 dpi, Color, Black + Color Cartr.: ""
-*ijsParams Quality=600ColorCMYK: "Quality:Quality=0,Quality:ColorMode=2,Quality:MediaType=0,Quality:PenSet=2"
-*ijsResolution Quality=600ColorCMYK: "600 600"
-
-*Quality 600ColorCMYKFullBleed/600 dpi, Color, Full Bleed, Black + Color Cartr.: ""
-*ijsParams Quality=600ColorCMYKFullbleed: "Quality:Quality=0,Quality:ColorMode=2,Quality:MediaType=0,Quality:PenSet=2,Quality:FullBleed=1"
-*ijsResolution Quality=600ColorCMYKFullbleed: "600 600"
-
-*Quality 600GrayscaleCMYK/600 dpi, Grayscale, Black + Color Cartr.: ""
-*ijsParams Quality=600GrayscaleCMYK: "Quality:Quality=0,Quality:ColorMode=0,Quality:MediaType=0,Quality:PenSet=2"
-*ijsResolution Quality=600GrayscaleCMYK: "600 600"
-
-*Quality 1200PhotoCMYK/1200 dpi, Photo, Black + Color Cartr., Photo Paper: ""
-*ijsParams Quality=1200PhotoCMYK: "Quality:Quality=3,Quality:ColorMode=2,Quality:MediaType=2,Quality:PenSet=2"
-*ijsResolution Quality=1200PhotoCMYK: "1200 1200"
-
-*Quality 1200PhotoCMYKFullBleed/1200 dpi, Photo, Full Bleed, Black + Color Cartr., Photo Paper: ""
-*ijsParams Quality=1200PhotoCMYKFullBleed: "Quality:Quality=3,Quality:ColorMode=2,Quality:MediaType=3,Quality:PenSet=2,Quality:FullBleed=1"
-*ijsResolution Quality=1200PhotoCMYKFullBleed: "1200 1200"
-
-*CloseUI: *Quality
-
-*OpenUI *InputSlot/Media Source: PickOne
-*OrderDependency: 100 AnySetup *InputSlot
-*DefaultInputSlot: Default
-
-*InputSlot Default/Printer default: ""
-*ijsParams InputSlot=Default: "PS:MediaPosition=7"
-
-*InputSlot PhotoTray/Photo Tray: ""
-*ijsParams InputSlot=PhotoTray: "PS:MediaPosition=6"
-
-*InputSlot Upper/Upper Tray: ""
-*ijsParams InputSlot=Upper: "PS:MediaPosition=1"
-
-*InputSlot Lower/Lower Tray: ""
-*ijsParams InputSlot=Lower: "PS:MediaPosition=4"
-
-*InputSlot CDDVDTray/CD or DVD Tray: ""
-*ijsParams InputSlot=CDDVDTray: "PS:MediaPosition=14"
-
-*InputSlot Envelope/Envelope Feeder: ""
-*ijsParams InputSlot=Envelope: "PS:MediaPosition=3"
-
-*InputSlot LargeCapacity/Large Capacity Tray: ""
-*ijsParams InputSlot=LargeCapacity: "PS:MediaPosition=5"
-
-*InputSlot Manual/Manual Feeder: ""
-*ijsParams InputSlot=Manual: "PS:MediaPosition=2"
-
-*InputSlot MPTray/Multi Purpose Tray: ""
-*ijsParams InputSlot=MPTray: "PS:MediaPosition=8"
-
-*CloseUI: *InputSlot
-
-*OpenUI *PageSize/Page Size: PickOne
-*OrderDependency: 105 AnySetup *PageSize
-*DefaultPageSize: Letter
-*PageSize Letter/Letter: ""
-*PageSize A4/A4: ""
-*PageSize Photo/Photo or 4x6 inch index card: ""
-*PageSize Photo5x7/Photo or 5x7 inch index card: ""
-*PageSize PhotoTearOff/Photo with tear-off tab: ""
-*PageSize 3x5/3x5 inch index card: ""
-*PageSize 5x8/5x8 inch index card: ""
-*PageSize A3/A3: ""
-*PageSize A5/A5: ""
-*PageSize A6/A6: ""
-*PageSize A6TearOff/A6 with tear-off tab: ""
-*PageSize B4JIS/B4 (JIS): ""
-*PageSize B5JIS/B5 (JIS): ""
-*PageSize CDDVD80/CD or DVD 80 mm: ""
-*PageSize CDDVD120/CD or DVD 120 mm: ""
-*PageSize Env10/Envelope #10: ""
-*PageSize EnvC5/Envelope C5: ""
-*PageSize EnvC6/Envelope C6: ""
-*PageSize EnvDL/Envelope DL: ""
-*PageSize EnvISOB5/Envelope B5: ""
-*PageSize EnvMonarch/Envelope Monarch: ""
-*PageSize Executive/Executive: ""
-*PageSize FLSA/American Foolscap: ""
-*PageSize Hagaki/Hagaki: ""
-*PageSize Ledger/Ledger: ""
-*PageSize Legal/Legal: ""
-*PageSize Oufuku/Oufuku-Hagaki: ""
-*PageSize SuperB/Super B: ""
-*PageSize w558h774/16K: ""
-*PageSize w612h935/Executive (JIS): ""
-*PageSize w774h1116/8K: ""
-*CloseUI: *PageSize
-
-*OpenUI *PageRegion: PickOne
-*OrderDependency: 105 AnySetup *PageRegion
-*DefaultPageRegion: Letter
-*PageRegion Letter/Letter: ""
-*PageRegion A4/A4: ""
-*PageRegion Photo/Photo or 4x6 inch index card: ""
-*PageRegion Photo5x7/Photo or 5x7 inch index card: ""
-*PageRegion PhotoTearOff/Photo with tear-off tab: ""
-*PageRegion 3x5/3x5 inch index card: ""
-*PageRegion 5x8/5x8 inch index card: ""
-*PageRegion A3/A3: ""
-*PageRegion A5/A5: ""
-*PageRegion A6/A6: ""
-*PageRegion A6TearOff/A6 with tear-off tab: ""
-*PageRegion B4JIS/B4 (JIS): ""
-*PageRegion B5JIS/B5 (JIS): ""
-*PageRegion CDDVD80/CD or DVD 80 mm: ""
-*PageRegion CDDVD120/CD or DVD 120 mm: ""
-*PageRegion Env10/Envelope #10: ""
-*PageRegion EnvC5/Envelope C5: ""
-*PageRegion EnvC6/Envelope C6: ""
-*PageRegion EnvDL/Envelope DL: ""
-*PageRegion EnvISOB5/Envelope B5: ""
-*PageRegion EnvMonarch/Envelope Monarch: ""
-*PageRegion Executive/Executive: ""
-*PageRegion FLSA/American Foolscap: ""
-*PageRegion Hagaki/Hagaki: ""
-*PageRegion Ledger/Ledger: ""
-*PageRegion Legal/Legal: ""
-*PageRegion Oufuku/Oufuku-Hagaki: ""
-*PageRegion SuperB/Super B: ""
-*PageRegion w558h774/16K: ""
-*PageRegion w612h935/Executive (JIS): ""
-*PageRegion w774h1116/8K: ""
-*CloseUI: *PageRegion
-
-*DefaultImageableArea: Letter
-*ImageableArea Letter/Letter: "18 36 594 783"
-*ImageableArea A4/A4: "9.72 36 585.28 833"
-*ImageableArea Photo/Photo or 4x6 inch index card: "0 36 288 432"
-*ImageableArea Photo5x7/Photo or 5x7 inch index card: "0 36 360 504"
-*ImageableArea PhotoTearOff/Photo with tear-off tab: "0 0 288 432"
-*ImageableArea 3x5/3x5 inch index card: "0 36 216 360"
-*ImageableArea 5x8/5x8 inch index card: "0 36 360 576"
-*ImageableArea A3/A3: "14.40 36.00 827.60 1181"
-*ImageableArea A5/A5: "9 36 411 586"
-*ImageableArea A6/A6: "0 36 297 420"
-*ImageableArea A6TearOff/A6 with tear-off tab: "0 0 297 420"
-*ImageableArea B4JIS/B4 (JIS): "18 36 711 1024"
-*ImageableArea B5JIS/B5 (JIS): "18 36 498 720"
-*ImageableArea CDDVD80/CD or DVD 80 mm: "0 36 237 237"
-*ImageableArea CDDVD120/CD or DVD 120 mm: "0 36 360 360"
-*ImageableArea Env10/Envelope #10: "0 36 297 684"
-*ImageableArea EnvC5/Envelope C5: "18 36 441 640"
-*ImageableArea EnvC6/Envelope C6: "0 36 323 459"
-*ImageableArea EnvDL/Envelope DL: "0 36 312 624"
-*ImageableArea EnvISOB5/Envelope B5: "18 36 481 700"
-*ImageableArea EnvMonarch/Envelope Monarch: "0 36 279 540"
-*ImageableArea Executive/Executive: "18 36 504 747"
-*ImageableArea FLSA/American Foolscap: "18 36 594 927"
-*ImageableArea Hagaki/Hagaki: "0 36 283 420"
-*ImageableArea Ledger/Ledger: "14.40 36 777.60 1215"
-*ImageableArea Legal/Legal: "18 36 594 999"
-*ImageableArea Oufuku/Oufuku-Hagaki: "0 36 420 567"
-*ImageableArea SuperB/Super B: "14.40 36 921.60 1359"
-*ImageableArea w558h774/16K: "18 36 540 765"
-*ImageableArea w612h935/Executive (JIS): "18 36 594 926"
-*ImageableArea w774h1116/8K: "18 36 756 1107"
-
-*DefaultPaperDimension: Letter
-*PaperDimension Letter/Letter: "612 792"
-*PaperDimension A4/A4: "595 842"
-*PaperDimension Photo/Photo or 4x6 inch index card: "288 432"
-*PaperDimension Photo5x7/Photo or 5x7 inch index card: "360 504"
-*PaperDimension PhotoTearOff/Photo with tear-off tab: "288 432"
-*PaperDimension 3x5/3x5 inch index card: "216 360"
-*PaperDimension 5x8/5x8 inch index card: "360 576"
-*PaperDimension A3/A3: "842 1190"
-*PaperDimension A5/A5: "420 595"
-*PaperDimension A6/A6: "297 420"
-*PaperDimension A6TearOff/A6 with tear-off tab: "297 420"
-*PaperDimension B4JIS/B4 (JIS): "729 1033"
-*PaperDimension B5JIS/B5 (JIS): "516 729"
-*PaperDimension CDDVD80/CD or DVD 80 mm: "237 237"
-*PaperDimension CDDVD120/CD or DVD 120 mm: "360 360"
-*PaperDimension Env10/Envelope #10: "297 684"
-*PaperDimension EnvC5/Envelope C5: "459 649"
-*PaperDimension EnvC6/Envelope C6: "323 459"
-*PaperDimension EnvDL/Envelope DL: "312 624"
-*PaperDimension EnvISOB5/Envelope B5: "499 709"
-*PaperDimension EnvMonarch/Envelope Monarch: "279 540"
-*PaperDimension Executive/Executive: "522 756"
-*PaperDimension FLSA/American Foolscap: "612 936"
-*PaperDimension Hagaki/Hagaki: "283 420"
-*PaperDimension Ledger/Ledger: "792 1224"
-*PaperDimension Legal/Legal: "612 1008"
-*PaperDimension Oufuku/Oufuku-Hagaki: "420 567"
-*PaperDimension SuperB/Super B: "936 1368"
-*PaperDimension w558h774/16K: "558 774"
-*PaperDimension w612h935/Executive (JIS): "612 935"
-*PaperDimension w774h1116/8K: "774 1116"
-
-*OpenUI *Duplex/Double-Sided Printing: PickOne
-*FoomaticRIPOption Duplex: enum CmdLine A
-*OrderDependency: 120 AnySetup *Duplex
-*DefaultDuplex: None
-*Duplex DuplexNoTumble/Long Edge (Standard): ""
-*Duplex DuplexTumble/Short Edge (Flip): ""
-*Duplex None/Off: ""
-*CloseUI: *Duplex
-
-*CloseGroup: General
-
-
-*% Generic boilerplate PPD stuff as standard PostScript fonts and so on
-
-*DefaultFont: Courier
-*Font AvantGarde-Book: Standard "(001.006S)" Standard ROM
-*Font AvantGarde-BookOblique: Standard "(001.006S)" Standard ROM
-*Font AvantGarde-Demi: Standard "(001.007S)" Standard ROM
-*Font AvantGarde-DemiOblique: Standard "(001.007S)" Standard ROM
-*Font Bookman-Demi: Standard "(001.004S)" Standard ROM
-*Font Bookman-DemiItalic: Standard "(001.004S)" Standard ROM
-*Font Bookman-Light: Standard "(001.004S)" Standard ROM
-*Font Bookman-LightItalic: Standard "(001.004S)" Standard ROM
-*Font Courier: Standard "(002.004S)" Standard ROM
-*Font Courier-Bold: Standard "(002.004S)" Standard ROM
-*Font Courier-BoldOblique: Standard "(002.004S)" Standard ROM
-*Font Courier-Oblique: Standard "(002.004S)" Standard ROM
-*Font Helvetica: Standard "(001.006S)" Standard ROM
-*Font Helvetica-Bold: Standard "(001.007S)" Standard ROM
-*Font Helvetica-BoldOblique: Standard "(001.007S)" Standard ROM
-*Font Helvetica-Narrow: Standard "(001.006S)" Standard ROM
-*Font Helvetica-Narrow-Bold: Standard "(001.007S)" Standard ROM
-*Font Helvetica-Narrow-BoldOblique: Standard "(001.007S)" Standard ROM
-*Font Helvetica-Narrow-Oblique: Standard "(001.006S)" Standard ROM
-*Font Helvetica-Oblique: Standard "(001.006S)" Standard ROM
-*Font NewCenturySchlbk-Bold: Standard "(001.009S)" Standard ROM
-*Font NewCenturySchlbk-BoldItalic: Standard "(001.007S)" Standard ROM
-*Font NewCenturySchlbk-Italic: Standard "(001.006S)" Standard ROM
-*Font NewCenturySchlbk-Roman: Standard "(001.007S)" Standard ROM
-*Font Palatino-Bold: Standard "(001.005S)" Standard ROM
-*Font Palatino-BoldItalic: Standard "(001.005S)" Standard ROM
-*Font Palatino-Italic: Standard "(001.005S)" Standard ROM
-*Font Palatino-Roman: Standard "(001.005S)" Standard ROM
-*Font Symbol: Special "(001.007S)" Special ROM
-*Font Times-Bold: Standard "(001.007S)" Standard ROM
-*Font Times-BoldItalic: Standard "(001.009S)" Standard ROM
-*Font Times-Italic: Standard "(001.007S)" Standard ROM
-*Font Times-Roman: Standard "(001.007S)" Standard ROM
-*Font ZapfChancery-MediumItalic: Standard "(001.007S)" Standard ROM
-*Font ZapfDingbats: Special "(001.004S)" Standard ROM
-
