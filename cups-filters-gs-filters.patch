diff -up cups-filters-1.0.35/configure.ac.gs-filters cups-filters-1.0.35/configure.ac
--- cups-filters-1.0.35/configure.ac.gs-filters	2013-06-26 17:26:43.000000000 +0100
+++ cups-filters-1.0.35/configure.ac	2013-08-13 10:36:31.982178082 +0100
@@ -530,6 +530,21 @@ AS_IF([test x"$GCC" = "xyes"], [
 CFLAGS="$CFLAGS -D_GNU_SOURCE"
 CXXFLAGS="$CXXFLAGS -D_GNU_SOURCE"
 
+# =======
+# gstopxl
+# =======
+AC_PROG_SED
+dnl See if it is GNU sed or else.
+dnl - need more work to tell SED features.
+SED_EXTENDED_REGEX_OPT=-nre
+sed_variant=`sed --version 2>&1`
+sed_variant=`echo $sed_variant|sed -e 's/ .*//'`
+if test "$sed_variant" != GNU ; then
+SED_EXTENDED_REGEX_OPT=-nEe
+fi
+AC_SUBST(SED_EXTENDED_REGEX_OPT)
+AC_SUBST(CUPS_GHOSTSCRIPT)
+
 # =====================
 # Prepare all .in files
 # =====================
@@ -537,6 +552,7 @@ AC_CONFIG_FILES([
 	libcupsfilters.pc
 	libfontembed.pc
 	Makefile
+	filter/gstopxl
 	utils/cups-browsed
 	utils/cups-browsed.conf
 ])
diff -up cups-filters-1.0.35/COPYING.gs-filters cups-filters-1.0.35/COPYING
--- cups-filters-1.0.35/COPYING.gs-filters	2012-11-17 20:19:18.000000000 +0000
+++ cups-filters-1.0.35/COPYING	2013-08-13 10:36:31.956177963 +0100
@@ -7,7 +7,7 @@ Copyright 1993-2007 Easy Software Produc
 Copyright 2007-2011 Apple Inc.
 Copyright 2012 Canonical Ltd.
 Copyright 2006-2012 BBR Inc.
-Copyright 2008-2012 Till Kamppeter
+Copyright 2008-2013 Till Kamppeter
 Copyright 2008,2012 Tobias Hoffmann
 Copyright 2003 Robert Sander
 Copyright 2003-2006 Red Hat, Inc.
@@ -53,12 +53,13 @@ CLAIM, DAMAGES OR OTHER LIABILITY, WHETH
 TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
-The filter textonly and its PPD file textonly.ppd and also the filters
-texttops and imagetops are provided under the terms of version 2 of
-the GNU General Public License, or (at your option) any later
-version. This program is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+The filters gstopxl, textonly, and its PPD files pxlcolor.ppd,
+pxlmono.ppd, and textonly.ppd and also the filters texttops and
+imagetops are provided under the terms of version 2 of the GNU General
+Public License, or (at your option) any later version. This program is
+distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.
 
 The filter bannertopdf and all their auxiliary files is provided under
 the terms of version 3 of the GNU General Public License. This program
@@ -72,10 +73,10 @@ version.. This program is distributed in
 useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
-The filters pdftoijs, pdftoopvp, pdftopdf, and pdftoraster and all
-their auxiliary files and also libfontembed in the filter/fontembed
-subdirectory (used by texttopdf) are also free software and are
-published under MIT license:
+The filters gstoraster, pdftoijs, pdftoopvp, pdftopdf, and pdftoraster
+and all their auxiliary files and also libfontembed in the
+filter/fontembed subdirectory (used by texttopdf) are also free
+software and are published under MIT license:
 
 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
diff -up cups-filters-1.0.35/cupsfilters/raster.c.gs-filters cups-filters-1.0.35/cupsfilters/raster.c
--- cups-filters-1.0.35/cupsfilters/raster.c.gs-filters	2013-08-13 10:36:31.983178087 +0100
+++ cups-filters-1.0.35/cupsfilters/raster.c	2013-08-13 10:36:31.983178087 +0100
@@ -0,0 +1,1030 @@
+/*
+ *   Function to apply IPP options to a CUPS/PWG Raster header.
+ *
+ *   Copyright 2013 by Till Kamppeter.
+ *
+ *   Distribution and use rights are outlined in the file "COPYING"
+ *   which should have been included with this file.
+ *
+ * Contents:
+ *
+ *   cupsRasterParseIPPOptions() - Parse IPP options from the command line
+ *                                 and apply them to the CUPS Raster header.
+ */
+
+/*
+ * Include necessary headers.
+ */
+
+#include "driver.h"
+#include <config.h>
+#include <string.h>
+#include <ctype.h>
+#include <cups/pwg.h>
+
+/*
+ * '_strlcpy()' - Safely copy two strings.
+ */
+
+size_t					/* O - Length of string */
+_strlcpy(char       *dst,		/* O - Destination string */
+	 const char *src,		/* I - Source string */
+	 size_t      size)		/* I - Size of destination string buffer */
+{
+  size_t	srclen;			/* Length of source string */
+
+
+ /*
+  * Figure out how much room is needed...
+  */
+
+  size --;
+
+  srclen = strlen(src);
+
+ /*
+  * Copy the appropriate amount...
+  */
+
+  if (srclen > size)
+    srclen = size;
+
+  memcpy(dst, src, srclen);
+  dst[srclen] = '\0';
+
+  return (srclen);
+}
+
+/*
+ * 'cupsRasterParseIPPOptions()' - Parse IPP options from the command line
+ *                                 and apply them to the CUPS Raster header.
+ */
+
+int                                          /* O - -1 on error, 0 on success */
+cupsRasterParseIPPOptions(cups_page_header2_t *h, /* I - Raster header */
+			  int num_options,        /* I - Number of options */
+			  cups_option_t *options, /* I - Options */
+			  int pwg_raster,         /* I - 1 if PWG Raster */
+			  int set_defaults)       /* I - If 1, se default values
+						     for all fields for which
+						     we did not get an option */
+{
+  int		i;			/* Looping var */
+  char		*ptr,			/* Pointer into string */
+		s[255];			/* Temporary string */
+  const char	*val,			/* Pointer into value */
+		*media,			/* media option */
+		*page_size,		/* PageSize option */
+                *media_source,          /* Media source */
+                *media_type;		/* Media type */
+  pwg_media_t   *size_found;            /* page size found for given name */
+
+ /*
+  * Range check input...
+  */
+
+  if (!h)
+    return (-1);
+
+ /*
+  * Check if the supplied "media" option is a comma-separated list of any
+  * combination of page size ("media"), media source ("media-position"),
+  * and media type ("media-type") and if so, put these list elements into
+  * their dedicated options.
+  */
+
+  page_size = NULL;
+  media_source = NULL;
+  media_type = NULL;
+  if ((media = cupsGetOption("media", num_options, options)) != NULL)
+  {
+   /*
+    * Loop through the option string, separating it at commas and marking each
+    * individual option as long as the corresponding PPD option (PageSize,
+    * InputSlot, etc.) is not also set.
+    *
+    * For PageSize, we also check for an empty option value since some versions
+    * of MacOS X use it to specify auto-selection of the media based solely on
+    * the size.
+    */
+
+    for (val = media; *val;)
+    {
+     /*
+      * Extract the sub-option from the string...
+      */
+
+      for (ptr = s; *val && *val != ',' && (ptr - s) < (sizeof(s) - 1);)
+	*ptr++ = *val++;
+      *ptr++ = '\0';
+
+      if (*val == ',')
+	val ++;
+
+     /*
+      * Identify it...
+      */
+
+      size_found = NULL;
+      if ((size_found = pwgMediaForPWG(s)) == NULL)
+	if ((size_found = pwgMediaForPPD(s)) == NULL)
+	  if ((size_found = pwgMediaForPPD(s)) == NULL)
+	  {
+	    if (strcasestr(s, "tray") ||
+		strcasestr(s, "feed") ||
+		strcasestr(s, "capacity") ||
+		strcasestr(s, "upper") ||
+		strcasestr(s, "top") ||
+		strcasestr(s, "middle") ||
+		strcasestr(s, "lower") ||
+		strcasestr(s, "bottom") ||
+		strcasestr(s, "left") ||
+		strcasestr(s, "right") ||
+		strcasestr(s, "side") ||
+		strcasestr(s, "main"))
+	      media_source = strdup(s);
+	    else
+	      media_type = strdup(s);
+	  }
+      if (size_found)
+	page_size = strdup(size_found->pwg);
+    }
+  }
+
+  if (pwg_raster)
+    strcpy(h->MediaClass, "PwgRaster");
+  else if ((val = cupsGetOption("media-class", num_options, options)) != NULL ||
+	   (val = cupsGetOption("MediaClass", num_options, options)) != NULL)
+    _strlcpy(h->MediaClass, val, sizeof(h->MediaClass));
+  else if (set_defaults)
+    strcpy(h->MediaClass, "PwgRaster");
+
+  if ((val = cupsGetOption("media-color", num_options, options)) != NULL ||
+      (val = cupsGetOption("MediaColor", num_options, options)) != NULL)
+    _strlcpy(h->MediaColor, val, sizeof(h->MediaColor));
+  else if (set_defaults)
+    h->MediaColor[0] = '\0';
+
+  if ((val = cupsGetOption("media-type", num_options, options)) != NULL ||
+      (val = cupsGetOption("MediaType", num_options, options)) != NULL ||
+      (val = media_type) != NULL)
+    _strlcpy(h->MediaType, val, sizeof(h->MediaType));
+  else if (set_defaults)
+    h->MediaType[0] = '\0';
+
+  if ((val = cupsGetOption("print-content-optimize", num_options,
+			   options)) != NULL ||
+      (val = cupsGetOption("output-type", num_options, options)) != NULL ||
+      (val = cupsGetOption("OutputType", num_options, options)) != NULL)
+  {
+    if (!strcasecmp(val, "automatic"))
+      _strlcpy(h->OutputType, "Automatic",
+	      sizeof(h->OutputType));
+    else if (!strcasecmp(val, "graphics"))
+      _strlcpy(h->OutputType, "Graphics", sizeof(h->OutputType));
+    else if (!strcasecmp(val, "photo"))
+      _strlcpy(h->OutputType, "Photo", sizeof(h->OutputType));
+    else if (!strcasecmp(val, "text"))
+      _strlcpy(h->OutputType, "Text", sizeof(h->OutputType));
+    else if (!strcasecmp(val, "text-and-graphics") ||
+	     !strcasecmp(val, "TextAndGraphics"))
+      _strlcpy(h->OutputType, "TextAndGraphics",
+	      sizeof(h->OutputType));
+    else if (pwg_raster)
+      fprintf(stderr, "DEBUG: Unsupported print-content-type \"%s\".\n", val);
+    else
+      _strlcpy(h->OutputType, val, sizeof(h->OutputType));
+  }
+  else if (set_defaults)
+    _strlcpy(h->OutputType, "Automatic", sizeof(h->OutputType));
+
+  if (pwg_raster)
+  {
+    /* Set "reserved" fields to 0 */
+    h->AdvanceDistance = 0;
+    h->AdvanceMedia = CUPS_ADVANCE_NONE;
+    h->Collate = CUPS_FALSE;
+  }
+  else
+  {
+    /* TODO - Support for advance distance and advance media */
+    if (set_defaults)
+    {
+      h->AdvanceDistance = 0;
+      h->AdvanceMedia = CUPS_ADVANCE_NONE;
+    }
+    if ((val = cupsGetOption("Collate", num_options, options)) != NULL &&
+	(!strcasecmp(val, "true") || !strcasecmp(val, "on") ||
+	 !strcasecmp(val, "yes")))
+      h->Collate = CUPS_TRUE;
+    else if ((val = cupsGetOption("Collate", num_options, options)) != NULL &&
+	     (!strcasecmp(val, "false") || !strcasecmp(val, "off") ||
+	      !strcasecmp(val, "no")))
+      h->Collate = CUPS_FALSE;
+    else if (set_defaults)
+      h->Collate = CUPS_FALSE;
+  }
+
+  if (set_defaults)
+    h->CutMedia = CUPS_CUT_NONE;
+
+  if ((val = cupsGetOption("sides", num_options, options)) != NULL ||
+      (val = cupsGetOption("Duplex", num_options, options)) != NULL)
+  {
+    if (!strcasecmp(val, "None") || !strcasecmp(val, "Off") ||
+	!strcasecmp(val, "False") || !strcasecmp(val, "No") ||
+	!strcasecmp(val, "one-sided") || !strcasecmp(val, "OneSided"))
+      h->Duplex = CUPS_FALSE;
+    else if (!strcasecmp(val, "On") ||
+	     !strcasecmp(val, "True") || !strcasecmp(val, "Yes") ||
+	     !strncasecmp(val, "two-sided", 9) ||
+	     !strncasecmp(val, "TwoSided", 8) ||
+	     !strncasecmp(val, "Duplex", 6))
+      h->Duplex = CUPS_TRUE;
+    else if (set_defaults)
+      h->Duplex = CUPS_FALSE;
+  }
+  else if (set_defaults)
+    h->Duplex = CUPS_FALSE;
+
+  if ((val = cupsGetOption("printer-resolution", num_options,
+			   options)) != NULL ||
+      (val = cupsGetOption("Resolution", num_options, options)) != NULL)
+  {
+    int	        xres,		/* X resolution */
+                yres;		/* Y resolution */
+    char	*ptr;		/* Pointer into value */
+
+    xres = yres = strtol(val, (char **)&ptr, 10);
+    if (ptr > val && xres > 0)
+    {
+      if (*ptr == 'x')
+	yres = strtol(ptr + 1, (char **)&ptr, 10);
+    }
+
+    if (ptr <= val || xres <= 0 || yres <= 0 || !ptr ||
+	(strcasecmp(ptr, "dpi") &&
+	 strcasecmp(ptr, "dpc") &&
+	 strcasecmp(ptr, "dpcm")))
+    {
+      fprintf(stderr, "DEBUG: Bad resolution value \"%s\".\n", val);
+      if (set_defaults)
+      {
+	h->HWResolution[0] = 600;
+	h->HWResolution[1] = 600;
+      }
+    }
+    else
+    {
+      if (!strcasecmp(ptr, "dpc") ||
+	  !strcasecmp(ptr, "dpcm"))
+      {
+	xres = xres * 254 / 100;
+	yres = yres * 254 / 100;
+      }
+      h->HWResolution[0] = xres;
+      h->HWResolution[1] = yres;
+    }
+  }
+  else if (set_defaults)
+  {
+    h->HWResolution[0] = 600;
+    h->HWResolution[1] = 600;
+  }
+  
+  if (set_defaults)
+  {
+    /* TODO - Support for insert sheets */
+    h->InsertSheet = CUPS_FALSE;
+  }
+
+  if (set_defaults)
+  {
+    /* TODO - Support for jog */
+    h->Jog = CUPS_JOG_NONE;
+  }
+
+  if ((val = cupsGetOption("feed-orientation", num_options,
+			   options)) != NULL ||
+      (val = cupsGetOption("feed-direction", num_options, options)) != NULL ||
+      (val = cupsGetOption("LeadingEdge", num_options, options)) != NULL)
+  {
+    if (!strcasecmp(val, "ShortEdgeFirst"))
+      h->LeadingEdge = CUPS_EDGE_TOP;
+    else if (!strcasecmp(val, "LongEdgeFirst"))
+      h->LeadingEdge = CUPS_EDGE_RIGHT;
+    else
+      fprintf(stderr, "DEBUG: Unsupported feed-orientation \"%s\".\n", val);
+  }
+  else if (set_defaults)
+    h->LeadingEdge = CUPS_EDGE_TOP;
+
+  if (pwg_raster || set_defaults)
+  {
+    /* TODO - Support for margins */
+    h->Margins[0] = 0;
+    h->Margins[1] = 0;
+  }
+
+  if (pwg_raster || set_defaults)
+  {
+    /* TODO - Support for manual feed */
+    h->ManualFeed = CUPS_FALSE;
+  }
+
+  if ((val = cupsGetOption("media-position", num_options, options)) != NULL ||
+      (val = cupsGetOption("MediaPosition", num_options, options)) != NULL ||
+      (val = cupsGetOption("media-source", num_options, options)) != NULL ||
+      (val = cupsGetOption("MediaSource", num_options, options)) != NULL ||
+      (val = cupsGetOption("InputSlot", num_options, options)) != NULL ||
+      (val = media_source) != NULL)
+  {
+    if (!strncasecmp(val, "Auto", 4) ||
+	!strncasecmp(val, "Default", 7))
+      h->MediaPosition = 0;
+    else if (!strcasecmp(val, "Main"))
+      h->MediaPosition = 1;
+    else if (!strcasecmp(val, "Alternate"))
+      h->MediaPosition = 2;
+    else if (!strcasecmp(val, "LargeCapacity"))
+      h->MediaPosition = 3;
+    else if (!strcasecmp(val, "Manual"))
+      h->MediaPosition = 4;
+    else if (!strcasecmp(val, "Envelope"))
+      h->MediaPosition = 5;
+    else if (!strcasecmp(val, "Disc"))
+      h->MediaPosition = 6;
+    else if (!strcasecmp(val, "Photo"))
+      h->MediaPosition = 7;
+    else if (!strcasecmp(val, "Hagaki"))
+      h->MediaPosition = 8;
+    else if (!strcasecmp(val, "MainRoll"))
+      h->MediaPosition = 9;
+    else if (!strcasecmp(val, "AlternateRoll"))
+      h->MediaPosition = 10;
+    else if (!strcasecmp(val, "Top"))
+      h->MediaPosition = 11;
+    else if (!strcasecmp(val, "Middle"))
+      h->MediaPosition = 12;
+    else if (!strcasecmp(val, "Bottom"))
+      h->MediaPosition = 13;
+    else if (!strcasecmp(val, "Side"))
+      h->MediaPosition = 14;
+    else if (!strcasecmp(val, "Left"))
+      h->MediaPosition = 15;
+    else if (!strcasecmp(val, "Right"))
+      h->MediaPosition = 16;
+    else if (!strcasecmp(val, "Center"))
+      h->MediaPosition = 17;
+    else if (!strcasecmp(val, "Rear"))
+      h->MediaPosition = 18;
+    else if (!strcasecmp(val, "ByPassTray"))
+      h->MediaPosition = 19;
+    else if (!strcasecmp(val, "Tray1"))
+      h->MediaPosition = 20;
+    else if (!strcasecmp(val, "Tray2"))
+      h->MediaPosition = 21;
+    else if (!strcasecmp(val, "Tray3"))
+      h->MediaPosition = 22;
+    else if (!strcasecmp(val, "Tray4"))
+      h->MediaPosition = 23;
+    else if (!strcasecmp(val, "Tray5"))
+      h->MediaPosition = 24;
+    else if (!strcasecmp(val, "Tray6"))
+      h->MediaPosition = 25;
+    else if (!strcasecmp(val, "Tray7"))
+      h->MediaPosition = 26;
+    else if (!strcasecmp(val, "Tray8"))
+      h->MediaPosition = 27;
+    else if (!strcasecmp(val, "Tray9"))
+      h->MediaPosition = 28;
+    else if (!strcasecmp(val, "Tray10"))
+      h->MediaPosition = 29;
+    else if (!strcasecmp(val, "Tray11"))
+      h->MediaPosition = 30;
+    else if (!strcasecmp(val, "Tray12"))
+      h->MediaPosition = 31;
+    else if (!strcasecmp(val, "Tray13"))
+      h->MediaPosition = 32;
+    else if (!strcasecmp(val, "Tray14"))
+      h->MediaPosition = 33;
+    else if (!strcasecmp(val, "Tray15"))
+      h->MediaPosition = 34;
+    else if (!strcasecmp(val, "Tray16"))
+      h->MediaPosition = 35;
+    else if (!strcasecmp(val, "Tray17"))
+      h->MediaPosition = 36;
+    else if (!strcasecmp(val, "Tray18"))
+      h->MediaPosition = 37;
+    else if (!strcasecmp(val, "Tray19"))
+      h->MediaPosition = 38;
+    else if (!strcasecmp(val, "Tray20"))
+      h->MediaPosition = 39;
+    else if (!strcasecmp(val, "Roll1"))
+      h->MediaPosition = 40;
+    else if (!strcasecmp(val, "Roll2"))
+      h->MediaPosition = 41;
+    else if (!strcasecmp(val, "Roll3"))
+      h->MediaPosition = 42;
+    else if (!strcasecmp(val, "Roll4"))
+      h->MediaPosition = 43;
+    else if (!strcasecmp(val, "Roll5"))
+      h->MediaPosition = 44;
+    else if (!strcasecmp(val, "Roll6"))
+      h->MediaPosition = 45;
+    else if (!strcasecmp(val, "Roll7"))
+      h->MediaPosition = 46;
+    else if (!strcasecmp(val, "Roll8"))
+      h->MediaPosition = 47;
+    else if (!strcasecmp(val, "Roll9"))
+      h->MediaPosition = 48;
+    else if (!strcasecmp(val, "Roll10"))
+      h->MediaPosition = 49;
+    else
+      fprintf(stderr, "DEBUG: Unsupported media source \"%s\".\n", val);
+  }
+  else if (set_defaults)
+    h->MediaPosition = 0; /* Auto */
+
+  if ((val = cupsGetOption("media-weight", num_options, options)) != NULL ||
+      (val = cupsGetOption("MediaWeight", num_options, options)) != NULL ||
+      (val = cupsGetOption("media-weight-metric", num_options,
+			   options)) != NULL ||
+      (val = cupsGetOption("MediaWeightMetric", num_options, options)) != NULL)
+    h->MediaWeight = atol(val);
+  else if (set_defaults)
+    h->MediaWeight = 0;
+
+  if (pwg_raster)
+  {
+    /* Set "reserved" fields to 0 */
+    h->MirrorPrint = CUPS_FALSE;
+    h->NegativePrint = CUPS_FALSE;
+  }
+  else
+  {
+    if ((val = cupsGetOption("mirror-print", num_options, options)) != NULL ||
+	(val = cupsGetOption("MirrorPrint", num_options, options)) != NULL)
+    {
+      if (!strcasecmp(val, "true") || !strcasecmp(val, "on") ||
+	  !strcasecmp(val, "yes"))
+	h->MirrorPrint = CUPS_TRUE;
+      else if (!strcasecmp(val, "false") ||
+	       !strcasecmp(val, "off") ||
+	       !strcasecmp(val, "no"))
+	h->MirrorPrint = CUPS_FALSE;
+      else if (set_defaults)
+	h->MirrorPrint = CUPS_FALSE;
+    }
+    if ((val = cupsGetOption("negative-print", num_options, options)) != NULL ||
+	(val = cupsGetOption("NegativePrint", num_options, options)) != NULL)
+    {
+      if (!strcasecmp(val, "true") || !strcasecmp(val, "on") ||
+	  !strcasecmp(val, "yes"))
+	h->NegativePrint = CUPS_TRUE;
+      else if (!strcasecmp(val, "false") ||
+	       !strcasecmp(val, "off") ||
+	       !strcasecmp(val, "no"))
+	h->NegativePrint = CUPS_FALSE;
+      else if (set_defaults)
+	h->NegativePrint = CUPS_FALSE;
+    }
+  }
+
+  if ((val = cupsGetOption("copies", num_options, options)) != NULL ||
+      (val = cupsGetOption("Copies", num_options, options)) != NULL ||
+      (val = cupsGetOption("num-copies", num_options, options)) != NULL ||
+      (val = cupsGetOption("NumCopies", num_options, options)) != NULL)
+    h->NumCopies = atol(val);
+  else if (set_defaults)
+    h->NumCopies = 1; /* 0 = Printer default */
+
+  if ((val = cupsGetOption("orientation-requested", num_options,
+			   options)) != NULL ||
+      (val = cupsGetOption("OrientationRequested", num_options,
+			   options)) != NULL ||
+      (val = cupsGetOption("Orientation", num_options, options)) != NULL)
+  {
+    if (!strcasecmp(val, "Portrait") ||
+	!strcasecmp(val, "3"))
+      h->Orientation = CUPS_ORIENT_0;
+    else if (!strcasecmp(val, "Landscape") ||
+	     !strcasecmp(val, "4"))
+      h->Orientation = CUPS_ORIENT_90;
+    else if (!strcasecmp(val, "reverse-portrait") ||
+	     !strcasecmp(val, "ReversePortrait") ||
+	     !strcasecmp(val, "5"))
+      h->Orientation = CUPS_ORIENT_180;
+    else if (!strcasecmp(val, "reverse-landscape") ||
+	     !strcasecmp(val, "ReverseLandscape") ||
+	     !strcasecmp(val, "6"))
+      h->Orientation = CUPS_ORIENT_270;
+    else
+      fprintf(stderr, "DEBUG: Unsupported Orientation \"%s\".\n", val);
+  }
+  else if (set_defaults)
+    h->Orientation = CUPS_ORIENT_0;
+
+  if (pwg_raster)
+  {
+    /* Set "reserved" fields to 0 */
+    h->OutputFaceUp = CUPS_FALSE;
+  }
+  else
+  {
+    if ((val = cupsGetOption("OutputFaceUp", num_options, options)) != NULL ||
+	(val = cupsGetOption("output-face-up", num_options, options)) != NULL)
+    {
+      if (!strcasecmp(val, "true") || !strcasecmp(val, "on") ||
+	  !strcasecmp(val, "yes"))
+	h->OutputFaceUp = CUPS_TRUE;
+      else if (!strcasecmp(val, "false") ||
+	       !strcasecmp(val, "off") ||
+	       !strcasecmp(val, "no"))
+	h->OutputFaceUp = CUPS_FALSE;
+      else if (set_defaults)
+	h->OutputFaceUp = CUPS_FALSE;
+    }
+  }
+
+  if ((val = cupsGetOption("media-size", num_options, options)) != NULL ||
+      (val = cupsGetOption("MediaSize", num_options, options)) != NULL ||
+      (val = cupsGetOption("page-size", num_options, options)) != NULL ||
+      (val = cupsGetOption("PageSize", num_options, options)) != NULL ||
+      (val = page_size) != NULL)
+  {
+    size_found = NULL;
+    if ((size_found = pwgMediaForPWG(val)) == NULL)
+      if ((size_found = pwgMediaForPPD(val)) == NULL)
+	size_found = pwgMediaForLegacy(val);
+    if (size_found != NULL)
+    {
+      h->PageSize[0] = size_found->width * 72 / 2540;
+      h->PageSize[1] = size_found->length * 72 / 2540;
+      _strlcpy(h->cupsPageSizeName, size_found->pwg,
+	      sizeof(h->cupsPageSizeName));
+      if (pwg_raster)
+      {
+	h->cupsPageSize[0] = 0.0;
+	h->cupsPageSize[1] = 0.0;
+      }
+      else
+      {
+	h->cupsPageSize[0] = size_found->width * 72.0 / 2540.0;
+	h->cupsPageSize[1] = size_found->length * 72.0 / 2540.0;
+      }
+    }
+    else
+      fprintf(stderr, "DEBUG: Unsupported page size %s.\n", val);
+  }
+  else if (set_defaults)
+  {
+    /* TODO: Automatic A4/Letter, like in scheduler/conf.c in CUPS. */
+    h->PageSize[0] = 612;
+    h->PageSize[1] = 792;
+    _strlcpy(h->cupsPageSizeName, "na_letter_8.5x11in",
+	    sizeof(h->cupsPageSizeName));
+    if (pwg_raster)
+    {
+      h->cupsPageSize[0] = 0.0;
+      h->cupsPageSize[1] = 0.0;
+    }
+  }
+  else if (pwg_raster)
+  {
+    h->cupsPageSize[0] = 0.0;
+    h->cupsPageSize[1] = 0.0;
+  }
+
+  if (pwg_raster)
+  {
+    /* Set "reserved" fields to 0 */
+    h->ImagingBoundingBox[0] = 0;
+    h->ImagingBoundingBox[1] = 0;
+    h->ImagingBoundingBox[2] = 0;
+    h->ImagingBoundingBox[3] = 0;
+    h->cupsImagingBBox[0] = 0.0;
+    h->cupsImagingBBox[1] = 0.0;
+    h->cupsImagingBBox[2] = 0.0;
+    h->cupsImagingBBox[3] = 0.0;
+  }
+  else
+  {
+    /* TODO - Support for non-zero margins */
+    h->ImagingBoundingBox[0] = 0;
+    h->ImagingBoundingBox[1] = 0;
+    h->ImagingBoundingBox[2] = h->PageSize[0];
+    h->ImagingBoundingBox[3] = h->PageSize[1];
+    h->cupsImagingBBox[0] = 0.0;
+    h->cupsImagingBBox[1] = 0.0;
+    h->cupsImagingBBox[2] = h->cupsPageSize[0];
+    h->cupsImagingBBox[3] = h->cupsPageSize[1];
+  }
+
+  if (pwg_raster)
+  {
+    /* Set "reserved" fields to 0 */
+    h->Separations = CUPS_FALSE;
+    h->TraySwitch = CUPS_FALSE;
+  }
+  else
+  {
+    if ((val = cupsGetOption("separations", num_options, options)) != NULL ||
+	(val = cupsGetOption("Separations", num_options, options)) != NULL)
+    {
+      if (!strcasecmp(val, "true") || !strcasecmp(val, "on") ||
+	  !strcasecmp(val, "yes"))
+	h->Separations = CUPS_TRUE;
+      else if (!strcasecmp(val, "false") ||
+	       !strcasecmp(val, "off") ||
+	       !strcasecmp(val, "no"))
+	h->Separations = CUPS_FALSE;
+      else if (set_defaults)
+	h->Separations = CUPS_FALSE;
+    }
+    if ((val = cupsGetOption("tray-switch", num_options, options)) != NULL ||
+	(val = cupsGetOption("TraySwitch", num_options, options)) != NULL)
+    {
+      if (!strcasecmp(val, "true") || !strcasecmp(val, "on") ||
+	  !strcasecmp(val, "yes"))
+	h->TraySwitch = CUPS_TRUE;
+      else if (!strcasecmp(val, "false") ||
+	       !strcasecmp(val, "off") ||
+	       !strcasecmp(val, "no"))
+	h->TraySwitch = CUPS_FALSE;
+      else if (set_defaults)
+	h->TraySwitch = CUPS_FALSE;
+    }
+  }
+
+  if ((val = cupsGetOption("sides", num_options, options)) != NULL ||
+      (val = cupsGetOption("Tumble", num_options, options)) != NULL)
+  {
+    if (!strcasecmp(val, "None") || !strcasecmp(val, "Off") ||
+	!strcasecmp(val, "False") || !strcasecmp(val, "No") ||
+	!strcasecmp(val, "one-sided") || !strcasecmp(val, "OneSided") ||
+	!strcasecmp(val, "two-sided-long-edge") ||
+	!strcasecmp(val, "TwoSidedLongEdge") ||
+	!strcasecmp(val, "DuplexNoTumble"))
+      h->Tumble = CUPS_FALSE;
+    else if (!strcasecmp(val, "On") ||
+	     !strcasecmp(val, "True") || !strcasecmp(val, "Yes") ||
+	     !strcasecmp(val, "two-sided-short-edge") ||
+	     !strcasecmp(val, "TwoSidedShortEdge") ||
+	     !strcasecmp(val, "DuplexTumble"))
+      h->Tumble = CUPS_TRUE;
+    else if (set_defaults)
+      h->Tumble = CUPS_FALSE;
+  }
+  else if (set_defaults)
+    h->Tumble = CUPS_FALSE;
+
+  h->cupsWidth = h->HWResolution[0] * h->PageSize[0] / 72;
+  h->cupsHeight = h->HWResolution[1] * h->PageSize[1] / 72;
+
+  if (pwg_raster || set_defaults)
+  {
+    /* TODO - Support for MediaType number */
+    h->cupsMediaType = 0;
+  }
+
+  if ((val = cupsGetOption("pwg-raster-document-type", num_options,
+			   options)) != NULL ||
+      (val = cupsGetOption("PwgRasterDocumentType", num_options,
+			   options)) != NULL ||
+      (val = cupsGetOption("print-color-mode", num_options,
+			   options)) != NULL ||
+      (val = cupsGetOption("PrintColorMode", num_options, options)) != NULL ||
+      (val = cupsGetOption("color-space", num_options, options)) != NULL ||
+      (val = cupsGetOption("ColorSpace", num_options, options)) != NULL ||
+      (val = cupsGetOption("color-model", num_options, options)) != NULL ||
+      (val = cupsGetOption("ColorModel", num_options, options)) != NULL)
+  {
+    int	        bitspercolor,	/* Bits per color */
+                bitsperpixel,   /* Bits per pixel */
+                colorspace,     /* CUPS/PWG raster color space */
+                numcolors;	/* Number of colorants */
+    const char	*ptr;		/* Pointer into value */
+
+    ptr = NULL;
+    numcolors = 0;
+    bitspercolor = 8;
+    if (!strncasecmp(val, "AdobeRgb", 8))
+    {
+      if (*(val + 8) == '_') 
+	ptr = val + 9;
+      colorspace = 20;
+      numcolors = 3;
+    }
+    else if (!strncasecmp(val, "Black", 5))
+    {
+      if (*(val + 5) == '_') 
+	ptr = val + 6;
+      bitspercolor = 1;
+      colorspace = 3;
+      numcolors = 1;
+    }
+    else if (!strncasecmp(val, "Cmyk", 4))
+    {
+      if (*(val + 4) == '_') 
+	ptr = val + 5;
+      colorspace = 6;
+      numcolors = 4;
+    }
+    else if (!strncasecmp(val, "Device", 6))
+    {
+      ptr = val + 6;
+      numcolors = strtol(ptr, (char **)&ptr, 10);
+      if (*ptr == '_')
+      {
+	ptr ++;
+	colorspace = 47 + numcolors;
+      }
+      else
+      {
+	numcolors = 0;
+	ptr = NULL;
+      }
+    }
+    else if (!strncasecmp(val, "Rgb", 3))
+    {
+      if (*(val + 3) == '_') 
+	ptr = val + 4;
+      colorspace = 1;
+      numcolors = 3;
+    }
+    else if (!strncasecmp(val, "Sgray", 5))
+    {
+      if (*(val + 5) == '_') 
+	ptr = val + 6;
+      colorspace = 18;
+      numcolors = 1;
+    }
+    else if (!strncasecmp(val, "Srgb", 4))
+    {
+      if (*(val + 4) == '_') 
+	ptr = val + 5;
+      colorspace = 19;
+      numcolors = 3;
+    }
+    if (numcolors > 0)
+    {
+      if (ptr)
+	bitspercolor = strtol(ptr, (char **)&ptr, 10);
+      bitsperpixel = bitspercolor * numcolors;
+      h->cupsBitsPerColor = bitspercolor;
+      h->cupsBitsPerPixel = bitsperpixel;
+      h->cupsColorSpace = colorspace;
+      h->cupsNumColors = numcolors;
+    }
+    else
+    {
+      fprintf(stderr, "DEBUG: Bad color space value \"%s\".\n", val);
+      if (set_defaults)
+      {
+	h->cupsBitsPerColor = 1;
+	h->cupsBitsPerPixel = 1;
+	h->cupsColorSpace = 3;
+	h->cupsNumColors = 1;
+      }
+    }
+  }
+  else if (set_defaults)
+  {
+    h->cupsBitsPerColor = 1;
+    h->cupsBitsPerPixel = 1;
+    h->cupsColorSpace = 3;
+    h->cupsNumColors = 1;
+  }
+
+  h->cupsBytesPerLine = (h->cupsWidth * h->cupsBitsPerPixel + 7) / 8;
+  
+  if (pwg_raster || set_defaults)
+  {
+    /* TODO - Support for color orders 1 (banded) and 2 (planar) */
+    h->cupsColorOrder = 0;
+  }
+  
+  if (pwg_raster || set_defaults)
+  {
+    /* TODO - Support for these parameters */
+    h->cupsCompression = 0;
+    h->cupsRowCount = 0;
+    h->cupsRowFeed = 0;
+    h->cupsRowStep = 0;
+  }
+
+  if (pwg_raster || set_defaults)
+  {
+    /* TODO - Support for cupsBorderlessScalingFactor */
+    h->cupsBorderlessScalingFactor = 0.0;
+  }
+
+  if (pwg_raster || set_defaults)
+  {
+    /* TODO - Support for custom values in CUPS Raster mode */
+    for (i = 0; i < 16; i ++)
+    {
+      h->cupsInteger[i] = 0;
+      h->cupsReal[i] = 0.0;
+      memset(h->cupsString[i], 0, 64);
+    }
+  }
+
+  if (pwg_raster)
+  {
+    
+    if ((val = cupsGetOption("job-impressions", num_options,
+			     options)) != NULL ||
+	(val = cupsGetOption("JobImpressions", num_options, options)) != NULL ||
+	(val = cupsGetOption("Impressions", num_options, options)) != NULL)
+    {
+      int impressions = atoi(val);
+      if (impressions >= 0)
+	h->cupsInteger[0] = impressions;
+    }
+
+    if ((val = cupsGetOption("pwg-raster-document-sheet-back", num_options,
+			     options)) != NULL ||
+	(val = cupsGetOption("PwgRasterDocumentSheetBack", num_options,
+			     options)) != NULL)
+    {
+      /* Set CrossFeedTransform and FeedTransform */
+      if (h->Duplex == CUPS_FALSE)
+      {
+	h->cupsInteger[1] = 1;
+	h->cupsInteger[2] = 1;
+      }
+      else if (h->Duplex == CUPS_TRUE)
+      {
+	if (h->Tumble == CUPS_FALSE)
+	{
+	  if (!strcasecmp(val, "Flipped"))
+	  {
+	    h->cupsInteger[1] =  1;
+	    h->cupsInteger[2] = -1;
+	  }
+	  else if (!strncasecmp(val, "Manual", 6))
+	  {
+	    h->cupsInteger[1] =  1;
+	    h->cupsInteger[2] =  1;
+	  }
+	  else if (!strcasecmp(val, "Normal"))
+	  {
+	    h->cupsInteger[1] =  1;
+	    h->cupsInteger[2] =  1;
+	  }
+	  else if (!strcasecmp(val, "Rotated"))
+	  {
+	    h->cupsInteger[1] = -1;
+	    h->cupsInteger[2] = -1;
+	  }
+	  else 
+	  {
+	    h->cupsInteger[1] =  1;
+	    h->cupsInteger[2] =  1;
+	  }
+	}
+	else
+	{
+	  if (!strcasecmp(val, "Flipped"))
+	  {
+	    h->cupsInteger[1] = -1;
+	    h->cupsInteger[2] =  1;
+	  }
+	  else if (!strncasecmp(val, "Manual", 6))
+	  {
+	    h->cupsInteger[1] = -1;
+	    h->cupsInteger[2] = -1;
+	  }
+	  else if (!strcasecmp(val, "Normal"))
+	  {
+	    h->cupsInteger[1] =  1;
+	    h->cupsInteger[2] =  1;
+	  }
+	  else if (!strcasecmp(val, "Rotated"))
+	  {
+	    h->cupsInteger[1] =  1;
+	    h->cupsInteger[2] =  1;
+	  }
+	  else 
+	  {
+	    h->cupsInteger[1] =  1;
+	    h->cupsInteger[2] =  1;
+	  }
+	}
+      }
+      else
+      {
+	h->cupsInteger[1] = 1;
+	h->cupsInteger[2] = 1;
+      }
+    }
+    else
+    {
+      h->cupsInteger[1] = 1;
+      h->cupsInteger[2] = 1;
+    }
+
+    /* TODO - Support for ImageBoxLeft, ImageBoxTop, ImageBoxRight, and
+       ImageBoxBottom (h->cupsInteger[3..6]), leave on 0 for now */
+
+    if ((val = cupsGetOption("alternate-primary", num_options,
+			     options)) != NULL ||
+	(val = cupsGetOption("AlternatePrimary", num_options,
+			     options)) != NULL)
+    {
+      int alternateprimary = atoi(val);		/* SRGB value for black
+						   pixels */
+      h->cupsInteger[7] = alternateprimary;
+    }
+
+    if ((val = cupsGetOption("print-quality", num_options, options)) != NULL ||
+	(val = cupsGetOption("PrintQuality", num_options, options)) != NULL ||
+	(val = cupsGetOption("Quality", num_options, options)) != NULL)
+    {
+      int quality = atoi(val);		/* print-quality value */
+
+      if (!quality ||
+	  (quality >= IPP_QUALITY_DRAFT && quality <= IPP_QUALITY_HIGH))
+	h->cupsInteger[8] = quality;
+      else
+	fprintf(stderr, "DEBUG: Unsupported print-quality %d.\n", quality);
+    }
+
+    /* Leave "reserved" fields (h->cupsInteger[9..13]) on 0 */
+
+    if ((val = cupsGetOption("vendor-identifier", num_options,
+			     options)) != NULL ||
+	(val = cupsGetOption("VendorIdentifier", num_options,
+			     options)) != NULL)
+    {
+      int vendorid = atoi(val);		/* USB ID of manufacturer */
+      h->cupsInteger[14] = vendorid;
+    }
+
+    if ((val = cupsGetOption("vendor-length", num_options,
+			     options)) != NULL ||
+	(val = cupsGetOption("VendorLength", num_options,
+			     options)) != NULL)
+    {
+      int vendorlength = atoi(val);		/* How many bytes of vendor
+						   data? */
+      if (vendorlength <= 1088)
+      {
+	h->cupsInteger[15] = vendorlength;
+	if ((val = cupsGetOption("vendor-data", num_options,
+				 options)) != NULL ||
+	    (val = cupsGetOption("VendorData", num_options,
+				 options)) != NULL)
+	  /* TODO - How to enter binary data here? */
+	  _strlcpy((char *)&(h->cupsReal[0]), val, 1088);
+      }
+    }
+  }
+
+  if (pwg_raster || set_defaults)
+  {
+    /* Set "reserved" fields to 0 */
+    memset(h->cupsMarkerType, 0, 64);
+  }
+
+  if ((val = cupsGetOption("print-rendering-intent", num_options,
+			   options)) != NULL ||
+      (val = cupsGetOption("PrintRenderingIntent", num_options,
+			   options)) != NULL ||
+      (val = cupsGetOption("RenderingIntent", num_options,
+			   options)) != NULL)
+  {
+    if (!strcmp(val, "absolute"))
+      _strlcpy(h->cupsRenderingIntent, "Absolute",
+	      sizeof(h->cupsRenderingIntent));
+    else if (!strcmp(val, "automatic"))
+      _strlcpy(h->cupsRenderingIntent, "Automatic",
+	      sizeof(h->cupsRenderingIntent));
+    else if (!strcmp(val, "perceptual"))
+      _strlcpy(h->cupsRenderingIntent, "Perceptual",
+	      sizeof(h->cupsRenderingIntent));
+    else if (!strcmp(val, "relative"))
+      _strlcpy(h->cupsRenderingIntent, "Relative",
+	      sizeof(h->cupsRenderingIntent));
+    else if (!strcmp(val, "relative-bpc"))
+      _strlcpy(h->cupsRenderingIntent, "RelativeBpc",
+	      sizeof(h->cupsRenderingIntent));
+    else if (!strcmp(val, "saturation"))
+      _strlcpy(h->cupsRenderingIntent, "Saturation",
+	      sizeof(h->cupsRenderingIntent));
+    else
+      fprintf(stderr, "DEBUG: Unsupported print-rendering-intent \"%s\".\n",
+	      val);
+  }
+  else if (set_defaults)
+    h->cupsRenderingIntent[0] = '\0';
+
+  return (0);
+}
+
+
+/*
+ * End
+ */
diff -up cups-filters-1.0.35/cupsfilters/raster.h.gs-filters cups-filters-1.0.35/cupsfilters/raster.h
--- cups-filters-1.0.35/cupsfilters/raster.h.gs-filters	2013-08-13 10:36:31.983178087 +0100
+++ cups-filters-1.0.35/cupsfilters/raster.h	2013-08-13 10:36:31.983178087 +0100
@@ -0,0 +1,55 @@
+/*
+ *   CUPS/PWG Raster utilities header file for CUPS.
+ *
+ *   Copyright 2013 by Till Kamppeter.
+ *
+ *   Distribution and use rights are outlined in the file "COPYING"
+ *   which should have been included with this file.
+ */
+
+#ifndef _CUPSFILTERS_RASTER_H_
+#  define _CUPSFILTERS_RASTER_H_
+
+#  ifdef __cplusplus
+extern "C" {
+#  endif /* __cplusplus */
+
+/*
+ * Include necessary headers...
+ */
+
+#  include <stdio.h>
+#  include <stdlib.h>
+#  include <time.h>
+#  include <math.h>
+
+#  if defined(WIN32) || defined(__EMX__)
+#    include <io.h>
+#  else
+#    include <unistd.h>
+#    include <fcntl.h>
+#  endif /* WIN32 || __EMX__ */
+
+#  include <cups/cups.h>
+#  include <cups/raster.h>
+
+/*
+ * Prototypes...
+ */
+
+extern int              cupsRasterParseIPPOptions(cups_page_header2_t *h,
+						  int num_options,
+						  cups_option_t *options,
+						  int pwg_raster,
+						  int set_defaults);
+
+#  ifdef __cplusplus
+}
+#  endif /* __cplusplus */
+
+#endif /* !_CUPSFILTERS_RASTER_H_ */
+
+/*
+ * End
+ */
+
diff -up cups-filters-1.0.35/filter/colord.c.gs-filters cups-filters-1.0.35/filter/colord.c
--- cups-filters-1.0.35/filter/colord.c.gs-filters	2013-08-13 10:36:31.984178091 +0100
+++ cups-filters-1.0.35/filter/colord.c	2013-08-13 10:36:31.984178091 +0100
@@ -0,0 +1,462 @@
+/*
+Copyright (c) 2011, Tim Waugh
+Copyright (c) 2011-2013, Richard Hughes
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+MIT Open Source License  -  http://www.opensource.org/
+
+*/
+
+
+/* Common routines for accessing the colord CMS framework */
+
+#include <cups/raster.h>
+#include <stdio.h>
+#include <sys/types.h>
+
+#ifdef HAVE_DBUS
+  #include <dbus/dbus.h>
+#endif
+
+#include "colord.h"
+
+#define QUAL_COLORSPACE   0
+#define QUAL_MEDIA        1
+#define QUAL_RESOLUTION   2
+#define QUAL_SIZE         3
+
+char **
+colord_get_qualifier_for_ppd (ppd_file_t *ppd)
+{
+  char q_keyword[PPD_MAX_NAME];
+  char **tuple = NULL;
+  const char *q1_choice;
+  const char *q2_choice;
+  const char *q3_choice;
+  ppd_attr_t *attr;
+  ppd_attr_t *q1_attr;
+  ppd_attr_t *q2_attr;
+  ppd_attr_t *q3_attr;
+
+  /* get colorspace */
+  if ((attr = ppdFindAttr (ppd, "cupsICCQualifier1", NULL)) != NULL &&
+      attr->value && attr->value[0])
+  {
+    snprintf (q_keyword, sizeof (q_keyword), "Default%s", attr->value);
+    q1_attr = ppdFindAttr (ppd, q_keyword, NULL);
+  }
+  else if ((q1_attr = ppdFindAttr (ppd, "DefaultColorModel", NULL)) == NULL)
+    q1_attr = ppdFindAttr (ppd, "DefaultColorSpace", NULL);
+
+  if (q1_attr && q1_attr->value && q1_attr->value[0])
+    q1_choice = q1_attr->value;
+  else
+    q1_choice = "";
+
+  /* get media */
+  if ((attr = ppdFindAttr(ppd, "cupsICCQualifier2", NULL)) != NULL &&
+      attr->value && attr->value[0])
+  {
+    snprintf(q_keyword, sizeof(q_keyword), "Default%s", attr->value);
+    q2_attr = ppdFindAttr(ppd, q_keyword, NULL);
+  }
+  else
+    q2_attr = ppdFindAttr(ppd, "DefaultMediaType", NULL);
+
+  if (q2_attr && q2_attr->value && q2_attr->value[0])
+    q2_choice = q2_attr->value;
+  else
+    q2_choice = "";
+
+  /* get resolution */
+  if ((attr = ppdFindAttr(ppd, "cupsICCQualifier3", NULL)) != NULL &&
+      attr->value && attr->value[0])
+  {
+    snprintf(q_keyword, sizeof(q_keyword), "Default%s", attr->value);
+    q3_attr = ppdFindAttr(ppd, q_keyword, NULL);
+  }
+  else
+    q3_attr = ppdFindAttr(ppd, "DefaultResolution", NULL);
+
+  if (q3_attr && q3_attr->value && q3_attr->value[0])
+    q3_choice = q3_attr->value;
+  else
+    q3_choice = "";
+
+  /* return a NULL terminated array so we don't have to break it up later */
+  tuple = calloc(QUAL_SIZE + 1, sizeof(char*));
+  tuple[QUAL_COLORSPACE] = strdup(q1_choice);
+  tuple[QUAL_MEDIA]      = strdup(q2_choice);
+  tuple[QUAL_RESOLUTION] = strdup(q3_choice);
+  return tuple;
+}
+
+#ifdef HAVE_DBUS
+
+static char *
+get_filename_for_profile_path (DBusConnection *con,
+                               const char *object_path)
+{
+  char *filename = NULL;
+  const char *interface = "org.freedesktop.ColorManager.Profile";
+  const char *property = "Filename";
+  const char *tmp;
+  DBusError error;
+  DBusMessageIter args;
+  DBusMessage *message = NULL;
+  DBusMessage *reply = NULL;
+  DBusMessageIter sub;
+
+  message = dbus_message_new_method_call("org.freedesktop.ColorManager",
+                 object_path,
+                 "org.freedesktop.DBus.Properties",
+                 "Get");
+
+  dbus_message_iter_init_append(message, &args);
+  dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &interface);
+  dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &property);
+
+  /* send syncronous */
+  dbus_error_init(&error);
+  fprintf(stderr, "DEBUG: Calling %s.Get(%s)\n", interface, property);
+  reply = dbus_connection_send_with_reply_and_block(con,
+                message,
+                -1,
+                &error);
+  if (reply == NULL) {
+    fprintf(stderr, "DEBUG: Failed to send: %s:%s\n",
+           error.name, error.message);
+    dbus_error_free(&error);
+    goto out;
+  }
+
+  /* get reply data */
+  dbus_message_iter_init(reply, &args);
+  if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_VARIANT) {
+    fprintf(stderr, "DEBUG: Incorrect reply type\n");
+    goto out;
+  }
+
+  dbus_message_iter_recurse(&args, &sub);
+  dbus_message_iter_get_basic(&sub, &tmp);
+  filename = strdup(tmp);
+out:
+  if (message != NULL)
+    dbus_message_unref(message);
+  if (reply != NULL)
+    dbus_message_unref(reply);
+  return filename;
+}
+
+static char *
+get_profile_for_device_path (DBusConnection *con,
+                             const char *object_path,
+                             const char **split)
+{
+  char **key = NULL;
+  char *profile = NULL;
+  char str[256];
+  const char *tmp;
+  DBusError error;
+  DBusMessageIter args;
+  DBusMessageIter entry;
+  DBusMessage *message = NULL;
+  DBusMessage *reply = NULL;
+  int i = 0;
+  const int max_keys = 7;
+
+  message = dbus_message_new_method_call("org.freedesktop.ColorManager",
+                                         object_path,
+                                         "org.freedesktop.ColorManager.Device",
+                                         "GetProfileForQualifiers");
+  dbus_message_iter_init_append(message, &args);
+
+  /* create the fallbacks */
+  key = calloc(max_keys + 1, sizeof(char*));
+
+  /* exact match */
+  i = 0;
+  snprintf(str, sizeof(str), "%s.%s.%s",
+           split[QUAL_COLORSPACE],
+           split[QUAL_MEDIA],
+           split[QUAL_RESOLUTION]);
+  key[i++] = strdup(str);
+  snprintf(str, sizeof(str), "%s.%s.*",
+           split[QUAL_COLORSPACE],
+           split[QUAL_MEDIA]);
+  key[i++] = strdup(str);
+  snprintf(str, sizeof(str), "%s.*.%s",
+           split[QUAL_COLORSPACE],
+           split[QUAL_RESOLUTION]);
+  key[i++] = strdup(str);
+  snprintf(str, sizeof(str), "%s.*.*",
+           split[QUAL_COLORSPACE]);
+  key[i++] = strdup(str);
+  key[i++] = strdup("*");
+  dbus_message_iter_open_container(&args,
+                                   DBUS_TYPE_ARRAY,
+                                   "s",
+                                   &entry);
+  for (i=0; key[i] != NULL; i++) {
+    dbus_message_iter_append_basic(&entry,
+                                   DBUS_TYPE_STRING,
+                                   &key[i]);
+  }
+  dbus_message_iter_close_container(&args, &entry);
+
+  /* send syncronous */
+  dbus_error_init(&error);
+  fprintf(stderr, "DEBUG: Calling GetProfileForQualifiers(%s...)\n", key[0]);
+  reply = dbus_connection_send_with_reply_and_block(con,
+                                                    message,
+                                                    -1,
+                                                    &error);
+  if (reply == NULL) {
+    fprintf(stderr, "DEBUG: Failed to send: %s:%s\n",
+           error.name, error.message);
+    dbus_error_free(&error);
+    goto out;
+  }
+
+  /* get reply data */
+  dbus_message_iter_init(reply, &args);
+  if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_OBJECT_PATH) {
+    fprintf(stderr, "DEBUG: Incorrect reply type\n");
+    goto out;
+  }
+  dbus_message_iter_get_basic(&args, &tmp);
+  fprintf(stderr, "DEBUG: Found profile %s\n", tmp);
+
+  /* get filename */
+  profile = get_filename_for_profile_path(con, tmp);
+
+out:
+  if (message != NULL)
+    dbus_message_unref(message);
+  if (reply != NULL)
+    dbus_message_unref(reply);
+  if (key != NULL) {
+    for (i=0; i < max_keys; i++)
+      free(key[i]);
+    free(key);
+  }
+  return profile;
+}
+
+static char *
+get_device_path_for_device_id (DBusConnection *con,
+                               const char *device_id)
+{
+  char *device_path = NULL;
+  const char *device_path_tmp;
+  DBusError error;
+  DBusMessageIter args;
+  DBusMessage *message = NULL;
+  DBusMessage *reply = NULL;
+
+  message = dbus_message_new_method_call("org.freedesktop.ColorManager",
+                                         "/org/freedesktop/ColorManager",
+                                         "org.freedesktop.ColorManager",
+                                         "FindDeviceById");
+  dbus_message_iter_init_append(message, &args);
+  dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &device_id);
+
+  /* send syncronous */
+  dbus_error_init(&error);
+  fprintf(stderr, "DEBUG: Calling FindDeviceById(%s)\n", device_id);
+  reply = dbus_connection_send_with_reply_and_block(con,
+                message,
+                -1,
+                &error);
+  if (reply == NULL) {
+    fprintf(stderr, "DEBUG: Failed to send: %s:%s\n",
+            error.name, error.message);
+    dbus_error_free(&error);
+    goto out;
+  }
+
+  /* get reply data */
+  dbus_message_iter_init(reply, &args);
+  if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_OBJECT_PATH) {
+    fprintf(stderr, "DEBUG: Incorrect reply type\n");
+    goto out;
+  }
+  dbus_message_iter_get_basic(&args, &device_path_tmp);
+  fprintf(stderr, "DEBUG: Found device %s\n", device_path_tmp);
+  device_path = strdup(device_path_tmp);
+out:
+  if (message != NULL)
+    dbus_message_unref(message);
+  if (reply != NULL)
+    dbus_message_unref(reply);
+  return device_path;
+}
+
+char *
+colord_get_profile_for_device_id (const char *device_id,
+				  const char **qualifier_tuple)
+{
+  DBusConnection *con = NULL;
+  char *device_path = NULL;
+  char *filename = NULL;
+
+  if (device_id == NULL) {
+    fprintf(stderr, "DEBUG: No colord device ID available\n");
+    goto out;
+  }
+
+  /* connect to system bus */
+  con = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
+  if (con == NULL) {
+    fprintf(stderr, "ERROR: Failed to connect to system bus\n");
+    goto out;
+  }
+
+  /* find the device */
+  device_path = get_device_path_for_device_id (con, device_id);
+  if (device_path == NULL) {
+    fprintf(stderr, "DEBUG: Failed to get find device %s\n", device_id);
+    goto out;
+  }
+
+  /* get the best profile for the device */
+  filename = get_profile_for_device_path(con, device_path, qualifier_tuple);
+  if (filename == NULL) {
+    fprintf(stderr, "DEBUG: Failed to get profile filename for %s\n", device_id);
+    goto out;
+  }
+  fprintf(stderr, "DEBUG: Use profile filename: '%s'\n", filename);
+out:
+  free(device_path);
+  if (con != NULL)
+    dbus_connection_unref(con);
+  return filename;
+}
+
+int
+get_profile_inhibitors (DBusConnection *con, const char *object_path)
+{
+  char *tmp;
+  const char *interface = "org.freedesktop.ColorManager.Device";
+  const char *property = "ProfilingInhibitors";
+  DBusError error;
+  DBusMessageIter args;
+  DBusMessageIter sub;
+  DBusMessageIter sub2;
+  DBusMessage *message = NULL;
+  DBusMessage *reply = NULL;
+  int inhibitors = 0;
+
+  message = dbus_message_new_method_call("org.freedesktop.ColorManager",
+                                         object_path,
+                                         "org.freedesktop.DBus.Properties",
+                                         "Get");
+
+  dbus_message_iter_init_append(message, &args);
+  dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &interface);
+  dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &property);
+
+  /* send syncronous */
+  dbus_error_init(&error);
+  fprintf(stderr, "DEBUG: Calling %s.Get(%s)\n", interface, property);
+  reply = dbus_connection_send_with_reply_and_block(con,
+                                                    message,
+                                                    -1,
+                                                    &error);
+  if (reply == NULL) {
+    fprintf(stderr, "DEBUG: Failed to send: %s:%s\n",
+           error.name, error.message);
+    dbus_error_free(&error);
+    goto out;
+  }
+
+  /* get reply data */
+  dbus_message_iter_init(reply, &args);
+  if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_VARIANT) {
+    fprintf(stderr, "DEBUG: Incorrect reply type\n");
+    goto out;
+  }
+
+  /* count the size of the array */
+  dbus_message_iter_recurse(&args, &sub2);
+  dbus_message_iter_recurse(&sub2, &sub);
+  while (dbus_message_iter_get_arg_type(&sub) != DBUS_TYPE_INVALID) {
+    dbus_message_iter_get_basic(&sub, &tmp);
+    fprintf(stderr, "DEBUG: Inhibitor %s exists\n", tmp);
+    dbus_message_iter_next(&sub);
+    inhibitors++;
+  }
+out:
+  if (message != NULL)
+    dbus_message_unref(message);
+  if (reply != NULL)
+    dbus_message_unref(reply);
+  return inhibitors;
+}
+
+int
+colord_get_inhibit_for_device_id (const char *device_id)
+{
+  DBusConnection *con;
+  char *device_path = NULL;
+  int has_inhibitors = FALSE;
+
+  /* connect to system bus */
+  con = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
+  if (con == NULL) {
+    fprintf(stderr, "ERROR: Failed to connect to system bus\n");
+    goto out;
+  }
+
+  /* find the device */
+  device_path = get_device_path_for_device_id (con, device_id);
+  if (device_path == NULL) {
+    fprintf(stderr, "DEBUG: Failed to get find device %s\n", device_id);
+    goto out;
+  }
+
+  /* get the best profile for the device */
+  has_inhibitors = get_profile_inhibitors(con, device_path);
+out:
+  free(device_path);
+  if (con != NULL)
+    dbus_connection_unref(con);
+  return has_inhibitors;
+}
+
+#else
+
+char *
+colord_get_profile_for_device_id (const char *device_id,
+                                  const char **qualifier_tuple)
+{
+  fprintf(stderr, "WARN: not compiled with DBus support\n");
+  return NULL;
+}
+
+int
+colord_get_inhibit_for_device_id (const char *device_id)
+{
+  fprintf(stderr, "WARN: not compiled with DBus support\n");
+  return 0;
+}
+
+#endif
diff -up cups-filters-1.0.35/filter/colord.h.gs-filters cups-filters-1.0.35/filter/colord.h
--- cups-filters-1.0.35/filter/colord.h.gs-filters	2013-08-13 10:36:31.984178091 +0100
+++ cups-filters-1.0.35/filter/colord.h	2013-08-13 10:36:31.984178091 +0100
@@ -0,0 +1,35 @@
+/*
+Copyright (c) 2011-2013, Richard Hughes
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+MIT Open Source License  -  http://www.opensource.org/
+
+*/
+
+
+/* Common routines for accessing the colord CMS framework */
+
+#include <cups/raster.h>
+
+char  **colord_get_qualifier_for_ppd      (ppd_file_t *ppd);
+char   *colord_get_profile_for_device_id  (const char *device_id,
+                                           const char **qualifier_tuple);
+int     colord_get_inhibit_for_device_id  (const char *device_id);
diff -up cups-filters-1.0.35/filter/gstopxl.in.gs-filters cups-filters-1.0.35/filter/gstopxl.in
--- cups-filters-1.0.35/filter/gstopxl.in.gs-filters	2013-08-13 10:36:31.985178096 +0100
+++ cups-filters-1.0.35/filter/gstopxl.in	2013-08-13 10:36:31.985178096 +0100
@@ -0,0 +1,184 @@
+#!/bin/sh
+#
+#
+# CUPS PCL XL/PCL 6 filter script for Ghostscript.
+#
+# Copyright 2001-2005 by Easy Software Products.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+
+# Set the library/font path...
+GS_LIB="${CUPS_FONTPATH:=/usr/share/cups/fonts}"
+export GS_LIB
+
+# Determine the PCL XL/PCL 6 driver to use...
+if test "x$PPD" != x; then
+    colordevice=`grep '^*ColorDevice:' "$PPD" | awk -F: '{print $2}'`
+    case "$colordevice" in
+	*True* | *true*)
+	    device="pxlcolor"
+	    ;;
+	*)
+	    device="pxlmono"
+	    ;;
+    esac
+else
+    device="pxlmono"
+fi
+
+# Apply PPD settings.
+
+ps_code=
+ppd_opts=
+
+resolution=
+eval "$(printf "%s" "$5" | sed @SED_EXTENDED_REGEX_OPT@ 's/.*(^|[[:space:]])Resolution=([0-9.]+(x[0-9.]+)?).*/resolution="${resolution:-\2}"/p')"
+if test -e "$PPD"; then
+  eval "$(sed @SED_EXTENDED_REGEX_OPT@ 's/^\*DefaultResolution:[[:space:]]+([0-9.]+(x[0-9.]+)?).*/resolution="${resolution:-\1}"/p' "$PPD")"
+fi
+echo "DEBUG: Resolution: $resolution" >&2
+if test -n "$resolution"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-r$resolution"
+fi
+
+pagesize=
+eval "$(printf "%s" "$5" | sed @SED_EXTENDED_REGEX_OPT@ 's/.*(^|[[:space:]])(media|PageSize)=([^[:space:]]+).*/pagesize="${pagesize:-\3}"/p')"
+if test -e "$PPD"; then
+  eval "$(sed @SED_EXTENDED_REGEX_OPT@ 's/^\*DefaultPageSize:[[:space:]]+([^[:space:]]+).*/pagesize="${pagesize:-\1}"/p' "$PPD")"
+fi
+echo "DEBUG: Page size: $pagesize" >&2
+width=
+height=
+if test -n "$pagesize" && test -e "$PPD"; then
+  eval "$(sed @SED_EXTENDED_REGEX_OPT@ 's|^\*PaperDimension[[:space:]]+'"$pagesize"'/[^:]+:[[:space:]]+"([^[:space:]]+)[[:space:]]+([^[:space:]]+)".*|width="\1"; height="\2"|p' "$PPD")"
+fi
+echo "DEBUG: Width: $width, height: $height" >&2
+if test -n "$width"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-dDEVICEWIDTHPOINTS=$width"
+fi
+if test -n "$height"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-dDEVICEHEIGHTPOINTS=$height"
+fi
+
+bl_x=
+bl_y=
+tr_x=
+tr_y=
+if test -n "$pagesize" && test -e "$PPD"; then
+  eval "$(sed @SED_EXTENDED_REGEX_OPT@ 's|^\*ImageableArea[[:space:]]+'"$pagesize"'/[^:]+:[[:space:]]+"([^[:space:]]+)[[:space:]]+([^[:space:]]+)[[:space:]]+([^[:space:]]+)[[:space:]]+([^[:space:]]+)".*|bl_x="\1"; bl_y="\2"; tr_x="\3"; tr_y="\4"|p' "$PPD")"
+fi
+echo "DEBUG: Absolute margins: $bl_x, $bl_y, $tr_x, $tr_y" >&2
+margin_l=
+margin_b=
+margin_r=
+margin_t=
+if test -n "$width" && test -n "$height" && \
+   test -n "$bl_x" && test -n "$bl_y" && \
+   test -n "$tr_x" && test -n "$tr_y"; then
+  margin_l="$bl_x"
+  margin_b="$bl_y"
+  margin_r="$(printf "scale=8; (%s)-(%s)\n" "$width" "$tr_x" | bc)"
+  margin_t="$(printf "scale=8; (%s)-(%s)\n" "$height" "$tr_y" | bc)"
+fi
+echo "DEBUG: Relative margins: $margin_l, $margin_b, $margin_r, $margin_t" >&2
+if test -n "$margin_l" && test -n "$margin_b" && \
+   test -n "$margin_r" && test -n "$margin_t"; then
+  ps_code="${ps_code:+$ps_code }<</.HWMargins[$margin_l $margin_b $margin_r $margin_t] /Margins[0 0]>>setpagedevice"
+fi
+
+inputslot=
+eval "$(printf "%s" "$5" | sed @SED_EXTENDED_REGEX_OPT@ 's/.*(^|[[:space:]])(InputSlot)=([^[:space:]]+).*/inputslot="${inputslot:-\3}"/p')"
+if test -e "$PPD"; then
+  eval "$(sed @SED_EXTENDED_REGEX_OPT@ 's/^\*DefaultInputSlot:[[:space:]]+([^[:space:]]+).*/inputslot="${inputslot:-\1}"/p' "$PPD")"
+fi
+echo "DEBUG: InputSlot: $inputslot" >&2
+inputslot_val=
+if test -n "$inputslot" && test -e "$PPD"; then
+  eval "$(sed @SED_EXTENDED_REGEX_OPT@ 's|^\*InputSlot[[:space:]]+'"$inputslot"'/[^:]+:[[:space:]]+"[[:space:]]*<[[:space:]]*<[[:space:]]*/MediaPosition[[:space:]]*([0-9]+)[[:space:]]*>[[:space:]]*>[[:space:]]*setpagedevice[[:space:]]*".*|inputslot_val="\1"|p' "$PPD")"
+fi
+echo "DEBUG: Value for MediaPosition: $inputslot_val" >&2
+if test -n "$inputslot_val"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-dMediaPosition=$inputslot_val"
+fi
+
+colormodel=
+eval "$(printf "%s" "$5" | sed @SED_EXTENDED_REGEX_OPT@ 's/.*(^|[[:space:]])(ColorModel)=([^[:space:]]+).*/colormodel="${colormodel:-\3}"/p')"
+if test -e "$PPD"; then
+  eval "$(sed @SED_EXTENDED_REGEX_OPT@ 's/^\*DefaultColorModel:[[:space:]]+([^[:space:]]+).*/colormodel="${colormodel:-\1}"/p' "$PPD")"
+fi
+echo "DEBUG: ColorModel: $colormodel" >&2
+if test "$colormodel" = "Gray"; then
+    device=pxlmono
+fi
+colormodel_val=
+if test -n "$colormodel" && test -e "$PPD"; then
+  eval "$(sed @SED_EXTENDED_REGEX_OPT@ 's|^\*ColorModel[[:space:]]+'"$colormodel"'/[^:]+:[[:space:]]+"[[:space:]]*<[[:space:]]*<[[:space:]]*/BitsPerPixel[[:space:]]*([0-9]*)[[:space:]]*>[[:space:]]*>[[:space:]]*setpagedevice[[:space:]]*".*|colormodel_val="\1"|p' "$PPD")"
+fi
+echo "DEBUG: Value for BitsPerPixel: $colormodel_val" >&2
+if test -n "$colormodel_val"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-dBitsPerPixel=$colormodel_val"
+fi
+
+duplex=
+eval "$(printf "%s" "$5" | sed @SED_EXTENDED_REGEX_OPT@ 's/.*(^|[[:space:]])(Duplex)=([^[:space:]]+).*/duplex="${duplex:-\3}"/p')"
+if test -e "$PPD"; then
+  eval "$(sed @SED_EXTENDED_REGEX_OPT@ 's/^\*DefaultDuplex:[[:space:]]+([^[:space:]]+).*/duplex="${duplex:-\1}"/p' "$PPD")"
+fi
+echo "DEBUG: Duplex: $duplex" >&2
+duplex_val=
+tumble_val=
+if test -n "$duplex" && test -e "$PPD"; then
+  eval "$(sed @SED_EXTENDED_REGEX_OPT@ 's|^\*Duplex[[:space:]]+'"$duplex"'/[^:]+:[[:space:]]+"[[:space:]]*<[[:space:]]*<[[:space:]]*/Duplex[[:space:]]*([^[:space:]]*)[[:space:]]*(/Tumble[[:space:]]*([^[:space:]]*)[[:space:]]*)?>[[:space:]]*>[[:space:]]*setpagedevice[[:space:]]*".*|duplex_val="\1"; tumble_val="\3"|p' "$PPD")"
+fi
+echo "DEBUG: Value for Duplex: $duplex_val; Value for Tumble: $tumble_val" >&2
+if test -n "$duplex_val"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-dDuplex=$duplex_val"
+fi
+if test -n "$tumble_val"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-dTumble=$tumble_val"
+fi
+
+
+echo "DEBUG: PPD options: $ppd_opts" >&2
+echo "DEBUG: PostScript code from options: $ps_code" >&2
+
+# Options we use with Ghostscript...
+gsopts="-dQUIET -dPARANOIDSAFER -dNOPAUSE -dBATCH -dNOINTERPOLATE"
+gsopts="$gsopts -sDEVICE=$device -sstdout=%stderr"
+
+# See if we have a filename on the command-line...
+if [ -n "$6" ]; then
+  exec <"$6"
+fi
+
+# We read the data into a temporary file as Ghostscript needs this to be
+# able to also work with PDF input
+tempfiles=
+trap 'rm -f $tempfiles' 0 1 2 13 15
+
+ifile=$(mktemp -t gstopxl.XXXXXX)
+tempfiles="$tempfiles $ifile"
+
+cat >"$ifile"
+
+echo INFO: Starting GPL Ghostscript `@CUPS_GHOSTSCRIPT@ --version`... 1>&2
+echo DEBUG: Running @CUPS_GHOSTSCRIPT@ $gsopts $ppd_opts -sOUTPUTFILE="%stdout" -c "$ps_code" -f "$ifile" 1>&2
+
+# Now run Ghostscript...
+@CUPS_GHOSTSCRIPT@ $gsopts $ppd_opts -sOUTPUTFILE="%stdout" -c "$ps_code" -f "$ifile"
+
+#
+#
diff -up cups-filters-1.0.35/filter/gstoraster.c.gs-filters cups-filters-1.0.35/filter/gstoraster.c
--- cups-filters-1.0.35/filter/gstoraster.c.gs-filters	2013-08-13 10:36:31.986178101 +0100
+++ cups-filters-1.0.35/filter/gstoraster.c	2013-08-13 10:36:31.986178101 +0100
@@ -0,0 +1,745 @@
+/*
+
+Copyright (c) 2008-2013, Till Kamppeter
+Copyright (c) 2011, Tim Waugh
+Copyright (c) 2011-2013, Richard Hughes
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+MIT Open Source License  -  http://www.opensource.org/
+
+*/
+
+
+/* PS/PDF to CUPS Raster filter based on Ghostscript */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <cups/cups.h>
+#include <stdarg.h>
+#include <fcntl.h>
+#include <cups/raster.h>
+#include <cupsfilters/raster.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <signal.h>
+#include <errno.h>
+
+#include "colord.h"
+
+#define PDF_MAX_CHECK_COMMENT_LINES	20
+
+#ifndef GS
+#define GS "gs"
+#endif
+#ifndef BINDIR
+#define BINDIR "/usr/bin"
+#endif
+#ifndef CUPS_FONTPATH
+#define CUPS_FONTPATH "/usr/share/cups/fonts"
+#endif
+#ifndef CUPSDATA
+#define CUPSDATA "/usr/share/cups"
+#endif
+
+typedef enum {
+  GS_DOC_TYPE_PDF,
+  GS_DOC_TYPE_PS,
+  GS_DOC_TYPE_UNKNOWN
+} GsDocType;
+
+#ifdef CUPS_RASTER_SYNCv1
+typedef cups_page_header2_t gs_page_header;
+#else
+typedef cups_page_header_t gs_page_header;
+#endif /* CUPS_RASTER_SYNCv1 */
+
+static GsDocType
+parse_doc_type(FILE *fp)
+{
+  char buf[5];
+  GsDocType doc_type;
+  char *rc;
+
+  /* get the first few bytes of the file */
+  doc_type = GS_DOC_TYPE_UNKNOWN;
+  rewind(fp);
+  rc = fgets(buf,sizeof(buf),fp);
+  if (rc == NULL)
+    goto out;
+
+  /* is PDF */
+  if (strncmp(buf,"%PDF",4) == 0) {
+    doc_type = GS_DOC_TYPE_PDF;
+    goto out;
+  }
+
+  /* is PS */
+  if (strncmp(buf,"%!",2) == 0) {
+    doc_type = GS_DOC_TYPE_PS;
+    goto out;
+  }
+out:
+  return doc_type;
+}
+
+static void
+parse_pdf_header_options(FILE *fp, gs_page_header *h)
+{
+  char buf[4096];
+  int i;
+
+  rewind(fp);
+  /* skip until PDF start header */
+  while (fgets(buf,sizeof(buf),fp) != 0) {
+    if (strncmp(buf,"%PDF",4) == 0) {
+      break;
+    }
+  }
+  for (i = 0;i < PDF_MAX_CHECK_COMMENT_LINES;i++) {
+    if (fgets(buf,sizeof(buf),fp) == 0) break;
+    if (strncmp(buf,"%%PDFTOPDFNumCopies",19) == 0) {
+      char *p;
+
+      p = strchr(buf+19,':');
+      h->NumCopies = atoi(p+1);
+    } else if (strncmp(buf,"%%PDFTOPDFCollate",17) == 0) {
+      char *p;
+
+      p = strchr(buf+17,':');
+      while (*p == ' ' || *p == '\t') p++;
+      if (strncasecmp(p,"true",4) == 0) {
+        h->Collate = CUPS_TRUE;
+      } else {
+        h->Collate = CUPS_FALSE;
+      }
+    }
+  }
+}
+
+static void
+add_pdf_header_options(gs_page_header *h, cups_array_t *gs_args)
+{
+  int i;
+  char tmpstr[1024];
+
+  /* Simple boolean, enumerated choice, numerical, and string parameters */
+  if (h->MediaClass[0] |= '\0') {
+    snprintf(tmpstr, sizeof(tmpstr), "-sMediaClass=%s", h->MediaClass);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->MediaColor[0] |= '\0') {
+    snprintf(tmpstr, sizeof(tmpstr), "-sMediaColor=%s", h->MediaColor);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->MediaType[0] |= '\0') {
+    snprintf(tmpstr, sizeof(tmpstr), "-sMediaType=%s", h->MediaType);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->OutputType[0] |= '\0') {
+    snprintf(tmpstr, sizeof(tmpstr), "-sOutputType=%s", h->OutputType);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->AdvanceDistance) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dAdvanceDistance=%d",
+	     (unsigned)(h->AdvanceDistance));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->AdvanceMedia) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dAdvanceMedia=%d",
+	     (unsigned)(h->AdvanceMedia));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->Collate) {
+    cupsArrayAdd(gs_args, strdup("-dCollate"));
+  }
+  if (h->CutMedia) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dCutMedia=%d",
+	     (unsigned)(h->CutMedia));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->Duplex) {
+    cupsArrayAdd(gs_args, strdup("-dDuplex"));
+  }
+  if ((h->HWResolution[0] != 100) || (h->HWResolution[1] != 100))
+    snprintf(tmpstr, sizeof(tmpstr), "-r%dx%d",
+	     (unsigned)(h->HWResolution[0]), (unsigned)(h->HWResolution[1]));
+  else
+    snprintf(tmpstr, sizeof(tmpstr), "-r100x100");
+  cupsArrayAdd(gs_args, strdup(tmpstr));
+  if (h->InsertSheet) {
+    cupsArrayAdd(gs_args, strdup("-dInsertSheet"));
+  }
+  if (h->Jog) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dJog=%d",
+	     (unsigned)(h->Jog));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->LeadingEdge) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dLeadingEdge=%d",
+	     (unsigned)(h->LeadingEdge));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->ManualFeed) {
+    cupsArrayAdd(gs_args, strdup("-dManualFeed"));
+  }
+  if (h->MediaPosition) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dMediaPosition=%d",
+	     (unsigned)(h->MediaPosition));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->MediaWeight) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dMediaWeight=%d",
+	     (unsigned)(h->MediaWeight));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->MirrorPrint) {
+    cupsArrayAdd(gs_args, strdup("-dMirrorPrint"));
+  }
+  if (h->NegativePrint) {
+    cupsArrayAdd(gs_args, strdup("-dNegativePrint"));
+  }
+  if (h->NumCopies != 1) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dNumCopies=%d",
+	     (unsigned)(h->NumCopies));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->Orientation) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dOrientation=%d",
+	     (unsigned)(h->Orientation));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->OutputFaceUp) {
+    cupsArrayAdd(gs_args, strdup("-dOutputFaceUp"));
+  }
+  if (h->PageSize[0] != 612)
+    snprintf(tmpstr, sizeof(tmpstr), "-dDEVICEWIDTHPOINTS=%d",
+	     (unsigned)(h->PageSize[0]));
+  else
+    snprintf(tmpstr, sizeof(tmpstr), "-dDEVICEWIDTHPOINTS=612");
+  cupsArrayAdd(gs_args, strdup(tmpstr));
+  if (h->PageSize[1] != 792)
+    snprintf(tmpstr, sizeof(tmpstr), "-dDEVICEHEIGHTPOINTS=%d",
+	     (unsigned)(h->PageSize[1]));
+  else
+    snprintf(tmpstr, sizeof(tmpstr), "-dDEVICEHEIGHTPOINTS=792");
+  cupsArrayAdd(gs_args, strdup(tmpstr));
+  if (h->Separations) {
+    cupsArrayAdd(gs_args, strdup("-dSeparations"));
+  }
+  if (h->TraySwitch) {
+    cupsArrayAdd(gs_args, strdup("-dTraySwitch"));
+  }
+  if (h->Tumble) {
+    cupsArrayAdd(gs_args, strdup("-dTumble"));
+  }
+  if (h->cupsMediaType) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsMediaType=%d",
+	     (unsigned)(h->cupsMediaType));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->cupsBitsPerColor != 1)
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsBitsPerColor=%d",
+	     (unsigned)(h->cupsBitsPerColor));
+  else
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsBitsPerColor=1");
+  cupsArrayAdd(gs_args, strdup(tmpstr));
+  if (h->cupsColorOrder != CUPS_ORDER_CHUNKED)
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsColorOrder=%d",
+	     (unsigned)(h->cupsColorOrder));
+  else
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsColorOrder=%d",
+	     CUPS_ORDER_CHUNKED);
+  cupsArrayAdd(gs_args, strdup(tmpstr));
+  if (h->cupsColorSpace != CUPS_CSPACE_K)
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsColorSpace=%d",
+	     (unsigned)(h->cupsColorSpace));
+  else
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsColorSpace=%d",
+	     CUPS_CSPACE_K);
+  cupsArrayAdd(gs_args, strdup(tmpstr));
+  if (h->cupsCompression) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsCompression=%d",
+	     (unsigned)(h->cupsCompression));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->cupsRowCount) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsRowCount=%d",
+	     (unsigned)(h->cupsRowCount));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->cupsRowFeed) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsRowFeed=%d",
+	     (unsigned)(h->cupsRowFeed));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->cupsRowStep) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsRowStep=%d",
+	     (unsigned)(h->cupsRowStep));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+#ifdef CUPS_RASTER_SYNCv1
+  if (h->cupsBorderlessScalingFactor != 1.0f) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsBorderlessScalingFactor=%.4f",
+	     h->cupsBorderlessScalingFactor);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  for (i=0; i <= 15; i ++)
+    if (h->cupsInteger[i]) {
+      snprintf(tmpstr, sizeof(tmpstr), "-dcupsInteger%d=%d",
+	       i, (unsigned)(h->cupsInteger[i]));
+      cupsArrayAdd(gs_args, strdup(tmpstr));
+    }
+  for (i=0; i <= 15; i ++)
+    if (h->cupsReal[i]) {
+      snprintf(tmpstr, sizeof(tmpstr), "-dcupsReal%d=%.4f",
+	       i, h->cupsReal[i]);
+      cupsArrayAdd(gs_args, strdup(tmpstr));
+    }
+  for (i=0; i <= 15; i ++)
+    if (h->cupsString[i][0] != '\0') {
+      snprintf(tmpstr, sizeof(tmpstr), "-scupsString%d=%s",
+	       i, h->cupsString[i]);
+      cupsArrayAdd(gs_args, strdup(tmpstr));
+    }
+  if (h->cupsMarkerType[0] != '\0') {
+    snprintf(tmpstr, sizeof(tmpstr), "-scupsMarkerType=%s",
+	     h->cupsMarkerType);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->cupsRenderingIntent[0] != '\0') {
+    snprintf(tmpstr, sizeof(tmpstr), "-scupsRenderingIntent=%s",
+	     h->cupsRenderingIntent);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->cupsPageSizeName[0] != '\0') {
+    snprintf(tmpstr, sizeof(tmpstr), "-scupsPageSizeName=%s",
+	     h->cupsPageSizeName);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+#endif /* CUPS_RASTER_SYNCv1 */
+}
+
+static int
+gs_spawn (const char *filename,
+          cups_array_t *gs_args,
+          char **envp,
+          FILE *fp)
+{
+  char *argument;
+  char buf[BUFSIZ];
+  char **gsargv;
+  const char* apos;
+  int fds[2];
+  int i;
+  int n;
+  int numargs;
+  int pid;
+  int status = 1;
+
+  /* Put Ghostscript command line argument into an array for the "exec()"
+     call */
+  numargs = cupsArrayCount(gs_args);
+  gsargv = calloc(numargs + 1, sizeof(char *));
+  for (argument = (char *)cupsArrayFirst(gs_args), i = 0; argument;
+       argument = (char *)cupsArrayNext(gs_args), i++) {
+    gsargv[i] = argument;
+  }
+  gsargv[i] = NULL;
+
+  /* Debug output: Full Ghostscript command line and environment variables */
+  fprintf(stderr, "DEBUG: Ghostscript command line:");
+  for (i = 0; gsargv[i]; i ++) {
+    if ((strchr(gsargv[i],' ')) || (strchr(gsargv[i],'\t')))
+      apos = "'";
+    else
+      apos = "";
+    fprintf(stderr, " %s%s%s", apos, gsargv[i], apos);
+  }
+  fprintf(stderr, "\n");
+
+  for (i = 0; envp[i]; i ++)
+    fprintf(stderr, "DEBUG: envp[%d]=\"%s\"\n", i, envp[i]);
+
+  /* Create a pipe for feeding the job into Ghostscript */
+  if (pipe(fds))
+  {
+    fds[0] = -1;
+    fds[1] = -1;
+    fprintf(stderr, "ERROR: Unable to establish pipe for Ghostscript call\n");
+    goto out;
+  }
+
+  /* Set the "close on exec" flag on each end of the pipe... */
+  if (fcntl(fds[0], F_SETFD, fcntl(fds[0], F_GETFD) | FD_CLOEXEC))
+  {
+    close(fds[0]);
+    close(fds[1]);
+    fds[0] = -1;
+    fds[1] = -1;
+    fprintf(stderr, "ERROR: Unable to set \"close on exec\" flag on read end of the pipe for Ghostscript call\n");
+    goto out;
+  }
+  if (fcntl(fds[1], F_SETFD, fcntl(fds[1], F_GETFD) | FD_CLOEXEC))
+  {
+    close(fds[0]);
+    close(fds[1]);
+    fprintf(stderr, "ERROR: Unable to set \"close on exec\" flag on write end of the pipe for Ghostscript call\n");
+    goto out;
+  }
+
+  if ((pid = fork()) == 0)
+  {
+    /* Couple pipe with STDIN of Ghostscript process */
+    if (fds[0] != 0) {
+      close(0);
+      if (fds[0] > 0) {
+        if (dup(fds[0]) < 0) {
+	  fprintf(stderr, "ERROR: Unable to couple pipe with STDIN of Ghostscript process\n");
+	  goto out;
+	}
+      } else {
+        fprintf(stderr, "ERROR: Unable to couple pipe with STDIN of Ghostscript process\n");
+        goto out;
+      }
+    }
+
+    /* Execute Ghostscript command line ... */
+    execve(filename, gsargv, envp);
+    perror(filename);
+    goto out;
+  }
+
+  /* Feed job data into Ghostscript */
+  while ((n = fread(buf, 1, BUFSIZ, fp)) > 0) {
+    int count = write(fds[1], buf, n);
+    if (count != n) {
+      if (count == -1)
+        fprintf(stderr, "ERROR: write failed: %s\n", strerror(errno));
+      fprintf(stderr, "ERROR: Can't feed job data into Ghostscript\n");
+      goto out;
+    }
+  }
+  close (fds[1]);
+
+  if (waitpid (pid, &status, 0) == -1) {
+    perror ("gs");
+    goto out;
+  }
+out:
+  free(gsargv);
+  return status;
+}
+
+static char *
+get_ppd_icc_fallback (ppd_file_t *ppd, char **qualifier)
+{
+  char full_path[1024];
+  char *icc_profile = NULL;
+  char qualifer_tmp[1024];
+  const char *profile_key;
+  ppd_attr_t *attr;
+
+  /* get profile attr, falling back to CUPS */
+  profile_key = "APTiogaProfile";
+  attr = ppdFindAttr(ppd, profile_key, NULL);
+  if (attr == NULL) {
+    profile_key = "cupsICCProfile";
+    attr = ppdFindAttr(ppd, profile_key, NULL);
+  }
+
+  /* create a string for a quick comparion */
+  snprintf(qualifer_tmp, sizeof(qualifer_tmp),
+           "%s.%s.%s",
+           qualifier[0],
+           qualifier[1],
+           qualifier[2]);
+
+  /* neither */
+  if (attr == NULL) {
+    fprintf(stderr, "INFO: no profiles specified in PPD\n");
+    goto out;
+  }
+
+  /* try to find a profile that matches the qualifier exactly */
+  for (;attr != NULL; attr = ppdFindNextAttr(ppd, profile_key, NULL)) {
+    fprintf(stderr, "INFO: found profile %s in PPD with qualifier '%s'\n",
+            attr->value, attr->spec);
+
+    /* invalid entry */
+    if (attr->spec == NULL || attr->value == NULL)
+      continue;
+
+    /* expand to a full path if not already specified */
+    if (attr->value[0] != '/')
+      snprintf(full_path, sizeof(full_path),
+               "%s/profiles/%s", CUPSDATA, attr->value);
+    else
+      strncpy(full_path, attr->value, sizeof(full_path));
+
+    /* check the file exists */
+    if (access(full_path, 0)) {
+      fprintf(stderr, "INFO: found profile %s in PPD that does not exist\n",
+              full_path);
+      continue;
+    }
+
+    /* matches the qualifier */
+    if (strcmp(qualifer_tmp, attr->spec) == 0) {
+      icc_profile = strdup(full_path);
+      goto out;
+    }
+  }
+
+  /* no match */
+  if (attr == NULL) {
+    fprintf(stderr, "INFO: no profiles in PPD for qualifier '%s'\n",
+            qualifer_tmp);
+    goto out;
+  }
+
+out:
+  return icc_profile;
+}
+
+static void
+child_reaper (int signum)
+{
+  wait(NULL);
+}
+
+int
+main (int argc, char **argv, char *envp[])
+{
+  char buf[BUFSIZ];
+  char *icc_profile = NULL;
+  char **qualifier = NULL;
+  char *tmp;
+  char tmpstr[1024];
+  const char *t = NULL;
+  cups_array_t *gs_args = NULL;
+  cups_option_t *options = NULL;
+  FILE *fp = NULL;
+  GsDocType doc_type;
+  gs_page_header h;
+  int fd;
+  int device_inhibited;
+  int i;
+  int n;
+  int num_options;
+  int status = 1;
+  ppd_file_t *ppd = NULL;
+  struct sigaction sa;
+
+  if (argc < 6 || argc > 7) {
+    fprintf(stderr, "ERROR: %s job-id user title copies options [file]\n",
+      argv[0]);
+    goto out;
+  }
+
+  memset(&sa, 0, sizeof(sa));
+  /* Ignore SIGPIPE and have write return an error instead */
+  sa.sa_handler = SIG_IGN;
+  sigaction(SIGPIPE, &sa, NULL);
+
+  sa.sa_handler = child_reaper;
+  sigaction(SIGCHLD, &sa, NULL);
+
+  num_options = cupsParseOptions(argv[5], 0, &options);
+
+  t = getenv("PPD");
+  if (t && t[0] != '\0')
+    if ((ppd = ppdOpenFile(t)) == NULL) {
+      fprintf(stderr, "ERROR: Failed to open PPD: %s\n", t);
+    }
+      
+  if (ppd) {
+    ppdMarkDefaults (ppd);
+    cupsMarkOptions (ppd, num_options, options);
+  }
+
+  if (argc == 6) {
+    /* stdin */
+
+    fd = cupsTempFd(buf,BUFSIZ);
+    if (fd < 0) {
+      fprintf(stderr, "ERROR: Can't create temporary file\n");
+      goto out;
+    }
+    /* remove name */
+    unlink(buf);
+
+    /* copy stdin to the tmp file */
+    while ((n = read(0,buf,BUFSIZ)) > 0) {
+      if (write(fd,buf,n) != n) {
+        fprintf(stderr, "ERROR: Can't copy stdin to temporary file\n");
+        close(fd);
+        goto out;
+      }
+    }
+    if (lseek(fd,0,SEEK_SET) < 0) {
+        fprintf(stderr, "ERROR: Can't rewind temporary file\n");
+        close(fd);
+        goto out;
+    }
+
+    if ((fp = fdopen(fd,"rb")) == 0) {
+        fprintf(stderr, "ERROR: Can't fdopen temporary file\n");
+        close(fd);
+        goto out;
+    }
+  } else {
+    /* argc == 7 filename is specified */
+
+    if ((fp = fopen(argv[6],"rb")) == 0) {
+        fprintf(stderr, "ERROR: Can't open input file %s\n",argv[6]);
+        goto out;
+    }
+  }
+
+  /* find out file type */
+  doc_type = parse_doc_type(fp);
+  if (doc_type == GS_DOC_TYPE_UNKNOWN) {
+    fprintf(stderr, "ERROR: Can't detect file type\n");
+    goto out;
+  }
+
+  /* support colord and the "color-management=off" option */
+  snprintf (tmpstr, sizeof(tmpstr), "cups-%s", getenv("PRINTER"));
+  device_inhibited = colord_get_inhibit_for_device_id (tmpstr);
+  t = cupsGetOption("color-management", num_options, options);
+  if (t != NULL && strcmp(t, "off") == 0)
+    device_inhibited = 1;
+  if (device_inhibited)
+    fprintf(stderr, "DEBUG: Device is inhibited, no CM performed\n");
+  if (ppd)
+    qualifier = colord_get_qualifier_for_ppd (ppd);
+  if (qualifier != NULL) {
+
+    fprintf(stderr, "DEBUG: PPD uses qualifier '%s.%s.%s'\n",
+            qualifier[0], qualifier[1], qualifier[2]);
+
+    snprintf (tmpstr, sizeof(tmpstr), "cups-%s", getenv("PRINTER"));
+    icc_profile = colord_get_profile_for_device_id (tmpstr,
+                                                    (const char**) qualifier);
+
+    /* fall back to the PPD */
+    if (icc_profile == NULL)
+      icc_profile = get_ppd_icc_fallback (ppd, qualifier);
+
+    if(icc_profile != NULL)
+      fprintf(stderr, "DEBUG: Using ICC Profile '%s'\n", icc_profile);
+  }
+
+  /* Ghostscript parameters */
+  gs_args = cupsArrayNew(NULL, NULL);
+  if (!gs_args) {
+    fprintf(stderr, "ERROR: Unable to allocate memory for Ghostscript arguments array\n");
+    exit(1);
+  }
+
+  /* Part of Ghostscript command line which is not dependent on the job and/or
+     the driver */
+  snprintf(tmpstr, sizeof(tmpstr), "%s/%s", BINDIR, GS);
+  cupsArrayAdd(gs_args, strdup(tmpstr));
+  cupsArrayAdd(gs_args, strdup("-dQUIET"));
+  /*cupsArrayAdd(gs_args, strdup("-dDEBUG"));*/
+  cupsArrayAdd(gs_args, strdup("-dPARANOIDSAFER"));
+  cupsArrayAdd(gs_args, strdup("-dNOPAUSE"));
+  cupsArrayAdd(gs_args, strdup("-dBATCH"));
+  cupsArrayAdd(gs_args, strdup("-dNOINTERPOLATE"));
+  if (doc_type == GS_DOC_TYPE_PS)
+    cupsArrayAdd(gs_args, strdup("-dNOMEDIAATTRS"));
+  if (device_inhibited)
+    cupsArrayAdd(gs_args, strdup("-dUseFastColor"));
+  cupsArrayAdd(gs_args, strdup("-sDEVICE=cups"));
+  cupsArrayAdd(gs_args, strdup("-sstdout=%stderr"));
+  cupsArrayAdd(gs_args, strdup("-sOutputFile=%stdout"));
+
+  if (ppd)
+    cupsRasterInterpretPPD(&h,ppd,num_options,options,0);
+  else
+    cupsRasterParseIPPOptions(&h,num_options,options,1,1);
+
+  /* setPDF specific options */
+  if (doc_type == GS_DOC_TYPE_PDF) {
+    parse_pdf_header_options(fp, &h);
+  }
+
+  /* fixed other values that pdftopdf handles */
+  h.MirrorPrint = CUPS_FALSE;
+  h.Orientation = CUPS_ORIENT_0;
+
+  /* get all the data from the header and pass it to ghostscript */
+  add_pdf_header_options (&h, gs_args);
+
+  /* CUPS font path */
+  if ((t = getenv("CUPS_FONTPATH")) == NULL)
+    t = CUPS_FONTPATH;
+  snprintf(tmpstr, sizeof(tmpstr), "-I%s", t);
+  cupsArrayAdd(gs_args, strdup(tmpstr));
+
+  /* set the device output ICC profile */
+  if(icc_profile != NULL && icc_profile[0] != '\0') {
+    snprintf(tmpstr, sizeof(tmpstr), "-sOutputICCProfile=%s", icc_profile);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+
+  /* Switch to taking PostScript commands on the Ghostscript command line */
+  cupsArrayAdd(gs_args, strdup("-c"));
+
+  if ((t = cupsGetOption("profile", num_options, options)) != NULL) {
+    snprintf(tmpstr, sizeof(tmpstr), "<</cupsProfile(%s)>>setpagedevice", t);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+
+  /* Mark the end of PostScript commands supplied on the Ghostscript command
+     line (with the "-c" option), so that we can supply the input file name */
+  cupsArrayAdd(gs_args, strdup("-f"));
+
+  /* Let Ghostscript read from STDIN */
+  cupsArrayAdd(gs_args, strdup("-_"));
+
+  /* Execute Ghostscript command line ... */
+  snprintf(tmpstr, sizeof(tmpstr), "%s/%s", BINDIR, GS);
+
+  /* call Ghostscript */
+  rewind(fp);
+  status = gs_spawn (tmpstr, gs_args, envp, fp);
+out:
+  if (fp)
+    fclose(fp);
+  if (qualifier != NULL) {
+    for (i=0; qualifier[i] != NULL; i++)
+      free(qualifier[i]);
+    free(qualifier);
+  }
+  if (gs_args) {
+    while ((tmp = cupsArrayFirst(gs_args)) != NULL) {
+      cupsArrayRemove(gs_args,tmp);
+      free(tmp);
+    }
+    cupsArrayDelete(gs_args);
+  }
+  free(icc_profile);
+  if (ppd)
+    ppdClose(ppd);
+  return status;
+}
diff -up cups-filters-1.0.35/filter/pdftoraster.cxx.gs-filters cups-filters-1.0.35/filter/pdftoraster.cxx
--- cups-filters-1.0.35/filter/pdftoraster.cxx.gs-filters	2013-06-26 16:05:04.000000000 +0100
+++ cups-filters-1.0.35/filter/pdftoraster.cxx	2013-08-13 10:36:31.999178161 +0100
@@ -48,6 +48,7 @@ SOFTWARE OR THE USE OR OTHER DEALINGS IN
 #include "GlobalParams.h"
 #include <cups/raster.h>
 #include <cupsfilters/image.h>
+#include <cupsfilters/raster.h>
 #include <splash/SplashTypes.h>
 #include <splash/SplashBitmap.h>
 #include <strings.h>
@@ -357,80 +358,82 @@ static void parseOpts(int argc, char **a
   }
 
   ppd = ppdOpenFile(getenv("PPD"));
-  if (ppd == NULL) {
-    pdfError(-1,const_cast<char *>("PPD file is not specified"));
-    exit(1);
-  }
-  ppdMarkDefaults(ppd);
+  if (ppd == NULL)
+    fprintf(stderr, "DEBUG: PPD file is not specified.\n");
+  if (ppd)
+    ppdMarkDefaults(ppd);
   options = NULL;
   num_options = cupsParseOptions(argv[5],0,&options);
-  cupsMarkOptions(ppd,num_options,options);
-  handleRqeuiresPageRegion();
-  cupsRasterInterpretPPD(&header,ppd,num_options,options,0);
-  attr = ppdFindAttr(ppd,"pdftorasterRenderingIntent",NULL);
-  if (attr != NULL && attr->value != NULL) {
-    if (strcasecmp(attr->value,"PERCEPTUAL") != 0) {
-      renderingIntent = INTENT_PERCEPTUAL;
-    } else if (strcasecmp(attr->value,"RELATIVE_COLORIMETRIC") != 0) {
-      renderingIntent = INTENT_RELATIVE_COLORIMETRIC;
-    } else if (strcasecmp(attr->value,"SATURATION") != 0) {
-      renderingIntent = INTENT_SATURATION;
-    } else if (strcasecmp(attr->value,"ABSOLUTE_COLORIMETRIC") != 0) {
-      renderingIntent = INTENT_ABSOLUTE_COLORIMETRIC;
-    }
-  }
-  if (header.Duplex) {
-    /* analyze options relevant to Duplex */
-    const char *backside = "";
-    /* APDuplexRequiresFlippedMargin */
-    enum {
-      FM_NO, FM_FALSE, FM_TRUE
-    } flippedMargin = FM_NO;
-
-    attr = ppdFindAttr(ppd,"cupsBackSide",NULL);
-    if (attr != NULL && attr->value != NULL) {
-      ppd->flip_duplex = 0;
-      backside = attr->value;
-    } else if (ppd->flip_duplex) {
-      backside = "Rotated"; /* compatible with Max OS and GS 8.71 */
-    }
-
-    attr = ppdFindAttr(ppd,"APDuplexRequiresFlippedMargin",NULL);
+  if (ppd) {
+    cupsMarkOptions(ppd,num_options,options);
+    handleRqeuiresPageRegion();
+    cupsRasterInterpretPPD(&header,ppd,num_options,options,0);
+    attr = ppdFindAttr(ppd,"pdftorasterRenderingIntent",NULL);
     if (attr != NULL && attr->value != NULL) {
-      if (strcasecmp(attr->value,"true") == 0) {
-        flippedMargin = FM_TRUE;
-      } else {
-        flippedMargin = FM_FALSE;
+      if (strcasecmp(attr->value,"PERCEPTUAL") != 0) {
+	renderingIntent = INTENT_PERCEPTUAL;
+      } else if (strcasecmp(attr->value,"RELATIVE_COLORIMETRIC") != 0) {
+	renderingIntent = INTENT_RELATIVE_COLORIMETRIC;
+      } else if (strcasecmp(attr->value,"SATURATION") != 0) {
+	renderingIntent = INTENT_SATURATION;
+      } else if (strcasecmp(attr->value,"ABSOLUTE_COLORIMETRIC") != 0) {
+	renderingIntent = INTENT_ABSOLUTE_COLORIMETRIC;
       }
     }
-    if (strcasecmp(backside,"ManualTumble") == 0 && header.Tumble) {
-      swap_image_x = swap_image_y = true;
-      swap_margin_x = swap_margin_y = true;
-      if (flippedMargin == FM_TRUE) {
-        swap_margin_y = false;
-      }
-    } else if (strcasecmp(backside,"Rotated") == 0 && !header.Tumble) {
-      swap_image_x = swap_image_y = true;
-      swap_margin_x = swap_margin_y = true;
-      if (flippedMargin == FM_TRUE) {
-        swap_margin_y = false;
+    if (header.Duplex) {
+      /* analyze options relevant to Duplex */
+      const char *backside = "";
+      /* APDuplexRequiresFlippedMargin */
+      enum {
+	FM_NO, FM_FALSE, FM_TRUE
+      } flippedMargin = FM_NO;
+
+      attr = ppdFindAttr(ppd,"cupsBackSide",NULL);
+      if (attr != NULL && attr->value != NULL) {
+	ppd->flip_duplex = 0;
+	backside = attr->value;
+      } else if (ppd->flip_duplex) {
+	backside = "Rotated"; /* compatible with Max OS and GS 8.71 */
       }
-    } else if (strcasecmp(backside,"Flipped") == 0) {
-      if (header.Tumble) {
-        swap_image_x = true;
-        swap_margin_x = swap_margin_y = true;
-      } else {
-        swap_image_y = true;
+
+      attr = ppdFindAttr(ppd,"APDuplexRequiresFlippedMargin",NULL);
+      if (attr != NULL && attr->value != NULL) {
+	if (strcasecmp(attr->value,"true") == 0) {
+	  flippedMargin = FM_TRUE;
+	} else {
+	  flippedMargin = FM_FALSE;
+	}
       }
-      if (flippedMargin == FM_FALSE) {
-        swap_margin_y = !swap_margin_y;
+      if (strcasecmp(backside,"ManualTumble") == 0 && header.Tumble) {
+	swap_image_x = swap_image_y = true;
+	swap_margin_x = swap_margin_y = true;
+	if (flippedMargin == FM_TRUE) {
+	  swap_margin_y = false;
+	}
+      } else if (strcasecmp(backside,"Rotated") == 0 && !header.Tumble) {
+	swap_image_x = swap_image_y = true;
+	swap_margin_x = swap_margin_y = true;
+	if (flippedMargin == FM_TRUE) {
+	  swap_margin_y = false;
+	}
+      } else if (strcasecmp(backside,"Flipped") == 0) {
+	if (header.Tumble) {
+	  swap_image_x = true;
+	  swap_margin_x = swap_margin_y = true;
+	} else {
+	  swap_image_y = true;
+	}
+	if (flippedMargin == FM_FALSE) {
+	  swap_margin_y = !swap_margin_y;
+	}
       }
     }
-  }
-  if (getColorProfilePath(ppd,&profilePath)) {
-    /* ICCProfile is specified */
-    colorProfile = cmsOpenProfileFromFile(profilePath.getCString(),"r");
-  }
+    if (getColorProfilePath(ppd,&profilePath)) {
+      /* ICCProfile is specified */
+      colorProfile = cmsOpenProfileFromFile(profilePath.getCString(),"r");
+    }
+  } else
+    cupsRasterParseIPPOptions(&header,num_options,options,1,1);
 }
 
 static void parsePDFTOPDFComment(FILE *fp)
@@ -1548,48 +1551,23 @@ static void outPage(PDFDoc *doc, Catalog
 
   memset(paperdimensions, 0, sizeof(paperdimensions));
   memset(margins, 0, sizeof(margins));
-  for (i = ppd->num_sizes, size = ppd->sizes;
-       i > 0;
-       i --, size ++) {
-    /* Skip page sizes which conflict with settings of the other options */
-    /* TODO XXX */
-    /* Find size of document's page under the PPD page sizes */
-    if (fabs(header.PageSize[1] - size->length) < 5.0 &&
-	fabs(header.PageSize[0] - size->width) < 5.0)
-      break;
-  }
-  if (i > 0) {
-    /*
-     * Standard size...
-     */
-    fprintf(stderr, "DEBUG: size = %s\n", size->name);
-    landscape = 0;
-    paperdimensions[0] = size->width;
-    paperdimensions[1] = size->length;
-    margins[0] = size->left;
-    margins[1] = size->bottom;
-    margins[2] = size->width - size->right;
-    margins[3] = size->length - size->top;
-    strncpy(header.cupsPageSizeName, size->name, 64);
-  } else {
-    /*
-     * No matching portrait size; look for a matching size in
-     * landscape orientation...
-     */
-
+  if (ppd) {
     for (i = ppd->num_sizes, size = ppd->sizes;
 	 i > 0;
-	 i --, size ++)
-      if (fabs(header.PageSize[0] - size->length) < 5.0 &&
-	  fabs(header.PageSize[1] - size->width) < 5.0)
+	 i --, size ++) {
+      /* Skip page sizes which conflict with settings of the other options */
+      /* TODO XXX */
+      /* Find size of document's page under the PPD page sizes */
+      if (fabs(header.PageSize[1] - size->length) < 5.0 &&
+	  fabs(header.PageSize[0] - size->width) < 5.0)
 	break;
-
+    }
     if (i > 0) {
       /*
-       * Standard size in landscape orientation...
+       * Standard size...
        */
-      fprintf(stderr, "DEBUG: landscape size = %s\n", size->name);
-      landscape = 1;
+      fprintf(stderr, "DEBUG: size = %s\n", size->name);
+      landscape = 0;
       paperdimensions[0] = size->width;
       paperdimensions[1] = size->length;
       margins[0] = size->left;
@@ -1599,17 +1577,53 @@ static void outPage(PDFDoc *doc, Catalog
       strncpy(header.cupsPageSizeName, size->name, 64);
     } else {
       /*
-       * Custom size...
+       * No matching portrait size; look for a matching size in
+       * landscape orientation...
        */
-      fprintf(stderr, "DEBUG: size = Custom\n");
-      landscape = 0;
-      paperdimensions[1] = size->length;
-      for (i = 0; i < 2; i ++)
-	paperdimensions[i] = header.PageSize[i];
-      for (i = 0; i < 4; i ++)
-	margins[i] = ppd->custom_margins[i];
-      header.cupsPageSizeName[0] = '\0';
+
+      for (i = ppd->num_sizes, size = ppd->sizes;
+	   i > 0;
+	   i --, size ++)
+	if (fabs(header.PageSize[0] - size->length) < 5.0 &&
+	    fabs(header.PageSize[1] - size->width) < 5.0)
+	  break;
+
+      if (i > 0) {
+	/*
+	 * Standard size in landscape orientation...
+	 */
+	fprintf(stderr, "DEBUG: landscape size = %s\n", size->name);
+	landscape = 1;
+	paperdimensions[0] = size->width;
+	paperdimensions[1] = size->length;
+	margins[0] = size->left;
+	margins[1] = size->bottom;
+	margins[2] = size->width - size->right;
+	margins[3] = size->length - size->top;
+	strncpy(header.cupsPageSizeName, size->name, 64);
+      } else {
+	/*
+	 * Custom size...
+	 */
+	fprintf(stderr, "DEBUG: size = Custom\n");
+	landscape = 0;
+	paperdimensions[1] = size->length;
+	for (i = 0; i < 2; i ++)
+	  paperdimensions[i] = header.PageSize[i];
+	for (i = 0; i < 4; i ++)
+	  margins[i] = ppd->custom_margins[i];
+	header.cupsPageSizeName[0] = '\0';
+      }
     }
+  } else {
+    for (i = 0; i < 2; i ++)
+      paperdimensions[i] = header.PageSize[i];
+    for (i = 0; i < 4; i ++)
+      margins[i] = 0.0;
+    /*margins[0] = 0.0;
+    margins[1] = 0.0;
+    margins[2] = header.PageSize[0];
+    margins[3] = header.PageSize[1];*/
   }
 
   if (header.Duplex && (pageNo & 1) == 0) {
diff -up cups-filters-1.0.35/Makefile.am.gs-filters cups-filters-1.0.35/Makefile.am
--- cups-filters-1.0.35/Makefile.am.gs-filters	2013-07-29 16:10:21.793413604 +0100
+++ cups-filters-1.0.35/Makefile.am	2013-08-13 10:36:31.967178014 +0100
@@ -79,7 +79,8 @@ EXTRA_DIST += $(pkgcharset_DATA)
 pkgfiltersincludedir = $(includedir)/cupsfilters
 pkgfiltersinclude_DATA = \
 	cupsfilters/driver.h \
-	cupsfilters/image.h
+	cupsfilters/image.h \
+	cupsfilters/raster.h
 
 lib_LTLIBRARIES = libcupsfilters.la
 
@@ -127,6 +128,7 @@ libcupsfilters_la_SOURCES = \
 	cupsfilters/image-zoom.c \
 	cupsfilters/lut.c \
 	cupsfilters/pack.c \
+	cupsfilters/raster.c \
 	cupsfilters/rgb.c \
 	cupsfilters/srgb.c \
 	$(pkgfiltersinclude_DATA)
@@ -389,6 +391,7 @@ pdftopdf_LDADD = \
 # Simple filter binaries
 # ======================
 pkgfilter_SCRIPTS = \
+	filter/gstopxl \
 	filter/imagetops \
 	filter/pstopdf \
 	filter/textonly \
@@ -397,6 +400,7 @@ pkgfilter_PROGRAMS += \
 	bannertopdf \
 	commandtoescpx \
 	commandtopclx \
+	gstoraster \
 	pdftoijs \
 	pdftops \
 	pdftoraster \
@@ -459,6 +463,18 @@ commandtopclx_CFLAGS = \
 	-I$(srcdir)/cupsfilters/
 commandtopclx_LDADD = $(CUPS_LIBS)
 
+gstoraster_SOURCES = \
+	filter/gstoraster.c \
+	filter/colord.c \
+	filter/colord.h \
+	cupsfilters/raster.h
+gstoraster_CFLAGS = \
+	$(CUPS_CFLAGS) \
+	-I$(srcdir)/cupsfilters/
+gstoraster_LDADD = \
+	$(CUPS_LIBS) \
+	-lcupsfilters
+
 imagetopdf_SOURCES = \
 	cupsfilters/image.h \
 	filter/common.c \
@@ -649,6 +665,8 @@ ppd_DATA = \
 	ppd/Generic-PDF_Printer-PDF.ppd \
 	ppd/HP-Color_LaserJet_CM3530_MFP-PDF.ppd \
 	ppd/HP-PhotoSmart_Pro_B8300-hpijs-pdftoijs.ppd \
+	ppd/pxlcolor.ppd \
+	ppd/pxlmono.ppd \
 	ppd/textonly.ppd
 
 EXTRA_DIST += $(ppd_DATA)
diff -up cups-filters-1.0.35/mime/cupsfilters.convs.gs-filters cups-filters-1.0.35/mime/cupsfilters.convs
--- cups-filters-1.0.35/mime/cupsfilters.convs.gs-filters	2013-07-29 16:10:21.799413632 +0100
+++ cups-filters-1.0.35/mime/cupsfilters.convs	2013-08-13 10:36:32.004178184 +0100
@@ -84,6 +84,8 @@ application/vnd.cups-pdf	application/vnd
 # Raster filters...
 #
 
+application/vnd.cups-pdf	application/vnd.cups-raster	66	gstoraster
+application/vnd.cups-postscript	application/vnd.cups-raster	100	gstoraster
 application/vnd.cups-pdf	application/vnd.cups-raster	100	pdftoraster
 image/gif			application/vnd.cups-raster	100	imagetoraster
 image/png			application/vnd.cups-raster	100	imagetoraster
diff -up cups-filters-1.0.35/NEWS.gs-filters cups-filters-1.0.35/NEWS
diff -up cups-filters-1.0.35/ppd/pxlcolor.ppd.gs-filters cups-filters-1.0.35/ppd/pxlcolor.ppd
--- cups-filters-1.0.35/ppd/pxlcolor.ppd.gs-filters	2013-08-13 10:36:32.005178188 +0100
+++ cups-filters-1.0.35/ppd/pxlcolor.ppd	2013-08-13 10:36:32.005178188 +0100
@@ -0,0 +1,215 @@
+*PPD-Adobe: "4.3"
+*%
+*%
+*%   Sample color PCL XL/PCL 6 driver PPD file for the Common UNIX
+*%   Printing System (CUPS).
+*%
+*%   Copyright 1997-2005 by Easy Software Products.
+*%
+*%   These coded instructions, statements, and computer programs are the
+*%   property of Easy Software Products and are protected by Federal
+*%   copyright law.  Distribution and use rights are outlined in the file
+*%   "LICENSE.txt" which should have been included with this file.  If this
+*%   file is missing or damaged please contact Easy Software Products
+*%   at:
+*%
+*%       Attn: CUPS Licensing Information
+*%       Easy Software Products
+*%       44141 Airport View Drive, Suite 204
+*%       Hollywood, Maryland 20636 USA
+*%
+*%       Voice: (301) 373-9600
+*%       EMail: cups-info@cups.org
+*%         WWW: http://www.cups.org
+*%
+*FormatVersion:	"4.3"
+*FileVersion:	"1.1"
+*LanguageVersion: English 
+*LanguageEncoding: ISOLatin1
+*PCFileName:	"PXLCOLOR.PPD"
+*Manufacturer:	"HP"
+*Product:	"(GPL Ghostscript)"
+*cupsVersion:	1.1
+*cupsManualCopies: False
+*cupsFilter:	"application/vnd.cups-postscript 100 gstopxl"
+*cupsFilter:	"application/vnd.cups-pdf 0 gstopxl"
+*ModelName:     "HP Color LaserJet Series PCL 6"
+*ShortNickName: "HP Color LaserJet Series PCL 6"
+*NickName:      "HP Color LaserJet Series PCL 6 CUPS"
+*PSVersion:	"(3010.000) 86000"
+*LanguageLevel:	"3"
+*ColorDevice:	True
+*DefaultColorSpace: RGB
+*FileSystem:	False
+*Throughput:	"8"
+*LandscapeOrientation: Plus90
+*TTRasterizer:	Type42
+
+*UIConstraints: *PageSize Executive *InputSlot Envelope
+*UIConstraints: *PageSize Letter *InputSlot Envelope
+*UIConstraints: *PageSize Legal *InputSlot Envelope
+*UIConstraints: *PageSize Tabloid *InputSlot Envelope
+*UIConstraints: *PageSize A3 *InputSlot Envelope
+*UIConstraints: *PageSize A4 *InputSlot Envelope
+*UIConstraints: *PageSize A5 *InputSlot Envelope
+*UIConstraints: *PageSize B5 *InputSlot Envelope
+*UIConstraints:	*Duplex *OptionDuplex False
+*UIConstraints: *InputSlot Envelope *PageSize Executive
+*UIConstraints: *InputSlot Envelope *PageSize Letter
+*UIConstraints: *InputSlot Envelope *PageSize Legal
+*UIConstraints: *InputSlot Envelope *PageSize Tabloid
+*UIConstraints: *InputSlot Envelope *PageSize A3
+*UIConstraints: *InputSlot Envelope *PageSize A4
+*UIConstraints: *InputSlot Envelope *PageSize A5
+*UIConstraints: *InputSlot Envelope *PageSize B5
+*UIConstraints:	*OptionDuplex False *Duplex
+
+*OpenUI *PageSize/Media Size: PickOne
+*OrderDependency: 10 AnySetup *PageSize
+*DefaultPageSize: Letter
+*PageSize Letter/US Letter:	"<</PageSize[612 792]/ImagingBBox null>>setpagedevice"
+*PageSize Legal/US Legal:	"<</PageSize[612 1008]/ImagingBBox null>>setpagedevice"
+*PageSize Executive/US Executive: "<</PageSize[522 756]/ImagingBBox null>>setpagedevice"
+*PageSize Tabloid/US Tabloid:	"<</PageSize[792 1224]/ImagingBBox null>>setpagedevice"
+*PageSize A3/A3:		"<</PageSize[842 1191]/ImagingBBox null>>setpagedevice"
+*PageSize A4/A4:		"<</PageSize[595 842]/ImagingBBox null>>setpagedevice"
+*PageSize A5/A5:		"<</PageSize[421 595]/ImagingBBox null>>setpagedevice"
+*PageSize B5/B5 (JIS):		"<</PageSize[516 729]/ImagingBBox null>>setpagedevice"
+*PageSize EnvISOB5/Envelope B5: "<</PageSize[499 709]/ImagingBBox null>>setpagedevice"
+*PageSize Env10/Envelope #10:	"<</PageSize[297 684]/ImagingBBox null>>setpagedevice"
+*PageSize EnvC5/Envelope C5:	"<</PageSize[459 649]/ImagingBBox null>>setpagedevice"
+*PageSize EnvDL/Envelope DL:	"<</PageSize[312 624]/ImagingBBox null>>setpagedevice"
+*PageSize EnvMonarch/Envelope Monarch: "<</PageSize[279 540]/ImagingBBox null>>setpagedevice"
+*CloseUI: *PageSize
+
+*OpenUI *PageRegion: PickOne
+*OrderDependency: 10 AnySetup *PageRegion
+*DefaultPageRegion: Letter
+*PageRegion Letter/US Letter:	"<</PageSize[612 792]/ImagingBBox null>>setpagedevice"
+*PageRegion Legal/US Legal:	"<</PageSize[612 1008]/ImagingBBox null>>setpagedevice"
+*PageRegion Executive/US Executive: "<</PageSize[522 756]/ImagingBBox null>>setpagedevice"
+*PageRegion Tabloid/US Tabloid:	"<</PageSize[792 1224]/ImagingBBox null>>setpagedevice"
+*PageRegion A3/A3:		"<</PageSize[842 1191]/ImagingBBox null>>setpagedevice"
+*PageRegion A4/A4:		"<</PageSize[595 842]/ImagingBBox null>>setpagedevice"
+*PageRegion A5/A5:		"<</PageSize[421 595]/ImagingBBox null>>setpagedevice"
+*PageRegion B5/B5 (JIS):	"<</PageSize[516 729]/ImagingBBox null>>setpagedevice"
+*PageRegion EnvISOB5/Envelope B5: "<</PageSize[499 709]/ImagingBBox null>>setpagedevice"
+*PageRegion Env10/Envelope #10:	"<</PageSize[297 684]/ImagingBBox null>>setpagedevice"
+*PageRegion EnvC5/Envelope C5:	"<</PageSize[459 649]/ImagingBBox null>>setpagedevice"
+*PageRegion EnvDL/Envelope DL:	"<</PageSize[312 624]/ImagingBBox null>>setpagedevice"
+*PageRegion EnvMonarch/Envelope Monarch: "<</PageSize[279 540]/ImagingBBox null>>setpagedevice"
+*CloseUI: *PageRegion
+
+*DefaultImageableArea: Letter 
+*ImageableArea Letter/US Letter:	"12 12 600 780"
+*ImageableArea Legal/US Legal:		"12 12 600 996"
+*ImageableArea Executive/US Executive:	"12 12 510 708"
+*ImageableArea Tabloid/US Tabloid:	"12 12 780 1212"
+*ImageableArea A3/A3:			"12 12 830 1179"
+*ImageableArea A4/A4:			"12 12 583 830"
+*ImageableArea A5/A5:			"12 12 409 583"
+*ImageableArea B5/JIS B5:		"12 12 504 717"
+*ImageableArea EnvISOB5/B5 (ISO):	"12 12 469 697"
+*ImageableArea Env10/Com-10:		"12 12 285 672"
+*ImageableArea EnvC5/EnvC5:		"12 12 447 637"
+*ImageableArea EnvDL/EnvDL:		"12 12 300 612"
+*ImageableArea EnvMonarch/Envelope Monarch: "12 12 267 528"
+
+*DefaultPaperDimension: Letter
+*PaperDimension Letter/US Letter:	"612 792"
+*PaperDimension Legal/US Legal:		"612 1008"
+*PaperDimension Executive/US Executive:	"522 756"
+*PaperDimension Tabloid/US Tabloid:	"792 1224"
+*PaperDimension A3/A3:			"842 1191"
+*PaperDimension A4/A4:			"595 842"
+*PaperDimension A5/A5:			"421 595"
+*PaperDimension B5/B5 (JIS):		"516 729"
+*PaperDimension EnvISOB5/Envelope B5:	"499 709"
+*PaperDimension Env10/Envelope #10:	"297 684"
+*PaperDimension EnvC5/Envelope C5:	"459 649"
+*PaperDimension EnvDL/Envelope DL:	"312 624"
+*PaperDimension EnvMonarch/Envelope Monarch: "279 540"
+
+*OpenUI *InputSlot/Media Source: PickOne
+*OrderDependency: 10 AnySetup *InputSlot
+*DefaultInputSlot: Default
+*InputSlot Default/Default: "<</MediaPosition 0>>setpagedevice"
+*InputSlot Auto/Automatically Select: "<</MediaPosition 1>>setpagedevice"
+*InputSlot MultiPurpose/Tray 1: "<</MediaPosition 3>>setpagedevice"
+*InputSlot Upper/Tray 2: "<</MediaPosition 4>>setpagedevice"
+*InputSlot Lower/Tray 3: "<</MediaPosition 5>>setpagedevice"
+*InputSlot LargeCapacity/Tray 4: "<</MediaPosition 7>>setpagedevice"
+*InputSlot Manual/Manual Feed: "<</MediaPosition 2>>setpagedevice"
+*InputSlot Envelope/Envelope Feed: "<</MediaPosition 6>>setpagedevice"
+*CloseUI: *InputSlot
+
+*OpenUI *ColorModel/Output Mode: PickOne
+*OrderDependency: 10 AnySetup *ColorModel
+*DefaultColorModel: RGB
+*ColorModel RGB/Color: "<</BitsPerPixel 24>>setpagedevice"
+*ColorModel Gray/Grayscale: "<</BitsPerPixel 8>>setpagedevice"
+*CloseUI: *ColorModel
+
+*OpenUI *Resolution/Output Resolution: PickOne
+*OrderDependency: 20 AnySetup *Resolution
+*DefaultResolution: 600dpi
+*Resolution 150dpi/150 DPI: "<</HWResolution[150 150]>>setpagedevice"
+*Resolution 300dpi/300 DPI: "<</HWResolution[300 300]>>setpagedevice"
+*Resolution 600dpi/600 DPI: "<</HWResolution[600 600]>>setpagedevice"
+*Resolution 1200dpi/1200 DPI: "<</HWResolution[1200 1200]>>setpagedevice"
+*CloseUI: *Resolution
+
+*OpenUI *Duplex/Double-Sided Printing: PickOne
+*OrderDependency: 20 AnySetup *Duplex
+*DefaultDuplex: None
+*Duplex None/Off:	"<</Duplex false>>setpagedevice"
+*Duplex DuplexNoTumble/Long Edge (Standard):	"<</Duplex true/Tumble false>>setpagedevice"
+*Duplex DuplexTumble/Short Edge (Flip):	"<</Duplex true/Tumble true>>setpagedevice"
+*CloseUI:	*Duplex
+
+*OpenGroup: InstallableOptions
+*OpenUI *OptionDuplex/Duplexer: Boolean
+*DefaultOptionDuplex: False
+*OptionDuplex True/Installed:	""
+*OptionDuplex False/Not Installed:	""
+*CloseUI: *OptionDuplex
+*CloseGroup: InstallableOptions
+
+*DefaultFont: Courier
+*Font AvantGarde-Book: Standard "(001.006S)" Standard ROM
+*Font AvantGarde-BookOblique: Standard "(001.006S)" Standard ROM
+*Font AvantGarde-Demi: Standard "(001.007S)" Standard ROM
+*Font AvantGarde-DemiOblique: Standard "(001.007S)" Standard ROM
+*Font Bookman-Demi: Standard "(001.004S)" Standard ROM
+*Font Bookman-DemiItalic: Standard "(001.004S)" Standard ROM
+*Font Bookman-Light: Standard "(001.004S)" Standard ROM
+*Font Bookman-LightItalic: Standard "(001.004S)" Standard ROM
+*Font Courier: Standard "(002.004S)" Standard ROM
+*Font Courier-Bold: Standard "(002.004S)" Standard ROM
+*Font Courier-BoldOblique: Standard "(002.004S)" Standard ROM
+*Font Courier-Oblique: Standard "(002.004S)" Standard ROM
+*Font Helvetica: Standard "(001.006S)" Standard ROM
+*Font Helvetica-Bold: Standard "(001.007S)" Standard ROM
+*Font Helvetica-BoldOblique: Standard "(001.007S)" Standard ROM
+*Font Helvetica-Narrow: Standard "(001.006S)" Standard ROM
+*Font Helvetica-Narrow-Bold: Standard "(001.007S)" Standard ROM
+*Font Helvetica-Narrow-BoldOblique: Standard "(001.007S)" Standard ROM
+*Font Helvetica-Narrow-Oblique: Standard "(001.006S)" Standard ROM
+*Font Helvetica-Oblique: Standard "(001.006S)" Standard ROM
+*Font NewCenturySchlbk-Bold: Standard "(001.009S)" Standard ROM
+*Font NewCenturySchlbk-BoldItalic: Standard "(001.007S)" Standard ROM
+*Font NewCenturySchlbk-Italic: Standard "(001.006S)" Standard ROM
+*Font NewCenturySchlbk-Roman: Standard "(001.007S)" Standard ROM
+*Font Palatino-Bold: Standard "(001.005S)" Standard ROM
+*Font Palatino-BoldItalic: Standard "(001.005S)" Standard ROM
+*Font Palatino-Italic: Standard "(001.005S)" Standard ROM
+*Font Palatino-Roman: Standard "(001.005S)" Standard ROM
+*Font Symbol: Special "(001.007S)" Special ROM
+*Font Times-Bold: Standard "(001.007S)" Standard ROM
+*Font Times-BoldItalic: Standard "(001.009S)" Standard ROM
+*Font Times-Italic: Standard "(001.007S)" Standard ROM
+*Font Times-Roman: Standard "(001.007S)" Standard ROM
+*Font ZapfChancery-MediumItalic: Standard "(001.007S)" Standard ROM
+*Font ZapfDingbats: Special "(001.004S)" Standard ROM
+*%
+*%
diff -up cups-filters-1.0.35/ppd/pxlmono.ppd.gs-filters cups-filters-1.0.35/ppd/pxlmono.ppd
--- cups-filters-1.0.35/ppd/pxlmono.ppd.gs-filters	2013-08-13 10:36:32.006178193 +0100
+++ cups-filters-1.0.35/ppd/pxlmono.ppd	2013-08-13 10:36:32.006178193 +0100
@@ -0,0 +1,208 @@
+*PPD-Adobe: "4.3"
+*%
+*%
+*%   Sample monochrome PCL XL/PCL 6 driver PPD file for the Common UNIX
+*%   Printing System (CUPS).
+*%
+*%   Copyright 1997-2005 by Easy Software Products.
+*%
+*%   These coded instructions, statements, and computer programs are the
+*%   property of Easy Software Products and are protected by Federal
+*%   copyright law.  Distribution and use rights are outlined in the file
+*%   "LICENSE.txt" which should have been included with this file.  If this
+*%   file is missing or damaged please contact Easy Software Products
+*%   at:
+*%
+*%       Attn: CUPS Licensing Information
+*%       Easy Software Products
+*%       44141 Airport View Drive, Suite 204
+*%       Hollywood, Maryland 20636 USA
+*%
+*%       Voice: (301) 373-9600
+*%       EMail: cups-info@cups.org
+*%         WWW: http://www.cups.org
+*%
+*FormatVersion:	"4.3"
+*FileVersion:	"1.1"
+*LanguageVersion: English 
+*LanguageEncoding: ISOLatin1
+*PCFileName:	"PXLMONO.PPD"
+*Manufacturer:	"HP"
+*Product:	"(GPL Ghostscript)"
+*cupsVersion:	1.1
+*cupsManualCopies: False
+*cupsFilter:	"application/vnd.cups-postscript 100 gstopxl"
+*cupsFilter:	"application/vnd.cups-pdf 0 gstopxl"
+*ModelName:     "HP LaserJet Series PCL 6"
+*ShortNickName: "HP LaserJet Series PCL 6"
+*NickName:      "HP LaserJet Series PCL 6 CUPS"
+*PSVersion:	"(3010.000) 86000"
+*LanguageLevel:	"3"
+*ColorDevice:	False
+*DefaultColorSpace: Gray
+*FileSystem:	False
+*Throughput:	"8"
+*LandscapeOrientation: Plus90
+*TTRasterizer:	Type42
+
+*UIConstraints: *PageSize Executive *InputSlot Envelope
+*UIConstraints: *PageSize Letter *InputSlot Envelope
+*UIConstraints: *PageSize Legal *InputSlot Envelope
+*UIConstraints: *PageSize Tabloid *InputSlot Envelope
+*UIConstraints: *PageSize A3 *InputSlot Envelope
+*UIConstraints: *PageSize A4 *InputSlot Envelope
+*UIConstraints: *PageSize A5 *InputSlot Envelope
+*UIConstraints: *PageSize B5 *InputSlot Envelope
+*UIConstraints:	*Duplex *OptionDuplex False
+*UIConstraints: *InputSlot Envelope *PageSize Executive
+*UIConstraints: *InputSlot Envelope *PageSize Letter
+*UIConstraints: *InputSlot Envelope *PageSize Legal
+*UIConstraints: *InputSlot Envelope *PageSize Tabloid
+*UIConstraints: *InputSlot Envelope *PageSize A3
+*UIConstraints: *InputSlot Envelope *PageSize A4
+*UIConstraints: *InputSlot Envelope *PageSize A5
+*UIConstraints: *InputSlot Envelope *PageSize B5
+*UIConstraints:	*OptionDuplex False *Duplex
+
+*OpenUI *PageSize/Media Size: PickOne
+*OrderDependency: 10 AnySetup *PageSize
+*DefaultPageSize: Letter
+*PageSize Letter/US Letter:	"<</PageSize[612 792]/ImagingBBox null>>setpagedevice"
+*PageSize Legal/US Legal:	"<</PageSize[612 1008]/ImagingBBox null>>setpagedevice"
+*PageSize Executive/US Executive: "<</PageSize[522 756]/ImagingBBox null>>setpagedevice"
+*PageSize Tabloid/US Tabloid:	"<</PageSize[792 1224]/ImagingBBox null>>setpagedevice"
+*PageSize A3/A3:		"<</PageSize[842 1191]/ImagingBBox null>>setpagedevice"
+*PageSize A4/A4:		"<</PageSize[595 842]/ImagingBBox null>>setpagedevice"
+*PageSize A5/A5:		"<</PageSize[421 595]/ImagingBBox null>>setpagedevice"
+*PageSize B5/B5 (JIS):		"<</PageSize[516 729]/ImagingBBox null>>setpagedevice"
+*PageSize EnvISOB5/Envelope B5: "<</PageSize[499 709]/ImagingBBox null>>setpagedevice"
+*PageSize Env10/Envelope #10:	"<</PageSize[297 684]/ImagingBBox null>>setpagedevice"
+*PageSize EnvC5/Envelope C5:	"<</PageSize[459 649]/ImagingBBox null>>setpagedevice"
+*PageSize EnvDL/Envelope DL:	"<</PageSize[312 624]/ImagingBBox null>>setpagedevice"
+*PageSize EnvMonarch/Envelope Monarch: "<</PageSize[279 540]/ImagingBBox null>>setpagedevice"
+*CloseUI: *PageSize
+
+*OpenUI *PageRegion: PickOne
+*OrderDependency: 10 AnySetup *PageRegion
+*DefaultPageRegion: Letter
+*PageRegion Letter/US Letter:	"<</PageSize[612 792]/ImagingBBox null>>setpagedevice"
+*PageRegion Legal/US Legal:	"<</PageSize[612 1008]/ImagingBBox null>>setpagedevice"
+*PageRegion Executive/US Executive: "<</PageSize[522 756]/ImagingBBox null>>setpagedevice"
+*PageRegion Tabloid/US Tabloid:	"<</PageSize[792 1224]/ImagingBBox null>>setpagedevice"
+*PageRegion A3/A3:		"<</PageSize[842 1191]/ImagingBBox null>>setpagedevice"
+*PageRegion A4/A4:		"<</PageSize[595 842]/ImagingBBox null>>setpagedevice"
+*PageRegion A5/A5:		"<</PageSize[421 595]/ImagingBBox null>>setpagedevice"
+*PageRegion B5/B5 (JIS):	"<</PageSize[516 729]/ImagingBBox null>>setpagedevice"
+*PageRegion EnvISOB5/Envelope B5: "<</PageSize[499 709]/ImagingBBox null>>setpagedevice"
+*PageRegion Env10/Envelope #10:	"<</PageSize[297 684]/ImagingBBox null>>setpagedevice"
+*PageRegion EnvC5/Envelope C5:	"<</PageSize[459 649]/ImagingBBox null>>setpagedevice"
+*PageRegion EnvDL/Envelope DL:	"<</PageSize[312 624]/ImagingBBox null>>setpagedevice"
+*PageRegion EnvMonarch/Envelope Monarch: "<</PageSize[279 540]/ImagingBBox null>>setpagedevice"
+*CloseUI: *PageRegion
+
+*DefaultImageableArea: Letter 
+*ImageableArea Letter/US Letter:	"12 12 600 780"
+*ImageableArea Legal/US Legal:		"12 12 600 996"
+*ImageableArea Executive/US Executive:	"12 12 510 708"
+*ImageableArea Tabloid/US Tabloid:	"12 12 780 1212"
+*ImageableArea A3/A3:			"12 12 830 1179"
+*ImageableArea A4/A4:			"12 12 583 830"
+*ImageableArea A5/A5:			"12 12 409 583"
+*ImageableArea B5/JIS B5:		"12 12 504 717"
+*ImageableArea EnvISOB5/B5 (ISO):	"12 12 469 697"
+*ImageableArea Env10/Com-10:		"12 12 285 672"
+*ImageableArea EnvC5/EnvC5:		"12 12 447 637"
+*ImageableArea EnvDL/EnvDL:		"12 12 300 612"
+*ImageableArea EnvMonarch/Envelope Monarch: "12 12 267 528"
+
+*DefaultPaperDimension: Letter
+*PaperDimension Letter/US Letter:	"612 792"
+*PaperDimension Legal/US Legal:		"612 1008"
+*PaperDimension Executive/US Executive:	"522 756"
+*PaperDimension Tabloid/US Tabloid:	"792 1224"
+*PaperDimension A3/A3:			"842 1191"
+*PaperDimension A4/A4:			"595 842"
+*PaperDimension A5/A5:			"421 595"
+*PaperDimension B5/B5 (JIS):		"516 729"
+*PaperDimension EnvISOB5/Envelope B5:	"499 709"
+*PaperDimension Env10/Envelope #10:	"297 684"
+*PaperDimension EnvC5/Envelope C5:	"459 649"
+*PaperDimension EnvDL/Envelope DL:	"312 624"
+*PaperDimension EnvMonarch/Envelope Monarch: "279 540"
+
+*OpenUI *InputSlot/Media Source: PickOne
+*OrderDependency: 10 AnySetup *InputSlot
+*DefaultInputSlot: Default
+*InputSlot Default/Default: "<</MediaPosition 0>>setpagedevice"
+*InputSlot Auto/Automatically Select: "<</MediaPosition 1>>setpagedevice"
+*InputSlot MultiPurpose/Tray 1: "<</MediaPosition 3>>setpagedevice"
+*InputSlot Upper/Tray 2: "<</MediaPosition 4>>setpagedevice"
+*InputSlot Lower/Tray 3: "<</MediaPosition 5>>setpagedevice"
+*InputSlot LargeCapacity/Tray 4: "<</MediaPosition 7>>setpagedevice"
+*InputSlot Manual/Manual Feed: "<</MediaPosition 2>>setpagedevice"
+*InputSlot Envelope/Envelope Feed: "<</MediaPosition 6>>setpagedevice"
+*CloseUI: *InputSlot
+
+*OpenUI *Resolution/Output Resolution: PickOne
+*OrderDependency: 20 AnySetup *Resolution
+*DefaultResolution: 600dpi
+*Resolution 150dpi/150 DPI: "<</HWResolution[150 150]>>setpagedevice"
+*Resolution 300dpi/300 DPI: "<</HWResolution[300 300]>>setpagedevice"
+*Resolution 600dpi/600 DPI: "<</HWResolution[600 600]>>setpagedevice"
+*Resolution 1200dpi/1200 DPI: "<</HWResolution[1200 1200]>>setpagedevice"
+*CloseUI: *Resolution
+
+*OpenUI *Duplex/Double-Sided Printing: PickOne
+*OrderDependency: 20 AnySetup *Duplex
+*DefaultDuplex: None
+*Duplex None/Off:	"<</Duplex false>>setpagedevice"
+*Duplex DuplexNoTumble/Long Edge (Standard):	"<</Duplex true/Tumble false>>setpagedevice"
+*Duplex DuplexTumble/Short Edge (Flip):	"<</Duplex true/Tumble true>>setpagedevice"
+*CloseUI:	*Duplex
+
+*OpenGroup: InstallableOptions
+*OpenUI *OptionDuplex/Duplexer: Boolean
+*DefaultOptionDuplex: False
+*OptionDuplex True/Installed:	""
+*OptionDuplex False/Not Installed:	""
+*CloseUI: *OptionDuplex
+*CloseGroup: InstallableOptions
+
+*DefaultFont: Courier
+*Font AvantGarde-Book: Standard "(001.006S)" Standard ROM
+*Font AvantGarde-BookOblique: Standard "(001.006S)" Standard ROM
+*Font AvantGarde-Demi: Standard "(001.007S)" Standard ROM
+*Font AvantGarde-DemiOblique: Standard "(001.007S)" Standard ROM
+*Font Bookman-Demi: Standard "(001.004S)" Standard ROM
+*Font Bookman-DemiItalic: Standard "(001.004S)" Standard ROM
+*Font Bookman-Light: Standard "(001.004S)" Standard ROM
+*Font Bookman-LightItalic: Standard "(001.004S)" Standard ROM
+*Font Courier: Standard "(002.004S)" Standard ROM
+*Font Courier-Bold: Standard "(002.004S)" Standard ROM
+*Font Courier-BoldOblique: Standard "(002.004S)" Standard ROM
+*Font Courier-Oblique: Standard "(002.004S)" Standard ROM
+*Font Helvetica: Standard "(001.006S)" Standard ROM
+*Font Helvetica-Bold: Standard "(001.007S)" Standard ROM
+*Font Helvetica-BoldOblique: Standard "(001.007S)" Standard ROM
+*Font Helvetica-Narrow: Standard "(001.006S)" Standard ROM
+*Font Helvetica-Narrow-Bold: Standard "(001.007S)" Standard ROM
+*Font Helvetica-Narrow-BoldOblique: Standard "(001.007S)" Standard ROM
+*Font Helvetica-Narrow-Oblique: Standard "(001.006S)" Standard ROM
+*Font Helvetica-Oblique: Standard "(001.006S)" Standard ROM
+*Font NewCenturySchlbk-Bold: Standard "(001.009S)" Standard ROM
+*Font NewCenturySchlbk-BoldItalic: Standard "(001.007S)" Standard ROM
+*Font NewCenturySchlbk-Italic: Standard "(001.006S)" Standard ROM
+*Font NewCenturySchlbk-Roman: Standard "(001.007S)" Standard ROM
+*Font Palatino-Bold: Standard "(001.005S)" Standard ROM
+*Font Palatino-BoldItalic: Standard "(001.005S)" Standard ROM
+*Font Palatino-Italic: Standard "(001.005S)" Standard ROM
+*Font Palatino-Roman: Standard "(001.005S)" Standard ROM
+*Font Symbol: Special "(001.007S)" Special ROM
+*Font Times-Bold: Standard "(001.007S)" Standard ROM
+*Font Times-BoldItalic: Standard "(001.009S)" Standard ROM
+*Font Times-Italic: Standard "(001.007S)" Standard ROM
+*Font Times-Roman: Standard "(001.007S)" Standard ROM
+*Font ZapfChancery-MediumItalic: Standard "(001.007S)" Standard ROM
+*Font ZapfDingbats: Special "(001.004S)" Standard ROM
+*%
+*%
